resources:
- name: Connection
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
- name: Channel
  endpoint:
    path: /api/channels
    method: GET
    data_selector: channels
- name: Channel
  endpoint:
    path: /channel
    method: GET
    data_selector: records
- name: Connection
  endpoint:
    path: /connection
    method: GET
    data_selector: records
- name: hello_queue
  endpoint:
    path: /queues/hello
    method: POST
    data_selector: messages
    params: {}
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: rabbitmq_server
  endpoint:
    path: /rabbitmq-server/releases
    method: GET
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: hello_queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: queue_hello
  endpoint:
    path: /api/queues/hello
    method: GET
    data_selector: messages
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: send_message
  endpoint:
    path: /send
    method: POST
    data_selector: message
    params: {}
- name: receive_message
  endpoint:
    path: /receive
    method: GET
    data_selector: message
    params: {}
- name: hello
  endpoint:
    path: /tutorials/tutorial-one-ruby
    method: GET
    data_selector: messages
    params: {}
- name: hello_queue
  endpoint:
    path: /queues/hello
    method: POST
    data_selector: message
    params: {}
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: hello
  endpoint:
    path: /
    method: POST
    data_selector: message
    params: {}
- name: hello_queue
  endpoint:
    path: /hello
    method: POST
    data_selector: message
    params: {}
- name: hello
  endpoint:
    path: /
    method: GET
    data_selector: messages
    params: {}
- name: hello_queue
  endpoint:
    path: /
    method: POST
    data_selector: message
    params: {}
- name: queue
  endpoint:
    path: /queue/hello
    method: GET
    data_selector: message
    params: {}
- name: hello_queue
  endpoint:
    path: /hello
    method: POST
    data_selector: message
    params: {}
- name: hello_queue
  endpoint:
    path: /queues/hello
    method: GET
    data_selector: messages
    params: {}
- name: hello
  endpoint:
    path: /
    method: POST
    data_selector: message
- name: task_queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: hello
  endpoint:
    path: queue/hello
    method: GET
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: task_queue
  endpoint:
    path: /
    method: POST
    data_selector: messages
- name: hello_queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: message
    params:
      durable: true
      persistent: true
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: message
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
- name: task_queue
  endpoint:
    path: /task_queue
    method: GET
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: message
    params:
      persistent: true
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: message
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: msg
    params: {}
- name: task_queue
  endpoint:
    path: /queues/task_queue
    method: GET
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
- name: worker
  endpoint:
    path: /worker
    method: GET
    data_selector: messages
- name: task_queue
  endpoint:
    path: /api/queues/task_queue
    method: POST
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: GET
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: GET
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: message
    params:
      durable: true
      persistent: true
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: body
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
    params:
      durable: true
      persistent: true
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
    params: {}
- name: task_queue
  endpoint:
    path: /queue/task_queue
    method: POST
    data_selector: messages
    params: {}
- name: hello_queue
  endpoint:
    path: hello
    method: GET
- name: task_queue
  endpoint:
    path: /task_queue
    method: POST
    data_selector: messages
- name: hello_queue
  endpoint:
    path: hello
    method: GET
    data_selector: null
    params: {}
- name: logs_exchange
  endpoint:
    path: /exchanges/logs
    method: POST
    data_selector: exchanges
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: logs
  endpoint:
    path: /exchanges/logs
    method: POST
    data_selector: ''
    params: {}
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /api/bindings
    method: GET
    data_selector: bindings
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
- name: logs_exchange
  endpoint:
    path: /exchange/logs
    method: POST
    data_selector: logs
    params: {}
- name: exchange
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: logs_exchange
  endpoint:
    path: /logs
    method: POST
    data_selector: message
    params: {}
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /api/bindings
    method: GET
    data_selector: bindings
- name: logs_exchange
  endpoint:
    path: /exchanges/logs
    method: POST
    data_selector: messages
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
- name: queues
  endpoint:
    path: /queues
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
- name: logs_exchange
  endpoint:
    path: /exchanges/logs
    method: POST
    data_selector: exchange
- name: temporary_queue
  endpoint:
    path: /queues
    method: POST
    data_selector: queue
- name: logs
  endpoint:
    path: /AMQP.Exchange.declare
    method: POST
    data_selector: logs
    params: {}
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /api/bindings
    method: GET
    data_selector: bindings
- name: logs
  endpoint:
    path: /exchanges/logs
    method: POST
    data_selector: messages
    params: {}
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /api/bindings
    method: GET
    data_selector: bindings
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /api/bindings
    method: GET
    data_selector: bindings
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: bindings
  endpoint:
    path: /api/bindings
    method: GET
    data_selector: bindings
    params: {}
- name: fanout_exchange
  endpoint:
    path: /exchanges/tut.fanout
    method: POST
- name: anonymous_queue
  endpoint:
    path: /queues
    method: POST
- name: fanout_exchange
  endpoint:
    path: /tut.fanout
    method: POST
    data_selector: messages
    params: {}
- name: direct_logs
  endpoint:
    path: /exchange/direct_logs
    method: POST
    data_selector: routing_key
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: message
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: logs
    params: {}
- name: EmitLogDirect
  endpoint:
    path: /emit_log_direct
    method: POST
    data_selector: message
    params: {}
- name: ReceiveLogsDirect
  endpoint:
    path: /receive_logs_direct
    method: GET
    data_selector: logs
    params: {}
- name: logs
  endpoint:
    path: /logs
    method: GET
    data_selector: logs
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: logs
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: messages
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: logs
    params: {}
- name: logs_direct
  endpoint:
    path: /logs_direct
    method: POST
    data_selector: body
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: message
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: logs
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: messages
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: GET
    data_selector: messages
    params: {}
- name: logs_direct
  endpoint:
    path: /logs_direct
    method: POST
    data_selector: logs
    params: {}
- name: direct_exchange
  endpoint:
    path: /tutorials/tutorial-four-spring-amqp
    method: GET
    data_selector: tutorials
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: logs
    params: {}
- name: topic_exchange
  endpoint:
    path: /tutorials/tutorial-five-python
    method: GET
    data_selector: logs
    params: {}
- name: logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: message
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: message
    params: {}
- name: direct_logs
  endpoint:
    path: /direct_logs
    method: POST
    data_selector: logs
- name: topic_exchange
  endpoint:
    path: /tutorials/tutorial-five-ruby
    method: GET
    data_selector: messages
    params: {}
- name: direct_exchange
  endpoint:
    path: /tut4
    method: GET
    data_selector: bindings
    params: {}
- name: topic_exchange
  endpoint:
    path: /tutorials/tutorial-five-php
    method: GET
    data_selector: messages
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: messages
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: message
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic
    method: POST
    data_selector: logs
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: ''
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic
    method: GET
- name: logs_topic
  endpoint:
    path: /logs_topic
    method: POST
    data_selector: messages
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_exchange
    method: GET
    data_selector: messages
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: messages
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: ''
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_exchange
    method: POST
    data_selector: logs
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
- name: topic_exchange
  endpoint:
    path: /tutorials/tutorial-five-swift
    method: GET
    data_selector: messages
    params: {}
- name: logs_topic
  endpoint:
    path: /logs_topic
    method: GET
    data_selector: messages
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: POST
    data_selector: routing_key
- name: topic_exchange
  endpoint:
    path: /tutorials/tutorial-five-spring-amqp
    method: GET
    data_selector: messages
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: GET
    data_selector: response
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic_logs
    method: GET
    data_selector: messages
    params: {}
- name: topic_exchange
  endpoint:
    path: /topic/exchange
    method: POST
    data_selector: logs
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: topic_exchange
  endpoint:
    path: /tut/topic
    method: POST
    data_selector: messages
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: basic_publish
    data_selector: ''
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: rpc_queue
  endpoint:
    path: /rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: RPC
    data_selector: message
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: GET
    data_selector: response
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: rpc_queue
  endpoint:
    path: /rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: GET
    data_selector: messages
- name: rpc_queue
  endpoint:
    path: rpc_queue
    method: POST
    data_selector: msg
    params: {}
- name: rpc_queue
  endpoint:
    path: /rpc_queue
    method: POST
    data_selector: response
    params: {}
- name: publisher_confirms
  endpoint:
    path: /docs/confirms
    method: GET
    data_selector: publisher_confirms
- name: rpc_queue
  endpoint:
    path: /tut.rpc
    method: POST
    data_selector: response
    params: {}
- name: tut.rpc.requests
  endpoint:
    path: /tut.rpc.requests
    method: POST
    data_selector: response
    params: {}
- name: exchange
  endpoint:
    path: /exchange
    method: POST
    data_selector: exchange.declare
    params: {}
- name: queue
  endpoint:
    path: /queue
    method: POST
    data_selector: queue.declare
    params: {}
- name: connection
  endpoint:
    path: /connection
    method: GET
- name: channel
  endpoint:
    path: /channel
    method: GET
- name: exchange
  endpoint:
    path: /exchange
    method: GET
- name: queue
  endpoint:
    path: /queue
    method: GET
- name: basic
  endpoint:
    path: /basic
    method: GET
- name: publisher_confirms
  endpoint:
    path: /docs/confirms
    method: GET
    data_selector: messages
    params: {}
- name: exchange
  endpoint:
    path: /exchange
    method: POST
    data_selector: operations
    params: {}
- name: queue
  endpoint:
    path: /queue
    method: POST
    data_selector: operations
    params: {}
- name: stream
  endpoint:
    path: /streams
    method: POST
    data_selector: stream
    params: {}
- name: stream
  endpoint:
    path: /stream
    method: POST
    data_selector: stream
    params:
      maxLengthBytes: 5368709120
- name: stream
  endpoint:
    path: /streams
    method: POST
    data_selector: stream
    params:
      MaxLengthBytes: 5000000000
- name: stream
  endpoint:
    path: /stream
    method: POST
    data_selector: streamName
    params: {}
- name: send
  endpoint:
    path: /send
    method: POST
    data_selector: message
    params: {}
- name: receive
  endpoint:
    path: /receive
    method: GET
    data_selector: messages
    params: {}
- name: send_message
  endpoint:
    path: /send
    method: POST
    data_selector: message
    params: {}
- name: receive_message
  endpoint:
    path: /receive
    method: GET
    data_selector: message
    params: {}
- name: hello-rust-stream
  endpoint:
    path: /streams/hello-rust-stream
    method: POST
    data_selector: message
- name: hello-stream
  endpoint:
    path: /hello-stream
    method: POST
    data_selector: message
- name: stream
  endpoint:
    path: /streams
    method: POST
    data_selector: streams
    params:
      stream: hello-nodejs-stream
- name: hello-go-stream
  endpoint:
    path: /stream
    method: POST
    data_selector: messages
    params: {}
- name: stream
  endpoint:
    path: /api/streams
    method: POST
    data_selector: stream
    params:
      name: stream-offset-tracking-java
- name: stream
  endpoint:
    path: /stream
    method: POST
    data_selector: messages
    params: {}
- name: stream
  endpoint:
    path: /streams
    method: POST
    data_selector: stream
    params:
      stream_name: hello-python-stream
      max_length_bytes: 5000000000
- name: stream-offset-tracking-go
  endpoint:
    path: /stream/offset-tracking
    method: POST
    data_selector: messages
    params: {}
- name: stream
  endpoint:
    path: /streams/hello-rust-stream
    method: POST
    data_selector: message
    params:
      max_length: 5GB
- name: stream_offset_tracking
  endpoint:
    path: /api/streams
    method: POST
    data_selector: stream
    params:
      max-length-bytes: 2000000000
- name: stream
  endpoint:
    path: /
    method: POST
    data_selector: stream
    params:
      streamName: hello-nodejs-stream
      max-length-bytes: 5000000000
- name: stream-offset-tracking-python
  endpoint:
    path: /stream-offset-tracking-python
    method: POST
    data_selector: messages
    params: {}
- name: stream-offset-tracking
  endpoint:
    path: /stream-offset-tracking-dotnet
    method: POST
    data_selector: messages
    params: {}
- name: offset_tracking_send
  endpoint:
    path: /offset_tracking_send.js
    method: GET
    data_selector: records
- name: offset_tracking_receive
  endpoint:
    path: /offset_tracking_receive.js
    method: GET
    data_selector: records
- name: stream
  endpoint:
    path: /stream-offset-tracking-python
    method: POST
    data_selector: messages
    params:
      messages: 100
      stream_retention: 2000000000
- name: rabbitmqadmin
  endpoint:
    path: /management
    method: GET
- name: stream-offset-tracking-python
  endpoint:
    path: /stream/stream-offset-tracking-python
    method: POST
    data_selector: messages
    params: {}
- name: stream-offset-tracking-javascript
  endpoint:
    path: /stream
    method: POST
    data_selector: messages
    params: {}
- name: rabbitmqadmin
  endpoint:
    path: /management/cli/rabbitmqadmin
    method: GET
- name: default_exchange
  endpoint:
    path: /default/exchange
    method: GET
- name: amq_fanout
  endpoint:
    path: /amq/fanout
    method: GET
- name: amq_topic
  endpoint:
    path: /amq/topic
    method: GET
- name: amq_direct
  endpoint:
    path: /amq/direct
    method: GET
- name: amq_headers
  endpoint:
    path: /amq/headers
    method: GET
- name: single_active_consumer
  endpoint:
    path: /docs/single_active_consumer
    method: GET
    data_selector: details
    params: {}
- name: queue_declaration
  endpoint:
    path: /docs/enabling_single_active_consumer
    method: GET
    data_selector: details
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: exchanges
  endpoint:
    path: /docs/exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: consumers
  endpoint:
    path: /docs/consumers
    method: GET
    data_selector: messages
- name: channels
  endpoint:
    path: /docs/channels
    method: GET
    data_selector: channels
    params: {}
- name: Single Active Consumer
  endpoint:
    path: /docs/single-active-consumer
    method: GET
    data_selector: details
- name: Enabling Single Active Consumer
  endpoint:
    path: /docs/enabling-single-active-consumer
    method: GET
    data_selector: details
- name: Consumer Activity
  endpoint:
    path: /docs/active-consumer
    method: GET
    data_selector: details
- name: queues
  endpoint:
    path: /docs/queues
    method: GET
    data_selector: queues
    params: {}
- name: clustering
  endpoint:
    path: /docs/clustering
    method: GET
- name: federation
  endpoint:
    path: /docs/federation
    method: GET
- name: shovels
  endpoint:
    path: /docs/shovel
    method: GET
- name: plugins
  endpoint:
    path: /rabbitmq-plugins
    method: GET
    data_selector: plugins
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
- name: enabled_plugins
  endpoint:
    path: /path/to/enabled_plugins
    method: GET
    data_selector: plugins
- name: consumer_acknowledgements
  endpoint:
    path: /docs/consumer-acknowledgements
    method: GET
    data_selector: acknowledgements
- name: publisher_confirms
  endpoint:
    path: /docs/publisher-confirms
    method: GET
    data_selector: confirms
- name: clustering
  endpoint:
    path: /docs/clustering
    method: GET
- name: federation
  endpoint:
    path: /docs/federation
    method: GET
- name: shovel
  endpoint:
    path: /docs/shovel
    method: GET
- name: enabled_plugins
  endpoint:
    path: /enabled_plugins
    method: GET
    data_selector: plugins
    params: {}
- name: enabled_plugins
  endpoint:
    path: /rabbitmq-plugins/enabled_plugins
    method: GET
    data_selector: plugins
    params: {}
- name: plugin_directories
  endpoint:
    path: /rabbitmq-plugins/directories
    method: GET
    data_selector: directories
    params: {}
- name: enabled_plugins
  endpoint:
    path: /path/to/enabled_plugins
    method: GET
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: cluster_overview
    params: {}
- name: nodes
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: queue_metrics
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue_metrics
    params: {}
- name: node_health_check
  endpoint:
    path: /api/nodes/{node}/health
    method: GET
    data_selector: health_status
- name: memory_usage
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: listeners
  endpoint:
    path: /api/nodes/{node}/listeners
    method: GET
    data_selector: listeners
- name: virtual_hosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
- name: rabbitmq_auth_backend_ldap
  endpoint:
    path: /plugins/rabbitmq_auth_backend_ldap
    method: GET
    data_selector: description
- name: rabbitmq_auth_backend_oauth2
  endpoint:
    path: /plugins/rabbitmq_auth_backend_oauth2
    method: GET
    data_selector: description
- name: rabbitmq_auth_backend_http
  endpoint:
    path: /plugins/rabbitmq_auth_backend_http
    method: GET
    data_selector: description
- name: rabbitmq_management
  endpoint:
    path: /plugins/rabbitmq_management
    method: GET
    data_selector: description
- name: rabbitmq_shovel
  endpoint:
    path: /plugins/rabbitmq_shovel
    method: GET
    data_selector: description
- name: rabbitmq_mqtt
  endpoint:
    path: /plugins/rabbitmq_mqtt
    method: GET
    data_selector: description
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
    params: {}
- name: node_metrics
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: queue_metrics
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue
    params: {}
- name: stream_listener
  endpoint:
    path: /stream/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: retained_message_store
  endpoint:
    path: mqtt.retained_message_store_dets_sync_interval
    method: GET
    data_selector: some-user
    params:
      anonymous_login_user: some-user
      anonymous_login_pass: s3kRe7
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: object_totals
    params: {}
- name: nodes
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: queues
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue_metrics
    params: {}
- name: node_health_check
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
    params: {}
- name: node_metrics
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: queue_metrics
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue_metrics
    params: {}
- name: tcp_listeners
  endpoint:
    path: /mqtt/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: retained_message_store
  endpoint:
    path: /mqtt/retained_message_store
    method: GET
    data_selector: stores
    params: {}
- name: mqtt_port_to_vhost_mapping
  endpoint:
    path: /api/global-parameters/mqtt_port_to_vhost_mapping
    method: PUT
    data_selector: null
    params: {}
- name: mqtt_default_vhosts
  endpoint:
    path: /api/global-parameters/mqtt_default_vhosts
    method: PUT
    data_selector: null
    params: {}
- name: stream_listener
  endpoint:
    path: /api/stream/listeners
    method: GET
    data_selector: listeners
- name: user
  endpoint:
    path: /api/users
    method: POST
    data_selector: records
    params: {}
- name: stream_listener
  endpoint:
    path: /stream/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: mqtt_configuration
  endpoint:
    path: /mqtt/configuration
    method: GET
    data_selector: configuration
    params: {}
- name: tcp_listeners
  endpoint:
    path: /tcp_listeners
    method: GET
    data_selector: listeners
    params: {}
- name: ssl_listeners
  endpoint:
    path: /ssl_listeners
    method: GET
    data_selector: listeners
    params: {}
- name: mqtt.retained_message_store
  endpoint:
    path: rabbit_mqtt_retained_msg_store_dets
    method: GET
- name: web_mqtt
  endpoint:
    path: /ws
    method: GET
- name: tcp_listeners
  endpoint:
    path: /mqtt/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: management_ui
  endpoint:
    path: /
    method: GET
    data_selector: stats
    params: {}
- name: mqtt_port_to_vhost_mapping
  endpoint:
    path: /api/global-parameters/mqtt_port_to_vhost_mapping
    method: PUT
    data_selector: null
    params: {}
- name: mqtt_default_vhosts
  endpoint:
    path: /api/global-parameters/mqtt_default_vhosts
    method: PUT
    data_selector: null
    params: {}
- name: mqtt
  endpoint:
    path: /
    method: GET
- name: retained_messages
  endpoint:
    path: /mqtt/retained_messages
    method: GET
    data_selector: messages
    params:
      incremental: timestamp
- name: tcp_listener
  endpoint:
    path: /stomp
    method: GET
    data_selector: listeners
    params:
      port: '61613'
- name: tls_listener
  endpoint:
    path: /stomp
    method: GET
    data_selector: listeners
    params:
      port: '61614'
- name: web_stomp
  endpoint:
    path: /ws
    method: GET
- name: web_mqtt
  endpoint:
    path: /ws
    method: GET
- name: management_ssl
  endpoint:
    path: /management/ssl
    method: GET
    data_selector: records
    params: {}
- name: management_ui
  endpoint:
    path: /
    method: GET
    data_selector: metrics
- name: message rates
  endpoint:
    path: /api/rates
    method: GET
    data_selector: rates
    params: {}
- name: sample retention policies
  endpoint:
    path: /api/sample_retention_policies
    method: GET
    data_selector: policies
    params: {}
- name: 3rd Party Plugins
  endpoint:
    path: /docs/installing-plugins
    method: GET
    data_selector: plugins
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation-upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
- name: federate_me_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: definition
- name: my-exchange
  endpoint:
    path: /federation_status
    method: GET
    data_selector: status
    params: {}
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_status
  endpoint:
    path: /federation_status
    method: GET
    data_selector: federation_links
    params: {}
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: federate_me_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
- name: 3rd Party Plugins
  endpoint:
    path: /docs/installing-plugins
    method: GET
    data_selector: plugins
    params: {}
- name: my-exchange
  endpoint:
    path: /federation_status
    method: GET
    data_selector: status
    params: {}
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params:
      uri: amqp://target.hostname
      expires: 3600000
- name: federate_me_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params:
      pattern: ^amq\.
      definition:
        federation-upstream-set: all
      apply-to: exchanges
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: federate_me
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: definition
    params:
      pattern: ^amq.
      apply-to: exchanges
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation-upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params:
      expires: 3600000
- name: my-exchange
  endpoint:
    path: /federation_status
    method: GET
    data_selector: status
    params: {}
- name: federation_upstream
  endpoint:
    path: /parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /policies/%2f/federate-me
    method: PUT
    data_selector: definition
    params: {}
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: federate_me_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_upstream
  endpoint:
    path: /federation_upstream
    method: POST
    data_selector: upstream
    params:
      uri: amqp://remote-host.local:5672
- name: exchange_federation
  endpoint:
    path: /exchange_federation
    method: POST
    data_selector: policy
    params:
      name: exchange-federation
      pattern: ^federated\.
      definition: '{"federation-upstream-set":"all"}'
      priority: 10
      apply-to: exchanges
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federated_queue
  endpoint:
    path: /federated_queues
    method: GET
    data_selector: queues
    params: {}
- name: federation_upstream
  endpoint:
    path: /parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policy
  endpoint:
    path: /policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: federation_link_status
  endpoint:
    path: /docs/next/cli
    method: GET
    data_selector: federation_links
    params: {}
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: shovel
  endpoint:
    path: /api/parameters/shovel/%2f/my-shovel
    method: PUT
    data_selector: value
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: vhosts
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params:
      uri: amqp://target.hostname
      expires: 3600000
- name: federation_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params:
      pattern: ^amq\.
      definition:
        federation-upstream-set: all
      apply-to: exchanges
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    params: {}
- name: vh1
  endpoint:
    path: /vhosts/vh1
    method: GET
- name: vh2
  endpoint:
    path: /vhosts/vh2
    method: GET
- name: my-exchange
  endpoint:
    path: /federation_status
    method: GET
    data_selector: status
    params:
      type: exchange
      vhost: /
      connection: upstream-server
      upstream_name: my-upstream-x
      status: running
      timestamp: '2020-03-01T12:03:28'
- name: vhost
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: ''
    params: {}
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: vhosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: federate_me_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata.protected_from_deletion
    params: {}
- name: vhost_deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
    data_selector: ''
    params: {}
- name: federation-upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: metadata
    params: {}
- name: delete_vhost
  endpoint:
    path: /api/vhosts/{name}
    method: DELETE
    data_selector: response
    params: {}
- name: federation_upstream
  endpoint:
    path: /api/parameters/federation-upstream/%2f/my-upstream
    method: PUT
    data_selector: value
    params: {}
- name: federate_me_policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata.protected_from_deletion
- name: delete_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: DELETE
- name: federation_links
  endpoint:
    path: /api/federation-links
    method: GET
- name: parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: federation_upstream
  endpoint:
    path: /api/federation-upstreams
    method: POST
    data_selector: uri
    params: {}
- name: federation_policy
  endpoint:
    path: /api/policies
    method: POST
    data_selector: name
    params: {}
- name: parameters
  endpoint:
    path: /api/parameters/{component_name}/{vhost}/{name}
    method: PUT
- name: global_parameters
  endpoint:
    path: /api/global-parameters/name
    method: PUT
- name: runtime_parameters
  endpoint:
    path: /api/parameters
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: federation_upstream
  endpoint:
    path: /federation/upstreams
    method: POST
    data_selector: upstreams
    params: {}
- name: federation_policy
  endpoint:
    path: /federation/policies
    method: POST
    data_selector: policies
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: federation-upstream
  endpoint:
    path: /set_parameter/federation-upstream
    method: SET
    data_selector: json-object
- name: federation-upstream-set
  endpoint:
    path: /set_parameter/federation-upstream-set
    method: SET
    data_selector: json-object
- name: set-policy
  endpoint:
    path: /set_policy
    method: SET
    data_selector: json-object
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: shovel
  endpoint:
    path: /api/parameters/shovel/%2f/my-shovel
    method: PUT
    data_selector: value
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: vhosts
- name: policies
  endpoint:
    path: /policies/delete_definition_keys
    method: DELETE
    data_selector: definition_keys
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/%2f/transient-queue-ttl
    method: PUT
    data_selector: pattern
    params: {}
- name: vh1
  endpoint:
    path: /vhosts/vh1
    method: GET
- name: vh2
  endpoint:
    path: /vhosts/vh2
    method: GET
- name: policies
  endpoint:
    path: /policies
    method: DELETE
    data_selector: definition_keys
    params:
      definition_keys: ha-mode,ha-params,ha-promote-on-shutdown,ha-promote-on-failure,ha-sync-mode,ha-sync-batch-size
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: delete_virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: DELETE
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
- name: delete_virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: DELETE
- name: list_virtual_hosts
  endpoint:
    path: /api/vhosts
    method: GET
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: pattern
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: policies
  endpoint:
    path: /api/policies
    method: PUT
    data_selector: pattern
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata.protected_from_deletion
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: ''
    params: {}
- name: virtual_hosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
- name: operator_policy_definition
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata.protected_from_deletion
- name: vhost_deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: DELETE
    data_selector: error
- name: policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: max-connections
  endpoint:
    path: /vhost_name
    method: POST
    data_selector: limits
    params:
      max-connections: 256
- name: max-queues
  endpoint:
    path: /vhost_name
    method: POST
    data_selector: limits
    params:
      max-queues: 1024
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: pattern
    params: {}
- name: parameters
  endpoint:
    path: /api/parameters/{component_name}/{vhost}/{name}
    method: PUT
- name: global_parameters
  endpoint:
    path: /api/global-parameters/name
    method: PUT
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: parameters
  endpoint:
    path: /api/parameters/{component_name}/{vhost}/{name}
    method: PUT
- name: global_parameters
  endpoint:
    path: /api/global-parameters/name
    method: PUT
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: null
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: set_policy
  endpoint:
    path: /api/policies/%2f/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: delete_policy
  endpoint:
    path: /api/policies/{vhost}/{name}
    method: DELETE
    data_selector: ''
    params: {}
- name: declare_override
  endpoint:
    path: /api/policies/{vhost}/overrides.{name}
    method: PUT
    data_selector: ''
    params: {}
- name: declare_blanket_policy
  endpoint:
    path: /api/policies/{vhost}/blanket.{name}
    method: PUT
    data_selector: ''
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: policy_override
  endpoint:
    path: /api/policies/%2f/ttl-fed
    method: PUT
    data_selector: pattern
    params: {}
- name: policy_blanket
  endpoint:
    path: /api/policies/%2f/blanket.queues
    method: POST
    data_selector: pattern
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policy
  endpoint:
    path: /operator_policies
    method: PATCH
    data_selector: definition
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: null
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: policy_deletion
  endpoint:
    path: /policies/delete_definition_keys
    method: DELETE
    data_selector: definition_keys
    params:
      definition_keys: ha-mode,ha-params,ha-promote-on-shutdown,ha-promote-on-failure,ha-sync-mode,ha-sync-batch-size
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: delete_operator_policy
  endpoint:
    path: /api/operator-policies/vh.1/policy.name
    method: DELETE
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f
    method: PUT
    data_selector: null
    params: {}
- name: policies
  endpoint:
    path: /vhosts/target.vhost/policies
    method: GET
    data_selector: policies
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/%2f/transient-queue-ttl
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policy_patch
  endpoint:
    path: /api/operator-policies/
    method: PATCH
    data_selector: ''
    params: {}
- name: operator_policy_delete
  endpoint:
    path: /api/operator-policies/
    method: DELETE
    data_selector: ''
    params: {}
- name: operator_policy_list
  endpoint:
    path: /api/policies/
    method: GET
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: policies
  endpoint:
    path: policies/list_matching_object
    method: GET
    data_selector: ''
    params:
      vhost: target.vhost
      name: a.queue
      type: queues
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: null
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy.name}
    method: PUT
    data_selector: pattern
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: list_matching_object
  endpoint:
    path: /api/policies/list_matching_object
    method: GET
    data_selector: policies
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: list_policies
  endpoint:
    path: /policies
    method: GET
    data_selector: policies
- name: list_matching_object
  endpoint:
    path: /policies/matching_object
    method: GET
    data_selector: matching_objects
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: delete_operator_policy
  endpoint:
    path: /api/operator-policies/vh.1/policy.name
    method: DELETE
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: rabbitmqctl
  endpoint:
    path: /docs/man/rabbitmqctl.8
    method: GET
- name: rabbitmq-diagnostics
  endpoint:
    path: /docs/man/rabbitmq-diagnostics.8
    method: GET
- name: rabbitmq-plugins
  endpoint:
    path: /docs/man/rabbitmq-plugins.8
    method: GET
- name: rabbitmq-queues
  endpoint:
    path: /docs/man/rabbitmq-queues.8
    method: GET
- name: rabbitmq-streams
  endpoint:
    path: /docs/man/rabbitmq-streams.8
    method: GET
- name: rabbitmq-upgrade
  endpoint:
    path: /docs/man/rabbitmq-upgrade.8
    method: GET
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: ''
    params: {}
- name: rabbitmqctl
  endpoint:
    path: /rabbitmqctl
    method: GET
- name: rabbitmq-diagnostics
  endpoint:
    path: /rabbitmq-diagnostics
    method: GET
- name: rabbitmq-plugins
  endpoint:
    path: /rabbitmq-plugins
    method: GET
- name: rabbitmq-queues
  endpoint:
    path: /rabbitmq-queues
    method: GET
- name: rabbitmq-streams
  endpoint:
    path: /rabbitmq-streams
    method: GET
- name: rabbitmq-upgrade
  endpoint:
    path: /rabbitmq-upgrade
    method: GET
- name: operator_policy
  endpoint:
    path: /operator_policies/patch
    method: POST
    data_selector: definition
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: delete_policy
  endpoint:
    path: /api/policies/vh.1/{policy_name}
    method: DELETE
    data_selector: 'null'
    params: {}
- name: quorum_queue
  endpoint:
    path: /quorum_queues
    method: GET
    data_selector: queues
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: set_policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: definition
    params:
      pattern: ^qq\.
      definition:
        delivery-limit: 50
      priority: 1
      apply-to: quorum_queues
- name: disable_limit
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: definition
    params:
      pattern: ^qq\.unlimited
      definition:
        delivery-limit: -1
      priority: 1
      apply-to: quorum_queues
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: GET
    data_selector: policies
    params: {}
- name: policies
  endpoint:
    path: /policies/list_matching_object
    method: GET
    data_selector: records
    params:
      vhost: target.vhost
      name: a.queue
      type: queues
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: ''
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: definition
    params:
      pattern: ^qq\.
      definition:
        delivery-limit: 50
      priority: 1
      apply-to: quorum_queues
- name: disabled_policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: definition
    params:
      pattern: ^qq\.unlimited
      definition:
        delivery-limit: -1
      priority: 1
      apply-to: quorum_queues
- name: dlx_policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: definition
    params:
      pattern: ^qq\.
      definition:
        delivery-limit: 50
        dead-letter-exchange: redeliveries.limit.dlx
      priority: 1
      apply-to: quorum_queues
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params:
      apply-to: queues
- name: quorum_queues
  endpoint:
    path: /docs/quorum-queues
    method: GET
    data_selector: quorum_queues_data
    params: {}
- name: list_policies
  endpoint:
    path: /policies/list
    method: GET
- name: list_matching_object
  endpoint:
    path: /policies/list_matching_object
    method: GET
- name: set_policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: pattern
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: patterns
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: policy
    params: {}
- name: policies
  endpoint:
    path: /api/policies/
    method: DELETE
    data_selector: policy
    params: {}
- name: set_policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: pattern
    params: {}
- name: rabbitmqctl
  endpoint:
    path: /docs/man/rabbitmqctl.8
    method: GET
- name: rabbitmq-diagnostics
  endpoint:
    path: /docs/man/rabbitmq-diagnostics.8
    method: GET
- name: rabbitmq-plugins
  endpoint:
    path: /docs/man/rabbitmq-plugins.8
    method: GET
- name: rabbitmq-queues
  endpoint:
    path: /docs/man/rabbitmq-queues.8
    method: GET
- name: rabbitmq-streams
  endpoint:
    path: /docs/man/rabbitmq-streams.8
    method: GET
- name: rabbitmq-upgrade
  endpoint:
    path: /docs/man/rabbitmq-upgrade.8
    method: GET
- name: quorum_queue
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: policies
  endpoint:
    path: /policies/%2f/qq-overrides
    method: PUT
    data_selector: pattern
    params: {}
- name: quorum_queue_settings
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: qq-overrides
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: null
    params:
      pattern: ^qq\.
      definition:
        delivery-limit: 50
        dead-letter-exchange: redeliveries.limit.dlx
      priority: 1
      apply-to: quorum_queues
- name: tls_support
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: content
    params: {}
- name: quorum_queue
  endpoint:
    path: /docs/quorum-queues
    method: GET
    data_selector: quorum queues data
- name: tls_configuration
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: configuration
    params: {}
- name: qq-overrides
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: definition
    params:
      pattern: ^qq\.
      definition:
        delivery-limit: 50
        dead-letter-exchange: redeliveries.limit.dlx
      priority: 1
      apply-to: quorum_queues
- name: policies
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: pattern
    params: {}
- name: tls_configuration
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: configuration
    params: {}
- name: quorum_queues
  endpoint:
    path: /docs/quorum-queues
    method: GET
    data_selector: quorum_queue_data
    params: {}
- name: set_policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: null
    params: {}
- name: listeners.ssl
  endpoint:
    path: /path/to/ca_certificate.pem
    method: GET
    data_selector: records
    params: {}
- name: ssl_options
  endpoint:
    path: /path/to/server_certificate.pem
    method: GET
    data_selector: records
    params: {}
- name: ssl_options.keyfile
  endpoint:
    path: /path/to/server_key.pem
    method: GET
    data_selector: records
    params: {}
- name: quorum_queues
  endpoint:
    path: /docs/quorum-queues
    method: GET
    data_selector: quorum queues
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/qq-overrides
    method: PUT
    data_selector: null
    params: {}
- name: tls_settings
  endpoint:
    path: /path/to/client_key.p12
    method: POST
    data_selector: settings
- name: quorum_queue_configuration
  endpoint:
    path: /docs/configure#advanced-config-file
    method: GET
    data_selector: configuration
    params: {}
- name: TLS Configuration
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: configuration
    params: {}
- name: TLS Configuration
  endpoint:
    path: /docs/ssl
    method: GET
- name: tls_configuration
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: configuration
    params: {}
- name: cert_management
  endpoint:
    path: /certmanagement
    method: GET
    data_selector: certs
- name: tls_settings
  endpoint:
    path: /tlssettings
    method: GET
    data_selector: tlsConfig
- name: connection
  endpoint:
    path: /docs/uri-query-parameters
    method: GET
    data_selector: parameters
    params: {}
- name: TLS Support
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: ''
    params: {}
- name: log_file
  endpoint:
    path: /logs
    method: GET
    data_selector: logs
- name: syslog
  endpoint:
    path: /syslog
    method: GET
    data_selector: syslog
- name: tls_settings
  endpoint:
    path: /path/to/client_key.p12
    method: POST
    data_selector: parameters
    params:
      Ssl.Enabled: true
      Ssl.ServerName: System.Net.Dns.GetHostName()
      Ssl.CertPath: /path/to/client_key.p12
      Ssl.CertPassphrase: MySecretPassword
      Ssl.Version: SslProtocols.Tls12
- name: tls_support
  endpoint:
    path: /docs/ssl
    method: GET
    data_selector: tls_options
    params: {}
- name: log_exchange
  endpoint:
    path: /amq.rabbitmq.log
    method: POST
    data_selector: messages
    params:
      log.exchange: 'true'
- name: tls_configuration
  endpoint:
    path: /tls/configuration
    method: GET
    data_selector: configuration
    params: {}
- name: classic_queue
  endpoint:
    path: /docs/classic-queues
    method: GET
    data_selector: classic_queue_features
- name: classic_queue
  endpoint:
    path: /docs/next/classic-queues
    method: GET
    data_selector: ''
    params: {}
- name: classic_queue
  endpoint:
    path: /docs/classic-queues
    method: GET
    data_selector: queue_data
    params: {}
- name: connection
  endpoint:
    path: /uri-query-parameters
    method: GET
    data_selector: ''
    params: {}
- name: logs
  endpoint:
    path: /logs
    method: GET
    data_selector: log_entries
- name: TTL
  endpoint:
    path: /docs/ttl
    method: GET
    data_selector: key topics covered
- name: log
  endpoint:
    path: /logs
    method: GET
    data_selector: records
- name: queue_length_limit
  endpoint:
    path: /docs/queues#maxlength
    method: GET
    data_selector: overview
    params: {}
- name: dead_letter_exchange
  endpoint:
    path: /api/policies/%2f/DLX
    method: PUT
    data_selector: definition
    params:
      pattern: .*
      priority: 7
      apply-to: queues
- name: consumer_priorities
  endpoint:
    path: /docs/consumer-priority
    method: GET
    data_selector: overview
    params: {}
- name: consumer_prefetch
  endpoint:
    path: /docs/consumer-prefetch
    method: GET
    data_selector: records
- name: logging
  endpoint:
    path: /docs/logging
    method: GET
    data_selector: content
    params: {}
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: settings
    params: {}
- name: advanced_config_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: settings
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: classic_queue_features
  endpoint:
    path: /docs/classic-queues/features
    method: GET
    data_selector: features
- name: classic_queue_persistence
  endpoint:
    path: /docs/classic-queues/persistence
    method: GET
    data_selector: persistence
- name: classic_queue_versions
  endpoint:
    path: /docs/classic-queues/versions
    method: GET
    data_selector: versions
- name: classic_queue_migration
  endpoint:
    path: /docs/classic-queues/migration
    method: GET
    data_selector: migration
- name: classic_queue_resource_use
  endpoint:
    path: /docs/classic-queues/resource-use
    method: GET
    data_selector: resource_use
- name: classic_queue_file_handle_usage
  endpoint:
    path: /docs/classic-queues/file-handles
    method: GET
    data_selector: file_handles
- name: classic_queue_memory_footprint
  endpoint:
    path: /docs/classic-queues/memory
    method: GET
    data_selector: memory
- name: classic_queue_alternate_message_store
  endpoint:
    path: /docs/classic-queues/msg-store-index-implementations
    method: GET
    data_selector: msg_store_index
- name: rabbitmq.conf
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: records
- name: advanced.config
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: records
- name: classic_queue
  endpoint:
    path: /docs/next/classic-queues
    method: GET
    data_selector: records
- name: classic_queue
  endpoint:
    path: /docs/classic-queues
    method: GET
    data_selector: queue_features
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: classic_queue
  endpoint:
    path: /docs/3.13/classic-queues
    method: GET
    data_selector: classic queues
    params: {}
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
- name: status
  endpoint:
    path: /diagnostics/status
    method: GET
    data_selector: status
- name: message_ttl
  endpoint:
    path: /docs/ttl
    method: GET
    data_selector: message_ttl
    params: {}
- name: queue_ttl
  endpoint:
    path: /docs/ttl
    method: GET
    data_selector: queue_ttl
    params: {}
- name: queue_length
  endpoint:
    path: /docs/queues/maxlength
    method: GET
    data_selector: overview
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: queue_length_limit
  endpoint:
    path: /docs/maxlength
    method: GET
    data_selector: overview
    params: {}
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: status
  endpoint:
    path: /diagnostics/status
    method: GET
- name: rabbitmq.conf
  endpoint:
    path: rabbitmq.conf
    method: GET
    data_selector: settings
    params: {}
- name: advanced.config
  endpoint:
    path: advanced.config
    method: GET
    data_selector: settings
    params: {}
- name: dead_letter_exchange
  endpoint:
    path: /api/policies/%2f/DLX
    method: PUT
    data_selector: definition
    params:
      pattern: .*
      definition:
        dead-letter-exchange: my-dlx
      priority: 7
      apply-to: queues
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: default_consumer_prefetch
  endpoint:
    path: /docs/configure#advanced-config-file
    method: GET
    data_selector: default_consumer_prefetch
    params: {}
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: settings
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: settings
- name: effective_configuration
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: parameters
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
    params: {}
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: tags
    params: {}
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: records
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: records
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: cluster
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /rabbitmq-diagnostics/status
    method: GET
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: listeners.tcp
  endpoint:
    path: listeners.tcp.default
    method: GET
- name: listeners.ssl
  endpoint:
    path: listeners.ssl
    method: GET
- name: ssl_options
  endpoint:
    path: ssl_options
    method: GET
- name: num_acceptors.tcp
  endpoint:
    path: num_acceptors.tcp
    method: GET
- name: num_acceptors.ssl
  endpoint:
    path: num_acceptors.ssl
    method: GET
- name: distribution.listener.interface
  endpoint:
    path: distribution.listener.interface
    method: GET
- name: distribution.listener.port_range.min
  endpoint:
    path: distribution.listener.port_range.min
    method: GET
- name: distribution.listener.port_range.max
  endpoint:
    path: distribution.listener.port_range.max
    method: GET
- name: handshake_timeout
  endpoint:
    path: handshake_timeout
    method: GET
- name: ssl_handshake_timeout
  endpoint:
    path: ssl_handshake_timeout
    method: GET
- name: vm_memory_high_watermark
  endpoint:
    path: vm_memory_high_watermark
    method: GET
- name: vm_memory_calculation_strategy
  endpoint:
    path: vm_memory_calculation_strategy
    method: GET
- name: total_memory_available_override_value
  endpoint:
    path: total_memory_available_override_value
    method: GET
- name: disk_free_limit
  endpoint:
    path: disk_free_limit
    method: GET
- name: queue_leader_locator
  endpoint:
    path: queue_leader_locator
    method: GET
- name: log.file.level
  endpoint:
    path: log.file.level
    method: GET
- name: session_max_per_connection
  endpoint:
    path: session_max_per_connection
    method: GET
- name: link_max_per_session
  endpoint:
    path: link_max_per_session
    method: GET
- name: channel_max
  endpoint:
    path: channel_max
    method: GET
- name: channel_operation_timeout
  endpoint:
    path: channel_operation_timeout
    method: GET
- name: max_message_size
  endpoint:
    path: max_message_size
    method: GET
- name: heartbeat
  endpoint:
    path: heartbeat
    method: GET
- name: default_vhost
  endpoint:
    path: default_vhost
    method: GET
- name: default_user
  endpoint:
    path: default_user
    method: GET
- name: default_pass
  endpoint:
    path: default_pass
    method: GET
- name: default_user_tags
  endpoint:
    path: default_user_tags
    method: GET
- name: default_permissions
  endpoint:
    path: default_permissions
    method: GET
- name: loopback_users
  endpoint:
    path: loopback_users
    method: GET
- name: cluster_formation.classic_config.nodes
  endpoint:
    path: cluster_formation.classic_config.nodes
    method: GET
- name: collect_statistics
  endpoint:
    path: collect_statistics
    method: GET
- name: collect_statistics_interval
  endpoint:
    path: collect_statistics_interval
    method: GET
- name: management.db_cache_multiplier
  endpoint:
    path: management.db_cache_multiplier
    method: GET
- name: auth_mechanisms
  endpoint:
    path: auth_mechanisms
    method: GET
- name: auth_backends
  endpoint:
    path: auth_backends
    method: GET
- name: reverse_dns_lookups
  endpoint:
    path: reverse_dns_lookups
    method: GET
- name: delegate_count
  endpoint:
    path: delegate_count
    method: GET
- name: tcp_listen_options
  endpoint:
    path: tcp_listen_options
    method: GET
- name: cluster_partition_handling
  endpoint:
    path: cluster_partition_handling
    method: GET
- name: cluster_keepalive_interval
  endpoint:
    path: cluster_keepalive_interval
    method: GET
- name: queue_index_embed_msgs_below
  endpoint:
    path: queue_index_embed_msgs_below
    method: GET
- name: mnesia_table_loading_retry_timeout
  endpoint:
    path: mnesia_table_loading_retry_timeout
    method: GET
- name: mnesia_table_loading_retry_limit
  endpoint:
    path: mnesia_table_loading_retry_limit
    method: GET
- name: queue_leader_locator
  endpoint:
    path: queue_leader_locator
    method: GET
- name: proxy_protocol
  endpoint:
    path: proxy_protocol
    method: GET
- name: cluster_name
  endpoint:
    path: cluster_name
    method: GET
- name: node_tags
  endpoint:
    path: node_tags
    method: GET
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: configuration
    params: {}
- name: rabbitmq.conf
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: ''
    params: {}
- name: advanced.config
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: ''
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: records
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: configurations
    params: {}
- name: advanced_config_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: configurations
    params: {}
- name: effective_configuration
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /api/status
    method: GET
- name: configuration
  endpoint:
    path: /docs/configure
    method: GET
- name: configuration_files
  endpoint:
    path: /docs/configure
    method: GET
    data_selector: files
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: listeners.tcp
  endpoint:
    path: /listeners/tcp
    method: GET
    data_selector: records
- name: listeners.ssl
  endpoint:
    path: /listeners/ssl
    method: GET
    data_selector: records
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: configuration
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: records
- name: status
  endpoint:
    path: /diagnostics/status
    method: GET
    data_selector: records
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /api/status
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters
    method: GET
- name: listeners
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: listeners
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: effective_configuration
  endpoint:
    path: /rabbitmq-diagnostics/environment
    method: GET
    data_selector: configuration
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: value
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: value
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /rabbitmq-diagnostics/status
    method: GET
- name: effective_configuration
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: configuration_files
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: records
- name: advanced_config
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: records
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: config
- name: default_user
  endpoint:
    path: /default_user
    method: GET
    data_selector: guest
    params: {}
- name: default_pass
  endpoint:
    path: /default_pass
    method: GET
    data_selector: encrypted
    params: {}
- name: config_entry_decoder
  endpoint:
    path: /config_entry_decoder
    method: GET
    data_selector: passphrase
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
    params: {}
- name: configuration
  endpoint:
    path: /api/config
    method: GET
    data_selector: config
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /rabbitmq-diagnostics/status
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
    params: {}
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: configuration
- name: listeners
  endpoint:
    path: /listeners
    method: GET
    data_selector: records
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: value
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: value
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /rabbitmq-diagnostics/status
    method: GET
- name: config_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: configurations
    params: {}
- name: advanced_config_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: configurations
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: value
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: value
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: config
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: configuration
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: records
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /rabbitmq-diagnostics/status
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: ''
    params: {}
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: records
    params: {}
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: records
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: data
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /rabbitmq-diagnostics/status
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
- name: configuration_file
  endpoint:
    path: /docs/configure
    method: GET
    data_selector: configuration
- name: environment_variables
  endpoint:
    path: /docs/customise-environment
    method: GET
    data_selector: environment_variables
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: node_tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: config
  endpoint:
    path: /api/config
    method: GET
    data_selector: config
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: value
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: value
- name: environment_variables
  endpoint:
    path: /docs/configure
    method: GET
    data_selector: environment_variables
    params: {}
- name: effective_configuration
  endpoint:
    path: /rabbitmq-diagnostics/environment
    method: GET
    data_selector: configuration
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: rabbitmq
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: queue
  endpoint:
    path: /management/queues
    method: GET
    data_selector: queues
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
- name: publisher
  endpoint:
    path: /publish
    method: POST
    data_selector: message
    params: {}
- name: consumer
  endpoint:
    path: /consume
    method: GET
    data_selector: message
    params: {}
- name: message
  endpoint:
    path: /publish
    method: POST
    data_selector: result
- name: consumer
  endpoint:
    path: /consume
    method: GET
    data_selector: result
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
- name: queue_info
  endpoint:
    path: /getQueueInfo
    method: GET
    data_selector: getInfo
    params: {}
- name: delete_queue
  endpoint:
    path: /deleteQueue
    method: DELETE
    data_selector: ''
    params: {}
- name: bind_queue
  endpoint:
    path: /binding
    method: POST
    data_selector: ''
    params: {}
- name: unbind_queue
  endpoint:
    path: /unbind
    method: DELETE
    data_selector: ''
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: value
- name: node_tags
  endpoint:
    path: /api/global-parameters/node_tags
    method: GET
    data_selector: value
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: status
  endpoint:
    path: /api/status
    method: GET
- name: some-queue
  endpoint:
    path: some-queue
    method: GET
    data_selector: message
    params: {}
- name: some-stream
  endpoint:
    path: some-stream
    method: GET
    data_selector: message
    params: {}
- name: some-stream
  endpoint:
    path: some-stream
    method: POST
    data_selector: stream
    params:
      filterValues:
      - invoices
      - orders
      matchUnfiltered: true
- name: stream_filter
  endpoint:
    path: /stream/filter
    method: POST
    data_selector: annotations
- name: consumer_management
  endpoint:
    path: /consumer
    method: POST
    data_selector: message
- name: exchange
  endpoint:
    path: /exchanges
    method: POST
    data_selector: exchange_info
- name: queue
  endpoint:
    path: /queues
    method: POST
    data_selector: queue_info
- name: binding
  endpoint:
    path: /bindings
    method: POST
    data_selector: binding_info
- name: RABBITMQ_CONFIG_FILE
  endpoint:
    path: ${install_prefix}/etc/rabbitmq/rabbitmq
    method: GET
- name: RABBITMQ_MNESIA_BASE
  endpoint:
    path: ${install_prefix}/var/lib/rabbitmq/mnesia
    method: GET
- name: RABBITMQ_MNESIA_DIR
  endpoint:
    path: $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME
    method: GET
- name: RABBITMQ_LOG_BASE
  endpoint:
    path: ${install_prefix}/var/log/rabbitmq
    method: GET
- name: RABBITMQ_LOGS
  endpoint:
    path: $RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log
    method: GET
- name: RABBITMQ_PLUGINS_DIR
  endpoint:
    path: /usr/lib/rabbitmq/plugins:$RABBITMQ_HOME/plugins
    method: GET
- name: RABBITMQ_PLUGINS_EXPAND_DIR
  endpoint:
    path: $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME-plugins-expand
    method: GET
- name: RABBITMQ_ENABLED_PLUGINS_FILE
  endpoint:
    path: ${install_prefix}/etc/rabbitmq/enabled_plugins
    method: GET
- name: RABBITMQ_FEATURE_FLAGS_FILE
  endpoint:
    path: $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME-feature_flags
    method: GET
- name: RABBITMQ_PID_FILE
  endpoint:
    path: $RABBITMQ_MNESIA_DIR.pid
    method: GET
- name: some-queue
  endpoint:
    path: /queues/some-queue
    method: GET
    data_selector: records
- name: some-stream
  endpoint:
    path: /streams/some-stream
    method: GET
    data_selector: records
- name: queue
  endpoint:
    path: /management/queues
    method: POST
    data_selector: queue
    params: {}
- name: queue_info
  endpoint:
    path: /queue/info
    method: GET
    data_selector: getInfo
- name: delete_queue
  endpoint:
    path: /queue/delete
    method: DELETE
    data_selector: ''
- name: bind_queue
  endpoint:
    path: /queue/bind
    method: POST
    data_selector: ''
- name: unbind_queue
  endpoint:
    path: /queue/unbind
    method: DELETE
    data_selector: ''
- name: publisher
  endpoint:
    path: /publish
    method: POST
    data_selector: publishResult
- name: consumer
  endpoint:
    path: /consume
    method: POST
    data_selector: message
- name: some-stream
  endpoint:
    path: /some/stream
    method: GET
    data_selector: records
- name: my-queue
  endpoint:
    path: /my-queue
    method: GET
    data_selector: queue_info
- name: queue
  endpoint:
    path: /management/queues
    method: GET
    data_selector: queues
    params: {}
- name: consumer
  endpoint:
    path: /management/consumers
    method: GET
    data_selector: consumers
    params: {}
- name: queue_info
  endpoint:
    path: /getQueueInfo
    method: GET
    data_selector: getInfo
    params: {}
- name: delete_queue
  endpoint:
    path: /deleteQueue
    method: DELETE
    data_selector: ''
    params: {}
- name: bind_queue
  endpoint:
    path: /binding
    method: POST
    data_selector: ''
    params: {}
- name: unbind_queue
  endpoint:
    path: /unbind
    method: DELETE
    data_selector: ''
    params: {}
- name: PerfTest
  endpoint:
    path: /perf-test
    method: GET
- name: Tracer
  endpoint:
    path: /tracer
    method: GET
- name: some-queue
  endpoint:
    path: /some-queue
    method: GET
- name: some-stream
  endpoint:
    path: /some-stream
    method: GET
- name: my-exchange
  endpoint:
    path: /my-exchange
    method: POST
- name: my-queue
  endpoint:
    path: /my-queue
    method: POST
- name: my-quorum-queue
  endpoint:
    path: /my-quorum-queue
    method: POST
- name: queue_info
  endpoint:
    path: /queueInfo
    method: GET
    data_selector: getInfo
    params: {}
- name: delete_queue
  endpoint:
    path: /delete_queue
    method: DELETE
    data_selector: ''
    params: {}
- name: amqp_client
  endpoint:
    path: /client-libraries/erlang-client
    method: GET
- name: stream_filter
  endpoint:
    path: /stream/filter
    method: POST
    data_selector: annotations
    params:
      filter_value: invoices
- name: signing_keys
  endpoint:
    path: /docs/signatures
    method: GET
    data_selector: signing_keys
    params: {}
- name: importing_signing_keys
  endpoint:
    path: /importing-gpg-keys
    method: GET
    data_selector: importing_signing_keys
    params: {}
- name: verifying_signatures
  endpoint:
    path: /checking-signatures
    method: GET
    data_selector: verifying_signatures
    params: {}
- name: stream
  endpoint:
    path: /some-stream
    method: GET
    data_selector: message
    params:
      filters:
      - invoices
      - orders
      match_unfiltered: true
- name: exchange_bind
  endpoint:
    path: /exchange/bind
    method: POST
    data_selector: bindings
- name: stream_filter
  endpoint:
    path: /some-stream
    method: GET
    data_selector: messages
    params:
      filter_value: invoices
- name: consumer_creation
  endpoint:
    path: /some-queue
    method: POST
    data_selector: consumer
    params: {}
- name: exchange
  endpoint:
    path: /exchange
    method: POST
    data_selector: exchange
- name: queue
  endpoint:
    path: /queue
    method: POST
    data_selector: queue
- name: binding
  endpoint:
    path: /binding
    method: POST
    data_selector: binding
- name: local_random_exchange
  endpoint:
    path: /docs/local-random-exchange
    method: GET
    data_selector: overview
- name: some-queue
  endpoint:
    path: /some-queue
    method: GET
    data_selector: records
    params: {}
- name: some-stream
  endpoint:
    path: /some-stream
    method: GET
    data_selector: records
    params: {}
- name: queue_info
  endpoint:
    path: /getQueueInfo
    method: GET
    data_selector: getInfo
    params: {}
- name: delete_queue
  endpoint:
    path: /queueDelete
    method: DELETE
    data_selector: ''
    params: {}
- name: bind_queue
  endpoint:
    path: /binding
    method: POST
    data_selector: ''
    params: {}
- name: unbind_queue
  endpoint:
    path: /unbind
    method: DELETE
    data_selector: ''
    params: {}
- name: queue_info
  endpoint:
    path: /queueInfo
    method: GET
    data_selector: getInfo
    params: {}
- name: delete_queue
  endpoint:
    path: /delete_queue
    method: DELETE
    data_selector: ''
    params: {}
- name: bind_queue
  endpoint:
    path: /binding
    method: POST
    data_selector: ''
    params: {}
- name: unbind_queue
  endpoint:
    path: /unbind
    method: DELETE
    data_selector: ''
    params: {}
- name: PerfTest
  endpoint:
    path: /rabbitmq/perf-test
    method: GET
- name: Tracer
  endpoint:
    path: /rabbitmq/tracer
    method: GET
- name: permissions
  endpoint:
    path: /api/permissions
    method: POST
    data_selector: permissions
- name: users
  endpoint:
    path: /api/users
    method: GET
    data_selector: users
- name: auth_mechanisms
  endpoint:
    path: /auth/mechanisms
    method: GET
    data_selector: mechanisms
- name: signing_key
  endpoint:
    path: https://github.com/rabbitmq/signing-keys/releases/download/3.0/rabbitmq-release-signing-key.asc
    method: GET
    data_selector: signature
    params: {}
- name: debian_repository
  endpoint:
    path: https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
    method: GET
    data_selector: repository
    params: {}
- name: exchange_bind
  endpoint:
    path: /exchange/bind
    method: POST
    data_selector: bindings
- name: alternate_exchange
  endpoint:
    path: /docs/ae
    method: GET
    data_selector: overview
    params: {}
- name: user_permissions
  endpoint:
    path: /api/users/{user}/permissions
    method: GET
- name: auth_mechanisms
  endpoint:
    path: /auth/mechanisms
    method: GET
    data_selector: mechanisms
    params: {}
- name: auth_mechanisms
  endpoint:
    path: /auth/mechanisms
    method: GET
    data_selector: mechanisms
- name: default_user_credentials
  endpoint:
    params:
      default_user: a-user
      default_pass: 768a852ed69ce916fa7faa278c962de3e4275e5f
- name: user_permissions
  endpoint:
    path: /api/users/{user}/permissions
    method: GET
    data_selector: permissions
- name: rabbitmqctl
  endpoint:
    path: /rabbitmqctl
    method: GET
- name: rabbitmq-diagnostics
  endpoint:
    path: /rabbitmq-diagnostics
    method: GET
- name: rabbitmq-plugins
  endpoint:
    path: /rabbitmq-plugins
    method: GET
- name: rabbitmq-queues
  endpoint:
    path: /rabbitmq-queues
    method: GET
- name: rabbitmq-streams
  endpoint:
    path: /rabbitmq-streams
    method: GET
- name: rabbitmq-upgrade
  endpoint:
    path: /rabbitmq-upgrade
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: ''
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: ''
- name: node_tags
  endpoint:
    path: /api/overview
    method: GET
    data_selector: ''
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: user
  endpoint:
    path: /api/users/{user}
    method: PUT
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
- name: advanced_config_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: rabbitmqctl
  endpoint:
    path: /docs/next/man/rabbitmqctl.8
    method: GET
- name: rabbitmq-diagnostics
  endpoint:
    path: /docs/next/man/rabbitmq-diagnostics.8
    method: GET
- name: rabbitmq-plugins
  endpoint:
    path: /docs/next/man/rabbitmq-plugins.8
    method: GET
- name: rabbitmq-queues
  endpoint:
    path: /docs/next/man/rabbitmq-queues.8
    method: GET
- name: rabbitmq-streams
  endpoint:
    path: /docs/next/man/rabbitmq-streams.8
    method: GET
- name: rabbitmq-upgrade
  endpoint:
    path: /docs/next/man/rabbitmq-upgrade.8
    method: GET
- name: default_configuration
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: configurations
- name: advanced_configuration
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: configurations
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: rabbitmqctl
  endpoint:
    path: /rabbitmqctl
    method: GET
- name: rabbitmq-diagnostics
  endpoint:
    path: /rabbitmq-diagnostics
    method: GET
- name: rabbitmq-plugins
  endpoint:
    path: /rabbitmq-plugins
    method: GET
- name: rabbitmq-queues
  endpoint:
    path: /rabbitmq-queues
    method: GET
- name: rabbitmq-streams
  endpoint:
    path: /rabbitmq-streams
    method: GET
- name: rabbitmq-upgrade
  endpoint:
    path: /rabbitmq-upgrade
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
    params: {}
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
    params: {}
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
    params: {}
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: config
    params: {}
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: config
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: configuration
  endpoint:
    path: /api/configuration
    method: GET
    data_selector: configuration
    params: {}
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
- name: effective_configuration
  endpoint:
    path: /rabbitmq-diagnostics/environment
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: configuration_file
  endpoint:
    path: /docs/next/configure
    method: GET
    data_selector: configuration
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: parameters
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: ''
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: ''
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: effective_configuration
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: records
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
- name: configuration
  endpoint:
    path: /docs/next/configure
    method: GET
    data_selector: settings
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
    params: {}
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
    params: {}
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: ''
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: ''
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: ''
- name: effective_configuration
  endpoint:
    path: /rabbitmq-diagnostics/environment
    method: GET
    data_selector: effective_configuration
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
    data_selector: tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: configuration_file
  endpoint:
    path: /docs/next/configure
    method: GET
    data_selector: configuration
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
    data_selector: tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: listeners.tcp
  endpoint:
    path: /api/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: listeners.ssl
  endpoint:
    path: /api/ssl_listeners
    method: GET
    data_selector: ssl_listeners
    params: {}
- name: effective_configuration
  endpoint:
    path: /api/diagnostics/environment
    method: GET
    data_selector: effective_configuration
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
    data_selector: tags
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: status
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: effective_configuration
  endpoint:
    path: /rabbitmq-diagnostics/environment
    method: GET
    data_selector: effective_configuration
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: node_tags
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
    data_selector: tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: global_parameters
    params: {}
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: ''
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: ''
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: ''
    params: {}
- name: configuration
  endpoint:
    path: /configurations
    method: GET
    data_selector: records
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: ''
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: ''
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: ''
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: configuration_file
  endpoint:
    path: /docs/next/configure
    method: GET
    data_selector: configurations
    params: {}
- name: environment_variables
  endpoint:
    path: /docs/next/customise-environment
    method: GET
    data_selector: variables
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
    data_selector: parameters
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
    data_selector: tags
- name: overview
  endpoint:
    path: /overview
    method: GET
    data_selector: overview
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: records
- name: advanced_config_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
    data_selector: records
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
    data_selector: tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
    data_selector: records
    params: {}
- name: configuration_file
  endpoint:
    path: /etc/rabbitmq/rabbitmq.conf
    method: GET
- name: advanced_configuration_file
  endpoint:
    path: /etc/rabbitmq/advanced.config
    method: GET
- name: environment_variable_file
  endpoint:
    path: /path/to/a/custom/location/rabbitmq-env.conf
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: parameters
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: global_parameters
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
    params: {}
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: effective_configuration
  endpoint:
    path: /rabbitmq-diagnostics/environment
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: null
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: null
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: null
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /overview
    method: GET
- name: environment_variables
  endpoint:
    path: /docs/next/configure
    method: GET
    data_selector: environment_variables
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: configuration
  endpoint:
    path: /docs/next/configure
    method: GET
    data_selector: configuration
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: ''
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: ''
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: ''
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: null
    params: {}
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: vhosts
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: cluster_name
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: cluster_tags
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: PUT
    data_selector: ''
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: vhosts
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: vhost_deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
- name: remove_vhost_deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: DELETE
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: vhosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: vhosts
    params: {}
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/cluster-tags
    method: GET
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata.protected_from_deletion
    params: {}
- name: deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
    data_selector: ''
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: overview
  endpoint:
    path: /api/overview
    method: GET
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata.protected_from_deletion
    params: {}
- name: vhost_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
    data_selector: ''
    params: {}
- name: vhost_limits
  endpoint:
    path: /vhost_limits
    method: GET
- name: cluster_name
  endpoint:
    path: /api/global-parameters/cluster_name
    method: GET
    data_selector: value
    params: {}
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
    data_selector: tags
    params: {}
- name: RABBITMQ_BASE
  endpoint:
    path: Not used - Windows only
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_CONFIG_FILE
  endpoint:
    path: ${install_prefix}/etc/rabbitmq/rabbitmq
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_MNESIA_BASE
  endpoint:
    path: ${install_prefix}/var/lib/rabbitmq/mnesia
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_MNESIA_DIR
  endpoint:
    path: $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_LOG_BASE
  endpoint:
    path: ${install_prefix}/var/log/rabbitmq
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_LOGS
  endpoint:
    path: $RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_PLUGINS_DIR
  endpoint:
    path: /usr/lib/rabbitmq/plugins:$RABBITMQ_HOME/plugins
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_PLUGINS_EXPAND_DIR
  endpoint:
    path: $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME-plugins-expand
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_ENABLED_PLUGINS_FILE
  endpoint:
    path: ${install_prefix}/etc/rabbitmq/enabled_plugins
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_FEATURE_FLAGS_FILE
  endpoint:
    path: $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME-feature_flags
    method: GET
    data_selector: records
    params: {}
- name: RABBITMQ_PID_FILE
  endpoint:
    path: $RABBITMQ_MNESIA_DIR.pid
    method: GET
    data_selector: records
    params: {}
- name: log_file
  endpoint:
    path: /logging
    method: GET
    data_selector: log_entries
    params: {}
- name: log_console
  endpoint:
    path: /logging/console
    method: GET
    data_selector: log_entries
    params: {}
- name: ldap
  endpoint:
    path: /docs/next/ldap
    method: GET
    data_selector: records
- name: auth_backends
  endpoint:
    path: /auth_backends
    method: GET
    data_selector: records
- name: log
  endpoint:
    path: /logs
    method: GET
    data_selector: logs
    params: {}
- name: vhost_access_query
  endpoint:
    path: rabbitmq_auth_backend_ldap.vhost_access_query
    method: GET
    data_selector: records
    params:
      default_expression: '{constant, true}'
- name: resource_access_query
  endpoint:
    path: rabbitmq_auth_backend_ldap.resource_access_query
    method: GET
    data_selector: records
    params:
      default_expression: '{constant, true}'
- name: topic_access_query
  endpoint:
    path: rabbitmq_auth_backend_ldap.topic_access_query
    method: GET
    data_selector: records
    params:
      default_expression: '{constant, true}'
- name: tag_queries
  endpoint:
    path: rabbitmq_auth_backend_ldap.tag_queries
    method: GET
    data_selector: records
    params:
      default_expression: '[{administrator, {constant, false}}]'
- name: vhost_access_query
  endpoint:
    path: /vhost_access_query
    method: GET
    data_selector: records
    params:
      incremental: username
- name: resource_access_query
  endpoint:
    path: /resource_access_query
    method: GET
    data_selector: records
    params: {}
- name: topic_access_query
  endpoint:
    path: /topic_access_query
    method: GET
    data_selector: records
    params: {}
- name: log_file
  endpoint:
    path: /logging
    method: GET
    data_selector: logs
    params: {}
- name: cache
  endpoint:
    path: /auth_cache
    method: POST
    data_selector: cache_results
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: user_limits
  endpoint:
    path: /api/user-limits/{username}/{limit}
    method: PUT
    data_selector: value
    params: {}
- name: list_user_limits
  endpoint:
    path: /api/user-limits/{username}
    method: GET
    data_selector: limits
    params: {}
- name: delete_user_limits
  endpoint:
    path: /api/user-limits/{username}/{limit}
    method: DELETE
    data_selector: confirmation
    params: {}
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
- name: virtual_hosts
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: description, tags, default_queue_type
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: ''
    params: {}
- name: vhost
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: virtual_hosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: ''
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: vhost_deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
    data_selector: protection
    params: {}
- name: policies
  endpoint:
    path: /policies
    method: DELETE
    data_selector: definition_keys
    params:
      definition_keys: ha-mode,ha-params,ha-promote-on-shutdown,ha-promote-on-failure,ha-sync-mode,ha-sync-batch-size
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: vhosts
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: policies_declare
  endpoint:
    path: /api/policies/%2f/ttl-fed
    method: PUT
    data_selector: null
    params: {}
- name: vhost_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
    data_selector: metadata
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: metadata
    params: {}
- name: virtual_host
  endpoint:
    path: /api/vhosts/{name}
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: null
    params: {}
- name: vhost_deletion_protection
  endpoint:
    path: /api/vhosts/{name}/deletion/protection
    method: POST
    data_selector: error
    params: {}
- name: vhost_info
  endpoint:
    path: /api/vhosts/{vhost}
    method: GET
    data_selector: metadata.protected_from_deletion
    params: {}
- name: delete_definition_keys
  endpoint:
    path: /policies/delete_definition_keys
    method: DELETE
    data_selector: definition_keys
    params:
      name: cq.policies.1
      definition_keys: ha-mode,ha-params,ha-promote-on-shutdown,ha-promote-on-failure,ha-sync-mode,ha-sync-batch-size
- name: delete_definition_keys_from_all
  endpoint:
    path: /policies/delete_definition_keys_from_all_in
    method: DELETE
    data_selector: definition_keys
    params: {}
- name: vhost_limits
  endpoint:
    path: /vhosts/vhost_name/limits
    method: GET
    data_selector: limits
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f
    method: PUT
    data_selector: null
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: policy
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: delete_policy
  endpoint:
    path: /api/policies/vh.1/policy.name
    method: DELETE
    data_selector: null
    params: {}
- name: OAuth 2.0
  endpoint:
    path: /oauth2
    method: GET
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: GET
    data_selector: policies
    params: {}
- name: transient-queue-ttl
  endpoint:
    path: /api/operator-policies/%2f/transient-queue-ttl
    method: PUT
    data_selector: definition
    params:
      pattern: ^amq\.
      definition:
        expires: 1800000
      priority: 1
      apply-to: queues
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: ''
    params: {}
- name: policies
  endpoint:
    path: /api/policies/
    method: DELETE
    data_selector: ''
    params: {}
- name: ldap_server
  endpoint:
    path: /auth/ldap
    method: GET
    data_selector: servers
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: ldap_server
  endpoint:
    path: /auth/ldap
    method: GET
    data_selector: servers
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policy
  endpoint:
    path: /operator_policies
    method: PATCH
    data_selector: definition
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: vhost_access_query
  endpoint:
    params:
      in_group: ou=${vhost}-users,ou=vhosts,dc=example,dc=com
- name: resource_access_query
  endpoint:
    params:
      for:
      - permission: configure
        in_group: cn=admin,dc=example,dc=com
      - permission: write
        for:
        - resource: queue
          in_group: cn=admin,dc=example,dc=com
        - resource: exchange
          constant: true
      - permission: read
        for:
        - resource: exchange
          in_group: cn=admin,dc=example,dc=com
        - resource: queue
          constant: true
- name: topic_access_query
  endpoint:
    params:
      for:
      - permission: write
        match:
          string: ^a
      - permission: read
        constant: true
- name: tag_queries
  endpoint:
    params:
      administrator:
        constant: false
      management:
        constant: true
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: POST
    data_selector: ''
    params: {}
- name: list_policies
  endpoint:
    path: /api/policies/
    method: GET
    data_selector: ''
    params: {}
- name: delete_policy
  endpoint:
    path: /api/operator-policies/{vhost}/{policy_name}
    method: DELETE
    data_selector: ''
    params: {}
- name: auth_cache
  endpoint:
    path: /auth/cache
    method: POST
    data_selector: results
    params:
      cache_ttl: 5000
- name: policies
  endpoint:
    path: /vhosts/target.vhost/policies
    method: GET
    data_selector: policies
    params: {}
- name: matching_policy
  endpoint:
    path: /vhosts/target.vhost/policies/matching_object
    method: GET
    data_selector: matching_policies
    params:
      name: a.queue
      type: queues
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: user_limits
  endpoint:
    path: /api/user-limits/{username}/{limit}
    method: PUT
    data_selector: value
    params: {}
- name: list_user_limits
  endpoint:
    path: /api/user-limits/{username}
    method: GET
    data_selector: limits
    params: {}
- name: delete_user_limits
  endpoint:
    path: /api/user-limits/{username}/{limit}
    method: DELETE
    data_selector: result
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: GET
    data_selector: policies
    params: {}
- name: policies
  endpoint:
    path: /policies/list_matching_object
    method: GET
    params:
      vhost: target.vhost
      name: a.queue
      type: queues
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: pattern
    params: {}
- name: set_policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: clear_policy
  endpoint:
    path: /api/policies/{vhost}/{policy_name}
    method: DELETE
    data_selector: null
    params: {}
- name: declare_override
  endpoint:
    path: /api/policies/{vhost}/{policy_name}/override
    method: PUT
    data_selector: null
    params: {}
- name: declare_blanket
  endpoint:
    path: /api/policies/{vhost}/blanket
    method: POST
    data_selector: null
    params: {}
- name: policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
    params: {}
- name: policies
  endpoint:
    path: /policies
    method: GET
    data_selector: policies
    params:
      vhost: target.vhost
- name: matching_object
  endpoint:
    path: /policies/matching_object
    method: GET
    data_selector: matching_object
    params:
      vhost: target.vhost
      name: a.queue
      type: queues
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: policies_delete_definition_keys
  endpoint:
    path: /policies/delete_definition_keys
    method: DELETE
    data_selector: definition_keys
    params:
      name: cq.policies.1
      definition_keys: ha-mode,ha-params,ha-promote-on-shutdown,ha-promote-on-failure,ha-sync-mode,ha-sync-batch-size
- name: policies_delete_definition_keys_from_all
  endpoint:
    path: /policies/delete_definition_keys_from_all
    method: DELETE
    data_selector: definition_keys_from_all
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: GET
    data_selector: policies
    params: {}
- name: policy
  endpoint:
    path: /api/policies/
    method: GET
    data_selector: policies
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: null
    params: {}
- name: runtime_parameters
  endpoint:
    path: /api/parameters
    method: GET
    data_selector: parameters
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: global_parameters
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: pattern
    params: {}
- name: parameters
  endpoint:
    path: /api/parameters/{component_name}/{vhost}/{name}
    method: PUT
- name: global_parameters
  endpoint:
    path: /api/global-parameters/name
    method: PUT
- name: policies
  endpoint:
    path: /api/policies/%2f
    method: PUT
    data_selector: null
    params: {}
- name: virtual_host_scoped_parameters
  endpoint:
    path: /api/parameters/{component_name}/{vhost}/{name}
    method: PUT
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params:
      apply-to: queues
- name: metadata_store
  endpoint:
    path: /metadata/store
    method: GET
- name: mnesia
  endpoint:
    path: /mnesia
    method: GET
- name: khepri
  endpoint:
    path: /khepri
    method: GET
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: null
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policy_definition
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params:
      pattern: ^amq\.
      definition:
        expires: 1800000
      priority: 1
      apply-to: queues
- name: tcp_listen_options
  endpoint:
    path: tcp_listen_options.backlog
    method: SET
    data_selector: '4096'
- name: policy
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: ''
    params: {}
- name: network_interfaces
  endpoint:
    path: /docs/next/networking
    method: GET
    data_selector: interfaces
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: policy
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: null
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
    params: {}
- name: operator_policy
  endpoint:
    path: /operator_policies
    method: PATCH
    data_selector: definition
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/{policy_name}
    method: PUT
    data_selector: pattern
- name: epmd
  endpoint:
    path: /epmd
    method: GET
    data_selector: records
- name: operator_policy
  endpoint:
    path: /operator_policies
    method: GET
    data_selector: policies
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: ''
    params: {}
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: GET
    data_selector: policies
    params: {}
- name: policies
  endpoint:
    path: /policies/list_matching_object
    method: GET
    params:
      vhost: target.vhost
      name: a.queue
      type: queues
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policies
  endpoint:
    path: /api/operator-policies/
    method: POST
    data_selector: policies
    params: {}
- name: policies
  endpoint:
    path: /api/policies/
    method: GET
    data_selector: policies
    params: {}
- name: policies_in_virtual_host
  endpoint:
    path: /vhosts/{vhost}/policies
    method: GET
    data_selector: policies
    params:
      vhost: target.vhost
- name: policies_matching_queue
  endpoint:
    path: /vhosts/{vhost}/policies/matching
    method: GET
    data_selector: policies
    params:
      vhost: target.vhost
      name: a.queue
      type: queues
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: overview
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: overview
    params: {}
- name: authentication_and_authorization
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: overview
    params: {}
- name: policies
  endpoint:
    path: /api/policies/%2f/federate-me
    method: PUT
    data_selector: pattern
    params: {}
- name: operator_policy
  endpoint:
    path: /api/operator-policies/
    method: PUT
    data_selector: definition
- name: cluster_status
  endpoint:
    path: /cluster_status
    method: GET
    data_selector: status
    params: {}
- name: reset_node
  endpoint:
    path: /reset
    method: POST
    data_selector: result
    params: {}
- name: create_cluster
  endpoint:
    path: /create_cluster
    method: POST
    data_selector: result
    params: {}
- name: runtime_parameters
  endpoint:
    path: /api/parameters
    method: GET
    data_selector: parameters
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
    data_selector: global_parameters
    params: {}
- name: parameters
  endpoint:
    path: /api/parameters/{component_name}/{vhost}/{name}
    method: PUT
- name: global_parameters
  endpoint:
    path: /api/global-parameters/name
    method: PUT
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: authentication
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: content
    params: {}
- name: global_parameters
  endpoint:
    path: /api/global-parameters
    method: GET
- name: cluster_tags
  endpoint:
    path: /api/global-parameters/cluster_tags
    method: GET
- name: metadata_store
  endpoint:
    path: /metadata/store
    method: GET
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
    params: {}
- name: inter-node communication
  endpoint:
    path: /docs/next/runtime
    method: GET
- name: cluster_status
  endpoint:
    path: rabbitmqctl cluster_status
    method: GET
- name: reset_running_node
  endpoint:
    path: rabbitmqctl reset
    method: POST
- name: start_app
  endpoint:
    path: rabbitmqctl start_app
    method: POST
- name: stop_app
  endpoint:
    path: rabbitmqctl stop_app
    method: POST
- name: join_cluster
  endpoint:
    path: rabbitmqctl join_cluster
    method: POST
- name: forget_cluster_node
  endpoint:
    path: rabbitmqctl forget_cluster_node
    method: POST
- name: force_boot
  endpoint:
    path: rabbitmqctl force_boot
    method: POST
- name: Cluster Formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: Node Names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: Erlang Cookie
  endpoint:
    path: /docs/next/erlang-cookie
    method: GET
    data_selector: content
    params: {}
- name: listeners
  endpoint:
    path: /api/listeners
    method: GET
    data_selector: listeners
- name: ports
  endpoint:
    path: /api/ports
    method: GET
    data_selector: ports
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: overview
    params: {}
- name: clustering_and_clients
  endpoint:
    path: /docs/next/clustering-and-clients
    method: GET
    data_selector: overview
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: overview
    params: {}
- name: node_management
  endpoint:
    path: /nodes
    method: GET
    data_selector: nodes
    params: {}
- name: cluster_status
  endpoint:
    path: /cluster_status
    method: GET
    data_selector: status
    params: {}
- name: Cluster Formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: Node Names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: Hostname Resolution
  endpoint:
    path: /docs/next/hostname-resolution
    method: GET
    data_selector: content
    params: {}
- name: Erlang Cookie
  endpoint:
    path: /docs/next/erlang-cookie
    method: GET
    data_selector: content
    params: {}
- name: Cluster Formation
  endpoint:
    path: /docs/next/clustering
    method: GET
    data_selector: overview
    params: {}
- name: Node Names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: overview
    params: {}
- name: Cluster Formation Requirements
  endpoint:
    path: /docs/next/cluster-formation-requirements
    method: GET
    data_selector: overview
    params: {}
- name: Hostname Resolution
  endpoint:
    path: /docs/next/hostname-resolution
    method: GET
    data_selector: overview
    params: {}
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
- name: reset_node
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
- name: start_app
  endpoint:
    path: /rabbitmqctl/start_app
    method: POST
- name: stop_app
  endpoint:
    path: /rabbitmqctl/stop_app
    method: POST
- name: forget_cluster_node
  endpoint:
    path: /rabbitmqctl/forget_cluster_node
    method: POST
- name: force_boot
  endpoint:
    path: /rabbitmqctl/force_boot
    method: POST
- name: cluster_formation_requirements
  endpoint:
    path: /docs/next/cluster-formation-requirements
    method: GET
    data_selector: requirements
- name: clustering_and_clients
  endpoint:
    path: /docs/next/clustering-and-clients
    method: GET
    data_selector: clients
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: clustering_and_clients
  endpoint:
    path: /docs/next/clustering-and-clients
    method: GET
    data_selector: content
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: hostname_resolution
  endpoint:
    path: /docs/next/hostname-resolution
    method: GET
    data_selector: content
    params: {}
- name: authentication_and_authorization
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: content
    params: {}
- name: cluster_status
  endpoint:
    path: /cluster_status
    method: GET
    data_selector: running_nodes
- name: reset_node
  endpoint:
    path: /reset
    method: POST
    data_selector: status
- name: start_app
  endpoint:
    path: /start_app
    method: POST
    data_selector: status
- name: join_cluster
  endpoint:
    path: /join_cluster
    method: POST
    data_selector: status
- name: forget_cluster_node
  endpoint:
    path: /forget_cluster_node
    method: POST
    data_selector: status
- name: force_boot
  endpoint:
    path: /force_boot
    method: POST
    data_selector: status
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
- name: authentication
  endpoint:
    path: /docs/next/access-control
    method: GET
- name: networking
  endpoint:
    path: /docs/next/networking
    method: GET
- name: clustering
  endpoint:
    path: /docs/next/clustering
    method: GET
    data_selector: overview
    params: {}
- name: Cluster Formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: Node Names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: Hostname Resolution
  endpoint:
    path: /docs/next/hostname-resolution
    method: GET
    data_selector: content
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: authentication
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: content
    params: {}
- name: cluster_status
  endpoint:
    path: /cluster_status
    method: GET
    data_selector: status
    params: {}
- name: reset_node
  endpoint:
    path: /reset
    method: POST
    data_selector: result
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
- name: replication
  endpoint:
    path: /docs/next/what-is-replicated
    method: GET
    data_selector: content
- name: erlang_cookie
  endpoint:
    path: /docs/next/erlang-cookie
    method: GET
    data_selector: content
- name: cluster
  endpoint:
    path: /docs/next/clustering
    method: GET
    data_selector: overview
    params: {}
- name: runtime_stats
  endpoint:
    path: /diagnostics/runtime_thread_stats
    method: GET
    data_selector: thread_activity
    params: {}
- name: minimum_hardware_requirements
  endpoint:
    path: /docs/next/production-checklist
    method: GET
    data_selector: requirements
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
- name: node_metrics
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
- name: queue_metrics
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue_metrics
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
- name: node_metrics
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
- name: individual_queue_metrics
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue_metrics
- name: Cluster Formation
  endpoint:
    path: /docs/next/clustering
    method: GET
    data_selector: content
    params: {}
- name: Cluster Formation Requirements
  endpoint:
    path: /docs/next/cluster-formation-requirements
    method: GET
    data_selector: content
    params: {}
- name: Node Names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
    params: {}
- name: Erlang Cookie
  endpoint:
    path: /docs/next/erlang-cookie
    method: GET
    data_selector: content
    params: {}
- name: ssl
  endpoint:
    path: /listeners.ssl.default
    method: GET
    data_selector: records
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: topics
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: topics
    params: {}
- name: authentication
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: topics
    params: {}
- name: Ssl
  endpoint:
    path: /path/to/client_key.p12
    method: GET
    data_selector: Ssl
    params: {}
- name: tls_configuration
  endpoint:
    path: /docs/next/ssl
    method: GET
    data_selector: tls_settings
    params: {}
- name: tls_configuration
  endpoint:
    path: /path/to/tls_configuration
    method: GET
    data_selector: tls_settings
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
- name: authentication_and_authorization
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: content
- name: networking
  endpoint:
    path: /docs/next/networking
    method: GET
    data_selector: content
- name: cluster_formation_requirements
  endpoint:
    path: /docs/next/cluster-formation-requirements
    method: GET
    data_selector: requirements
    params: {}
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: node_names
    params: {}
- name: erlang_cookie
  endpoint:
    path: /docs/next/erlang-cookie
    method: GET
    data_selector: cookie
    params: {}
- name: tls_configuration
  endpoint:
    path: /docs/next/ssl
    method: GET
    data_selector: configuration
    params: {}
- name: connection
  endpoint:
    path: /
    method: GET
- name: cluster_formation
  endpoint:
    path: /docs/next/cluster-formation
    method: GET
    data_selector: content
- name: node_names
  endpoint:
    path: /docs/next/node-names
    method: GET
    data_selector: content
- name: hostname_resolution
  endpoint:
    path: /docs/next/hostname-resolution
    method: GET
    data_selector: content
- name: authentication
  endpoint:
    path: /docs/next/access-control
    method: GET
    data_selector: content
- name: management
  endpoint:
    path: /
    method: GET
- name: Cluster Operator
  endpoint:
    path: /kubernetes/operator
    method: GET
    data_selector: operational_features
    params: {}
- name: Messaging Topology Operator
  endpoint:
    path: /kubernetes/topology/operator
    method: GET
    data_selector: topology_features
    params: {}
- name: management
  endpoint:
    path: /api/
    method: GET
- name: cluster_overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: object_totals
    params: {}
- name: node_metrics
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: queue_metrics
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queue_metrics
    params: {}
- name: nodes
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: memory
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
    params: {}
- name: listeners
  endpoint:
    path: /api/nodes/{node}/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: virtual_hosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: overview
  endpoint:
    path: /api/overview
    method: GET
    data_selector: overview
- name: nodes
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: nodes
- name: queues
  endpoint:
    path: /api/queues/{vhost}/{qname}
    method: GET
    data_selector: queues
- name: TLS Configuration
  endpoint:
    path: /docs/next/ssl
    method: GET
    data_selector: configuration
- name: tls_configuration
  endpoint:
    path: /tls/configuration
    method: GET
    data_selector: tls_settings
    params: {}
- name: ssl_config
  endpoint:
    path: /management/ssl
    method: GET
    data_selector: records
    params: {}
- name: rabbitmq
  endpoint:
    path: /
    method: GET
    data_selector: records
- name: message_rates
  endpoint:
    path: /api/message_rates
    method: GET
    data_selector: rates
- name: tls_configuration
  endpoint:
    path: /docs/next/ssl
    method: GET
    data_selector: configuration
    params: {}
- name: modern-erlang
  endpoint:
    path: /erlang/el/8/$basearch
    method: GET
- name: rabbitmq-el8
  endpoint:
    path: /rabbitmq/el/8/$basearch
    method: GET
- name: modern-erlang
  endpoint:
    path: /erlang/el/9/$basearch
    method: GET
- name: rabbitmq
  endpoint:
    path: /rabbitmq/el/9/$basearch
    method: GET
- name: TLS Support
  endpoint:
    path: /docs/next/ssl
    method: GET
    data_selector: content
    params: {}
- name: rabbitmq-server
  endpoint:
    path: /rabbitmq/el/8/$basearch
    method: GET
- name: modern-erlang
  endpoint:
    path: /erlang/el/8/$basearch
    method: GET
- name: certificate_management
  endpoint:
    path: /path/to/certificate_management
    method: GET
- name: TLS 1.3 Setup
  endpoint:
    path: /path/to/tls1.3/setup
    method: GET
    data_selector: setup
    params: {}
- name: TLS 1.2 Setup with Restricted Cipher Suites
  endpoint:
    path: /path/to/tls1.2/setup
    method: GET
    data_selector: setup
    params: {}
- name: alternate_exchange
  endpoint:
    path: /docs/next/ae
    method: GET
    data_selector: ''
    params: {}
- name: dead_letter_exchanges
  endpoint:
    path: /api/policies/%2f/DLX
    method: PUT
    data_selector: null
    params: {}
- name: mqtt_configuration
  endpoint:
    path: /mqtt/config
    method: GET
    data_selector: config_data
    params: {}
- name: mqtt_user
  endpoint:
    path: /api/users
    method: POST
    data_selector: users
    params: {}
- name: tcp_listener
  endpoint:
    path: /mqtt.listeners.tcp.1
    method: GET
    data_selector: listeners
    params: {}
- name: retained_message_store
  endpoint:
    path: /mqtt.retained_message_store_dets_sync_interval
    method: GET
    data_selector: sync_interval
    params: {}
- name: tls_support
  endpoint:
    path: /ssl_options
    method: GET
    data_selector: ssl
    params: {}
- name: mqtt_users
  endpoint:
    path: /api/users
    method: GET
    data_selector: users
- name: API
  endpoint:
    path: /rabbitmq/api/
    method: GET
    data_selector: ''
    params: {}
- name: retained_messages
  endpoint:
    path: /mqtt/retained_messages
    method: GET
    data_selector: messages
- name: tcp_listener
  endpoint:
    path: /stomp.listeners.tcp.1
    method: SET
    data_selector: listeners
    params: {}
- name: ssl_listener
  endpoint:
    path: /stomp.listeners.ssl.1
    method: SET
    data_selector: listeners
    params: {}
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: enabled_plugins
  endpoint:
    path: /plugins
    method: GET
    data_selector: enabled_plugins
- name: plugin_directories
  endpoint:
    path: /plugins/directories
    method: GET
    data_selector: plugin_directories
- name: sample_retention_policies
  endpoint:
    path: /api/sample_retention_policies
    method: GET
    data_selector: policies
- name: management
  endpoint:
    path: /api/management
    method: GET
    data_selector: management
- name: modern-erlang
  endpoint:
    path: /erlang/el/9/$basearch
    method: GET
- name: rabbitmq-el9
  endpoint:
    path: /rabbitmq/el/9/$basearch
    method: GET
- name: modern-erlang-noarch
  endpoint:
    path: /erlang/el/9/noarch
    method: GET
- name: rabbitmq-el8
  endpoint:
    path: /rabbitmq/el/8/$basearch
    method: GET
- name: modern-erlang-el8-noarch
  endpoint:
    path: /erlang/el/8/noarch
    method: GET
- name: rabbitmq_auth_backend_ldap
  endpoint:
    path: /plugins/rabbitmq_auth_backend_ldap
    method: GET
- name: rabbitmq_auth_backend_oauth2
  endpoint:
    path: /plugins/rabbitmq_auth_backend_oauth2
    method: GET
- name: rabbitmq_auth_backend_http
  endpoint:
    path: /plugins/rabbitmq_auth_backend_http
    method: GET
- name: rabbitmq_management
  endpoint:
    path: /plugins/rabbitmq_management
    method: GET
- name: modern-erlang-el8
  endpoint:
    path: /erlang/el/8/noarch
    method: GET
    data_selector: pkg
    params: {}
- name: rabbitmq-el8
  endpoint:
    path: /rabbitmq/el/8/$basearch
    method: GET
    data_selector: pkg
    params: {}
- name: my_rabbitmq_plugin
  endpoint:
    path: /path/to/your/plugin
    method: GET
    data_selector: records
- name: modern-erlang
  endpoint:
    path: https://yum1.rabbitmq.com/erlang/el/9/$basearch
    method: GET
- name: rabbitmq-el9
  endpoint:
    path: https://yum2.rabbitmq.com/rabbitmq/el/9/$basearch
    method: GET
- name: rabbitmq-el8
  endpoint:
    path: https://yum2.rabbitmq.com/rabbitmq/el/8/$basearch
    method: GET
- name: rabbitmq-server
  endpoint:
    path: /rabbitmq-server-4.1.4-1.el8.noarch.rpm
    method: GET
    data_selector: package
    params: {}
- name: alternate_exchange_policy
  endpoint:
    path: /policies/AE
    method: POST
    data_selector: alternate-exchange
    params: {}
- name: dead_letter_exchange
  endpoint:
    path: /api/policies/%2f/DLX
    method: PUT
    data_selector: definition
    params:
      pattern: .*
      definition:
        dead-letter-exchange: my-dlx
      priority: 7
      apply-to: queues
- name: dead_letter_effects
  endpoint:
    path: /docs/dead-letter-effects
    method: GET
    data_selector: effects
    params: {}
- name: dead_letter_reason
  endpoint:
    path: /docs/dead-letter-reason
    method: GET
    data_selector: reason
    params: {}
- name: password_hashing
  endpoint:
    path: /docs/configure#config-file
    method: GET
    data_selector: hashing modules
    params: {}
- name: credential_validators
  endpoint:
    path: /docs/configure#credential-validation
    method: GET
    data_selector: validators
    params: {}
- name: mqtt_listener_tcp
  endpoint:
    path: /mqtt/listeners/tcp/default
    method: GET
    data_selector: default
    params: {}
- name: mqtt_listener_ssl
  endpoint:
    path: /mqtt/listeners/ssl/default
    method: GET
    data_selector: default
    params: {}
- name: mqtt_vhost
  endpoint:
    path: /mqtt/vhost
    method: GET
    data_selector: vhost
    params: {}
- name: mqtt_exchange
  endpoint:
    path: /mqtt/exchange
    method: GET
    data_selector: exchange
    params: {}
- name: mqtt_prefetch
  endpoint:
    path: /mqtt/prefetch
    method: GET
    data_selector: prefetch
    params: {}
- name: auth_backends
  endpoint:
    path: /auth_backends
    method: GET
    data_selector: backends
    params: {}
- name: ldap_servers
  endpoint:
    path: /auth_ldap/servers
    method: GET
    data_selector: servers
    params: {}
- name: mqtt
  endpoint:
    path: /api/global-parameters/mqtt_port_to_vhost_mapping
    method: PUT
- name: auth_backends
  endpoint:
    path: /auth_backends
    method: GET
    data_selector: data
    params: {}
- name: servers
  endpoint:
    path: /servers
    method: GET
    data_selector: data
    params: {}
- name: mqtt
  endpoint:
    path: /api/mqtt
    method: GET
    data_selector: data
- name: vhost_access_query
  endpoint:
    params:
      default: '{constant, true}'
- name: resource_access_query
  endpoint:
    params:
      default: '{constant, true}'
- name: topic_access_query
  endpoint:
    params:
      default: '{constant, true}'
- name: tag_queries
  endpoint:
    params:
      default: '[{administrator, {constant, false}}]'
- name: tcp_listener
  endpoint:
    path: /stomp/listeners/tcp
    method: GET
    data_selector: listeners
    params: {}
- name: tls_listener
  endpoint:
    path: /stomp/listeners/ssl
    method: GET
    data_selector: listeners
    params: {}
- name: cache_backend
  endpoint:
    path: /auth_backend/cache
    method: POST
    data_selector: cache
- name: queue
  endpoint:
    path: /amq/queue/<name>
    method: SEND
    data_selector: ''
    params: {}
- name: topic
  endpoint:
    path: /topic/<name>
    method: SEND
    data_selector: ''
    params: {}
- name: user_limits
  endpoint:
    path: /api/user-limits/{username}/{limit}
    method: PUT
    data_selector: value
    params: {}
- name: plugins
  endpoint:
    path: /plugins
    method: GET
    data_selector: records
- name: definitions_export
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
- name: definitions_import
  endpoint:
    path: /api/definitions
    method: POST
    data_selector: definitions
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
    params: {}
- name: enabled_plugins
  endpoint:
    path: /rabbitmq-plugins/enabled_plugins
    method: GET
- name: plugin_directories
  endpoint:
    path: /rabbitmq-plugins/directories
    method: GET
- name: rabbitmq_management
  endpoint:
    path: /path/to/rabbitmq/plugins
    method: GET
- name: rabbitmq_shovel
  endpoint:
    path: /path/to/rabbitmq/shovel
    method: GET
- name: rabbitmq_management_agent
  endpoint:
    path: /path/to/rabbitmq/management_agent
    method: GET
- name: rabbitmq_shovel_management
  endpoint:
    path: /path/to/rabbitmq/shovel_management
    method: GET
- name: listeners
  endpoint:
    path: /networking/listeners
    method: GET
    data_selector: listeners
    params: {}
- name: epmd
  endpoint:
    path: /networking/epmd
    method: GET
    data_selector: epmd
    params: {}
- name: rabbitmq_auth_backend_ldap
  endpoint:
    path: ./ldap
    method: GET
- name: rabbitmq_auth_backend_oauth2
  endpoint:
    path: ./oauth2
    method: GET
- name: rabbitmq_auth_backend_http
  endpoint:
    path: https://github.com/rabbitmq/rabbitmq-server/blob/main/deps/rabbitmq_auth_backend_http/README.md
    method: GET
- name: rabbitmq_management
  endpoint:
    path: ./management
    method: GET
- name: rabbitmq_federation
  endpoint:
    path: ./federation
    method: GET
- name: rabbitmq_mqtt
  endpoint:
    path: ./mqtt
    method: GET
- name: rabbitmq_prometheus
  endpoint:
    path: ./prometheus
    method: GET
- name: rabbitmq_shovel
  endpoint:
    path: ./shovel
    method: GET
- name: rabbitmq_tracing
  endpoint:
    path: ./firehose
    method: GET
- name: rabbitmq_web_stomp
  endpoint:
    path: ./web-stomp
    method: GET
- name: rabbitmq_web_mqtt
  endpoint:
    path: ./web-mqtt
    method: GET
- name: rabbitmq_metronome
  endpoint:
    path: /path/to/rabbitmq_metronome
    method: GET
    data_selector: data
    params: {}
- name: password_hashing_module
  endpoint:
    path: /docs/configure#config-file
    method: GET
    data_selector: hashing_modules
    params: {}
- name: credential_validator
  endpoint:
    path: /docs/configure
    method: GET
    data_selector: credential_validators
    params: {}
- name: resource_server_id
  endpoint:
    path: /auth_oauth2.resource_server_id
    method: GET
- name: scope_prefix
  endpoint:
    path: /auth_oauth2.scope_prefix
    method: GET
- name: auth_backends
  endpoint:
    path: /docs/access-control
    method: GET
    data_selector: auth_backends
    params: {}
- name: ldap_servers
  endpoint:
    path: /connectivity
    method: GET
    data_selector: servers
    params: {}
- name: auth_backend_ldap
  endpoint:
    path: /auth_backend/ldap
    method: GET
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
    data_selector: status
- name: stop_app
  endpoint:
    path: /rabbitmqctl/stop_app
    method: POST
    data_selector: status
- name: reset
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
    data_selector: status
- name: start_app
  endpoint:
    path: /rabbitmqctl/start_app
    method: POST
    data_selector: status
- name: forget_cluster_node
  endpoint:
    path: /rabbitmqctl/forget_cluster_node
    method: POST
    data_selector: status
- name: check_running
  endpoint:
    path: /rabbitmq-diagnostics/check_running
    method: GET
    data_selector: status
- name: ping
  endpoint:
    path: /rabbitmq-diagnostics/ping
    method: GET
    data_selector: status
- name: vhost_access
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: resource_access
  endpoint:
    path: /resources
    method: GET
    data_selector: resources
- name: user_limits
  endpoint:
    path: /api/user-limits/{username}/{limit}
    method: PUT
    data_selector: value
- name: Mnesia
  endpoint:
    path: /docs/mnesia
    method: GET
- name: Khepri
  endpoint:
    path: /docs/khepri
    method: GET
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
    params: {}
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/clustering
    method: GET
    data_selector: content
    params: {}
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
    data_selector: content
    params: {}
- name: cluster_requirements
  endpoint:
    path: /docs/cluster-formation-requirements
    method: GET
    data_selector: content
    params: {}
- name: proxy_protocol
  endpoint:
    path: /proxy-protocol
    method: GET
    data_selector: protocol_versions
    params: {}
- name: listeners
  endpoint:
    path: /docs/networking
    method: GET
    data_selector: listeners.tcp.*
- name: epmd
  endpoint:
    path: /docs/epmd
    method: GET
    data_selector: epmd
- name: inter-node communication
  endpoint:
    path: /docs/distribution
    method: GET
    data_selector: inter-node communication
- name: cluster_status
  endpoint:
    path: /cluster_status
    method: GET
- name: reset_node
  endpoint:
    path: /reset
    method: POST
- name: start_app
  endpoint:
    path: /start_app
    method: POST
- name: forget_cluster_node
  endpoint:
    path: /forget_cluster_node
    method: POST
- name: force_boot
  endpoint:
    path: /force_boot
    method: POST
- name: cluster
  endpoint:
    path: /clustering
    method: GET
    data_selector: nodes
- name: nodes
  endpoint:
    path: /nodes
    method: GET
    data_selector: nodes
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
- name: force_boot
  endpoint:
    path: /rabbitmqctl/force_boot
    method: POST
- name: reset_node
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
    data_selector: nodes
    params: {}
- name: stop_app
  endpoint:
    path: /rabbitmqctl/stop_app
    method: POST
    data_selector: response
    params: {}
- name: forget_cluster_node
  endpoint:
    path: /rabbitmqctl/forget_cluster_node
    method: POST
    data_selector: response
    params: {}
- name: reset
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
    data_selector: response
    params: {}
- name: start_app
  endpoint:
    path: /rabbitmqctl/start_app
    method: POST
    data_selector: response
    params: {}
- name: cluster_status
  endpoint:
    path: /cluster/status
    method: GET
    data_selector: status
    params: {}
- name: reset_node
  endpoint:
    path: /node/reset
    method: POST
    data_selector: result
    params: {}
- name: create_cluster
  endpoint:
    path: /cluster/create
    method: POST
    data_selector: confirmation
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/cluster-formation
    method: GET
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
- name: networking
  endpoint:
    path: /docs/networking
    method: GET
- name: clear_permissions
  endpoint:
    path: /clear_permissions
    method: POST
    data_selector: permissions
    params:
      vhost: my-vhost
      username: janeway
- name: clear_topic_permissions
  endpoint:
    path: /clear_topic_permissions
    method: POST
    data_selector: topic_permissions
    params:
      vhost: my-vhost
      username: janeway
      exchange: amq.topic
- name: list_permissions
  endpoint:
    path: /list_permissions
    method: GET
    data_selector: permissions_list
    params:
      vhost: my-vhost
- name: list_topic_permissions
  endpoint:
    path: /list_topic_permissions
    method: GET
    data_selector: topic_permissions_list
    params:
      vhost: my-vhost
- name: list_user_permissions
  endpoint:
    path: /list_user_permissions
    method: GET
    data_selector: user_permissions
    params:
      username: janeway
- name: list_user_topic_permissions
  endpoint:
    path: /list_user_topic_permissions
    method: GET
    data_selector: user_topic_permissions
    params:
      username: janeway
- name: list_vhosts
  endpoint:
    path: /list_vhosts
    method: GET
    data_selector: vhosts_list
    params: {}
- name: set_permissions
  endpoint:
    path: /set_permissions
    method: POST
    data_selector: set_permissions_response
    params:
      vhost: my-vhost
      user: janeway
      conf: ^janeway-.
      write: .
      read: .*
- name: set_permissions_globally
  endpoint:
    path: /set_permissions_globally
    method: POST
    data_selector: set_permissions_global_response
    params:
      username: janeway
      conf: ^janeway-.
      write: .
      read: .*
- name: set_topic_permissions
  endpoint:
    path: /set_topic_permissions
    method: POST
    data_selector: set_topic_permissions_response
    params:
      vhost: my-vhost
      user: janeway
      exchange: amq.topic
      write: ^janeway-.
      read: ^janeway-.
- name: cluster_formation
  endpoint:
    path: /docs/cluster-formation
    method: GET
    data_selector: cluster_formation_data
    params: {}
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
    data_selector: node_names_data
    params: {}
- name: authentication
  endpoint:
    path: /docs/access-control
    method: GET
    data_selector: authentication_data
    params: {}
- name: ports
  endpoint:
    path: /docs/networking#ports
    method: GET
    data_selector: ports_data
    params: {}
- name: list_bindings
  endpoint:
    path: /list_bindings
    method: GET
- name: list_channels
  endpoint:
    path: /list_channels
    method: GET
- name: list_connections
  endpoint:
    path: /list_connections
    method: GET
- name: list_consumers
  endpoint:
    path: /list_consumers
    method: GET
- name: list_exchanges
  endpoint:
    path: /list_exchanges
    method: GET
- name: list_queues
  endpoint:
    path: /list_queues
    method: GET
- name: list_unresponsive_queues
  endpoint:
    path: /list_unresponsive_queues
    method: GET
- name: unresponsive_queues
  endpoint:
    path: /list_unresponsive_queues
    method: GET
    data_selector: name
    params:
      local: true
- name: status
  endpoint:
    path: /status
    method: GET
    data_selector: broker_status_info
- name: report
  endpoint:
    path: /report
    method: GET
    data_selector: server_status_report
- name: schema_info
  endpoint:
    path: /schema_info
    method: GET
    data_selector: schema_database_tables
- name: cluster
  endpoint:
    path: /cluster
    method: GET
    data_selector: nodes
    params: {}
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
    data_selector: ''
- name: stop_app
  endpoint:
    path: /rabbitmqctl/stop_app
    method: POST
    data_selector: ''
- name: reset
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
    data_selector: ''
- name: forget_cluster_node
  endpoint:
    path: /rabbitmqctl/forget_cluster_node
    method: POST
    data_selector: ''
- name: force_boot
  endpoint:
    path: /rabbitmqctl/force_boot
    method: POST
    data_selector: ''
- name: cluster_formation
  endpoint:
    path: /docs/cluster-formation
    method: GET
    data_selector: content
    params: {}
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
    data_selector: content
    params: {}
- name: hostname_resolution
  endpoint:
    path: /docs/hostname-resolution
    method: GET
    data_selector: content
    params: {}
- name: ports
  endpoint:
    path: /docs/ports
    method: GET
    data_selector: content
    params: {}
- name: clear_global_parameter
  endpoint:
    path: /clear_global_parameter
    method: POST
- name: clear_parameter
  endpoint:
    path: /clear_parameter
    method: POST
- name: list_global_parameters
  endpoint:
    path: /list_global_parameters
    method: GET
- name: list_parameters
  endpoint:
    path: /list_parameters
    method: GET
- name: set_global_parameter
  endpoint:
    path: /set_global_parameter
    method: POST
- name: set_parameter
  endpoint:
    path: /set_parameter
    method: POST
- name: list_policies
  endpoint:
    path: /list_policies
    method: GET
- name: set_operator_policy
  endpoint:
    path: /set_operator_policy
    method: POST
- name: set_policy
  endpoint:
    path: /set_policy
    method: POST
- name: clear_policy
  endpoint:
    path: /clear_policy
    method: POST
- name: clear_operator_policy
  endpoint:
    path: /clear_operator_policy
    method: POST
- name: list_operator_policies
  endpoint:
    path: /list_operator_policies
    method: GET
- name: add_vhost
  endpoint:
    path: /add_vhost
    method: POST
- name: clear_vhost_limits
  endpoint:
    path: /clear_vhost_limits
    method: POST
- name: delete_vhost
  endpoint:
    path: /delete_vhost
    method: DELETE
- name: list_vhost_limits
  endpoint:
    path: /list_vhost_limits
    method: GET
- name: restart_vhost
  endpoint:
    path: /restart_vhost
    method: POST
- name: set_vhost_limits
  endpoint:
    path: /set_vhost_limits
    method: POST
- name: set_user_limits
  endpoint:
    path: /set_user_limits
    method: POST
- name: clear_user_limits
  endpoint:
    path: /clear_user_limits
    method: POST
- name: trace_off
  endpoint:
    path: /trace_off
    method: POST
- name: trace_on
  endpoint:
    path: /trace_on
    method: POST
- name: decode
  endpoint:
    path: /decode
    method: POST
- name: encode
  endpoint:
    path: /encode
    method: POST
- name: set_cluster_name
  endpoint:
    path: /set_cluster_name
    method: POST
- name: set_disk_free_limit
  endpoint:
    path: /set_disk_free_limit
    method: POST
- name: set_log_level
  endpoint:
    path: /set_log_level
    method: POST
- name: set_vm_memory_high_watermark
  endpoint:
    path: /set_vm_memory_high_watermark
    method: POST
- name: enable_feature_flag
  endpoint:
    path: /enable_feature_flag
    method: POST
- name: list_feature_flags
  endpoint:
    path: /list_feature_flags
    method: GET
- name: close_all_connections
  endpoint:
    path: /close_all_connections
    method: POST
- name: close_connection
  endpoint:
    path: /close_connection
    method: POST
- name: delete_queue
  endpoint:
    path: /delete_queue
    method: DELETE
- name: purge_queue
  endpoint:
    path: /purge_queue
    method: POST
- name: shovel_status
  endpoint:
    path: /shovel_status
    method: GET
    data_selector: configuredShovels
- name: federation_status
  endpoint:
    path: /federation_status
    method: GET
    data_selector: federationLinks
- name: list_amqp10_connections
  endpoint:
    path: /list_amqp10_connections
    method: GET
    data_selector: amqp10Connections
- name: list_mqtt_connections
  endpoint:
    path: /list_mqtt_connections
    method: GET
    data_selector: mqttConnections
- name: list_stomp_connections
  endpoint:
    path: /list_stomp_connections
    method: GET
    data_selector: stompConnections
- name: reset_stats_db
  endpoint:
    path: /reset_stats_db
    method: POST
    data_selector: resetStats
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
    data_selector: status
    params: {}
- name: reset_node
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
    data_selector: reset
    params: {}
- name: start_app
  endpoint:
    path: /rabbitmqctl/start_app
    method: POST
    data_selector: start
    params: {}
- name: forget_cluster_node
  endpoint:
    path: /rabbitmqctl/forget_cluster_node
    method: POST
    data_selector: forget
    params: {}
- name: force_boot
  endpoint:
    path: /rabbitmqctl/force_boot
    method: POST
    data_selector: boot
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/cluster-formation
    method: GET
    data_selector: overview
    params: {}
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
    data_selector: overview
    params: {}
- name: cluster_membership
  endpoint:
    path: /docs/cluster-membership
    method: GET
    data_selector: overview
    params: {}
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: definitions
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: cluster_status
  endpoint:
    path: /cluster_status
    method: GET
- name: stop_app
  endpoint:
    path: /stop_app
    method: POST
- name: reset
  endpoint:
    path: /reset
    method: POST
- name: forget_cluster_node
  endpoint:
    path: /forget_cluster_node
    method: POST
- name: churn
  endpoint:
    path: /show/churn
    method: GET
- name: nodes
  endpoint:
    path: /nodes/list
    method: GET
- name: vhosts
  endpoint:
    path: /vhosts/list
    method: GET
- name: users
  endpoint:
    path: /users/list
    method: GET
- name: create_user
  endpoint:
    path: /users/declare
    method: POST
- name: delete_user
  endpoint:
    path: /users/delete
    method: DELETE
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: cluster_formation
  endpoint:
    path: /docs/cluster-formation
    method: GET
    data_selector: overview
    params: {}
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
    data_selector: overview
    params: {}
- name: hostname_resolution
  endpoint:
    path: /docs/hostname-resolution
    method: GET
    data_selector: overview
    params: {}
- name: ports
  endpoint:
    path: /docs/ports
    method: GET
    data_selector: overview
    params: {}
- name: authentication
  endpoint:
    path: /docs/access-control
    method: GET
    data_selector: overview
    params: {}
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: definitions
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: cluster
  endpoint:
    path: /docs/clustering
    method: GET
    data_selector: nodes
    params: {}
- name: node_names
  endpoint:
    path: /docs/node-names
    method: GET
    data_selector: names
    params: {}
- name: cluster_formation
  endpoint:
    path: /docs/cluster-formation
    method: GET
    data_selector: formation
    params: {}
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: vhosts
  endpoint:
    path: /api/vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /api/users
    method: GET
    data_selector: users
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: cluster_formation
  endpoint:
    path: /docs/clustering
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: definitions
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: virtual_hosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: cluster_status
  endpoint:
    path: /rabbitmqctl/cluster_status
    method: GET
- name: stop_app
  endpoint:
    path: /rabbitmqctl/stop_app
    method: POST
- name: forget_cluster_node
  endpoint:
    path: /rabbitmqctl/forget_cluster_node
    method: POST
- name: reset
  endpoint:
    path: /rabbitmqctl/reset
    method: POST
- name: start_app
  endpoint:
    path: /rabbitmqctl/start_app
    method: POST
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: delete_user_limit
  endpoint:
    path: /delete/user_limit
    method: DELETE
    data_selector: user_limit
- name: declare_queue
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: queue_declaration
- name: vhost_limits
  endpoint:
    path: /vhosts/{vhost}/limits
    method: GET
    data_selector: limits
    params: {}
- name: user_limits
  endpoint:
    path: /users/{user}/limits
    method: GET
    data_selector: limits
    params: {}
- name: quorum_queue
  endpoint:
    path: /queues/events/target.quorum.queue.name
    method: POST
    data_selector: result
    params:
      type: quorum
      durable: true
- name: stream
  endpoint:
    path: /queues/events/target.stream.name
    method: POST
    data_selector: result
    params:
      type: stream
      durable: true
- name: classic_queue
  endpoint:
    path: /queues/events/target.classic.queue.name
    method: POST
    data_selector: result
    params:
      type: classic
      durable: true
      auto_delete: false
- name: list_streams
  endpoint:
    path: /streams/events
    method: GET
    data_selector: streams
    params: {}
- name: stream
  endpoint:
    path: /streams/declare
    method: POST
    data_selector: streams
    params:
      max-age: 3D
- name: queue
  endpoint:
    path: /queues/delete
    method: DELETE
    data_selector: queues
    params: {}
- name: vhost_limit
  endpoint:
    path: /vhosts/{vhost}/limits
    method: GET
    data_selector: limits
    params: {}
- name: quorum_queue
  endpoint:
    path: /queues/events/target.quorum.queue.name
    method: POST
    data_selector: declare
    params:
      type: quorum
      durable: true
- name: stream
  endpoint:
    path: /streams/events.stream
    method: POST
    data_selector: declare
    params:
      max-age: 3D
- name: classic_queue
  endpoint:
    path: /queues/events/target.classic.queue.name
    method: POST
    data_selector: declare
    params:
      type: classic
      durable: true
      auto-delete: false
- name: events.all_types.topic
  endpoint:
    path: /exchanges/events/events.all_types.topic
    method: declare
    data_selector: exchanges
    params:
      type: topic
      durable: true
- name: events.all_type.uncategorized
  endpoint:
    path: /exchanges/events/events.all_type.uncategorized
    method: declare
    data_selector: exchanges
    params:
      type: fanout
      durable: true
      auto-delete: false
- name: local.random.c60bda92
  endpoint:
    path: /exchanges/events/local.random.c60bda92
    method: declare
    data_selector: exchanges
    params:
      type: x-local-random
      durable: true
- name: clear_permissions
  endpoint:
    path: /clear_permissions
    method: POST
    data_selector: vhost
    params: {}
- name: clear_topic_permissions
  endpoint:
    path: /clear_topic_permissions
    method: POST
    data_selector: vhost
    params: {}
- name: list_permissions
  endpoint:
    path: /list_permissions
    method: GET
    data_selector: vhost
    params: {}
- name: list_topic_permissions
  endpoint:
    path: /list_topic_permissions
    method: GET
    data_selector: vhost
    params: {}
- name: list_user_permissions
  endpoint:
    path: /list_user_permissions
    method: GET
    data_selector: username
    params: {}
- name: list_user_topic_permissions
  endpoint:
    path: /list_user_topic_permissions
    method: GET
    data_selector: username
    params: {}
- name: list_vhosts
  endpoint:
    path: /list_vhosts
    method: GET
    data_selector: vhostinfoitem
    params: {}
- name: set_permissions
  endpoint:
    path: /set_permissions
    method: POST
    data_selector: vhost
    params: {}
- name: set_permissions_globally
  endpoint:
    path: /set_permissions_globally
    method: POST
    data_selector: username
    params: {}
- name: set_topic_permissions
  endpoint:
    path: /set_topic_permissions
    method: POST
    data_selector: vhost
    params: {}
- name: quorum_queue
  endpoint:
    path: /queues/events/target.quorum.queue.name
    method: DECLARE
    data_selector: queue
    params:
      type: quorum
      durable: true
- name: stream
  endpoint:
    path: /streams/events.stream
    method: DECLARE
    data_selector: stream
    params:
      max-age: 3D
- name: classic_queue
  endpoint:
    path: /queues/events/target.classic.queue.name
    method: DECLARE
    data_selector: queue
    params:
      type: classic
      durable: true
      auto-delete: false
- name: exchange_topic
  endpoint:
    path: /exchanges/events/events.all_types.topic
    method: DECLARE
    data_selector: exchange
    params:
      type: topic
      durable: true
- name: exchange_fanout
  endpoint:
    path: /exchanges/events/events.all_type.uncategorized
    method: DECLARE
    data_selector: exchange
    params:
      type: fanout
      durable: true
      auto-delete: false
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: list_bindings
  endpoint:
    path: /list_bindings
    method: GET
- name: list_channels
  endpoint:
    path: /list_channels
    method: GET
- name: list_connections
  endpoint:
    path: /list_connections
    method: GET
- name: list_consumers
  endpoint:
    path: /list_consumers
    method: GET
- name: list_exchanges
  endpoint:
    path: /list_exchanges
    method: GET
- name: list_queues
  endpoint:
    path: /list_queues
    method: GET
- name: list_unresponsive_queues
  endpoint:
    path: /list_unresponsive_queues
    method: GET
- name: unresponsive_queues
  endpoint:
    path: list_unresponsive_queues
    method: GET
    data_selector: queues
    params:
      local: true
- name: server_report
  endpoint:
    path: report
    method: GET
    data_selector: report_details
- name: schema_info
  endpoint:
    path: schema_info
    method: GET
    data_selector: schema_tables
- name: broker_status
  endpoint:
    path: status
    method: GET
    data_selector: broker_status_info
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: definitions
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: target_quorum_queue
  endpoint:
    path: /queues/events/target.quorum.queue.name
    method: DECLARE
    data_selector: queue
    params:
      type: quorum
      durable: true
- name: target_stream
  endpoint:
    path: /streams/events.stream
    method: DECLARE
    data_selector: stream
    params:
      max-age: 3D
- name: target_classic_queue
  endpoint:
    path: /queues/events/target.classic.queue.name
    method: DECLARE
    data_selector: queue
    params:
      type: classic
      durable: true
      auto-delete: false
- name: events_exchange
  endpoint:
    path: /exchanges/events/events.all_types.topic
    method: DECLARE
    data_selector: exchange
    params:
      type: topic
      durable: true
- name: local_random_exchange
  endpoint:
    path: /exchanges/events/local.random.c60bda92
    method: DECLARE
    data_selector: exchange
    params:
      type: x-local-random
      durable: true
- name: user_limit
  endpoint:
    path: /user_limits
    method: GET
    data_selector: records
- name: vhost_limit
  endpoint:
    path: /vhost_limits
    method: GET
    data_selector: records
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: records
- name: streams
  endpoint:
    path: /streams
    method: GET
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: records
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: records
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: records
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: records
- name: clear_global_parameter
  endpoint:
    path: /clear_global_parameter
    method: POST
    data_selector: name
- name: clear_parameter
  endpoint:
    path: /clear_parameter
    method: POST
    data_selector: component_name, name
- name: list_global_parameters
  endpoint:
    path: /list_global_parameters
    method: GET
    data_selector: ''
- name: list_parameters
  endpoint:
    path: /list_parameters
    method: GET
    data_selector: ''
- name: set_global_parameter
  endpoint:
    path: /set_global_parameter
    method: POST
    data_selector: name, value
- name: set_parameter
  endpoint:
    path: /set_parameter
    method: POST
    data_selector: component_name, name, value
- name: list_policies
  endpoint:
    path: /list_policies
    method: GET
    data_selector: ''
- name: set_operator_policy
  endpoint:
    path: /set_operator_policy
    method: POST
    data_selector: name, pattern, definition
- name: set_policy
  endpoint:
    path: /set_policy
    method: POST
    data_selector: name, pattern, definition
- name: clear_policy
  endpoint:
    path: /clear_policy
    method: POST
    data_selector: name
- name: clear_operator_policy
  endpoint:
    path: /clear_operator_policy
    method: POST
    data_selector: name
- name: list_operator_policies
  endpoint:
    path: /list_operator_policies
    method: GET
    data_selector: ''
- name: add_vhost
  endpoint:
    path: /add_vhost
    method: POST
    data_selector: vhost, desc, tags, default-q-type
- name: clear_vhost_limits
  endpoint:
    path: /clear_vhost_limits
    method: POST
    data_selector: vhost
- name: delete_vhost
  endpoint:
    path: /delete_vhost
    method: POST
    data_selector: vhost
- name: list_vhost_limits
  endpoint:
    path: /list_vhost_limits
    method: GET
    data_selector: ''
- name: restart_vhost
  endpoint:
    path: /restart_vhost
    method: POST
    data_selector: vhost
- name: set_vhost_limits
  endpoint:
    path: /set_vhost_limits
    method: POST
    data_selector: definition
- name: set_user_limits
  endpoint:
    path: /set_user_limits
    method: POST
    data_selector: username, definition
- name: clear_user_limits
  endpoint:
    path: /clear_user_limits
    method: POST
    data_selector: username, limit
- name: trace_off
  endpoint:
    path: /trace_off
    method: POST
    data_selector: vhost
- name: trace_on
  endpoint:
    path: /trace_on
    method: POST
    data_selector: vhost
- name: decode
  endpoint:
    path: /decode
    method: POST
    data_selector: value, passphrase
- name: encode
  endpoint:
    path: /encode
    method: POST
    data_selector: value, passphrase
- name: set_cluster_name
  endpoint:
    path: /set_cluster_name
    method: POST
    data_selector: name
- name: set_disk_free_limit
  endpoint:
    path: /set_disk_free_limit
    method: POST
    data_selector: disk_limit
- name: set_log_level
  endpoint:
    path: /set_log_level
    method: POST
    data_selector: log_level
- name: set_vm_memory_high_watermark
  endpoint:
    path: /set_vm_memory_high_watermark
    method: POST
    data_selector: fraction, memory_limit
- name: enable_feature_flag
  endpoint:
    path: /enable_feature_flag
    method: POST
    data_selector: feature_flag
- name: list_feature_flags
  endpoint:
    path: /list_feature_flags
    method: GET
    data_selector: ''
- name: close_all_connections
  endpoint:
    path: /close_all_connections
    method: POST
    data_selector: vhost, explanation
- name: close_connection
  endpoint:
    path: /close_connection
    method: POST
    data_selector: connectionpid, explanation
- name: delete_queue
  endpoint:
    path: /delete_queue
    method: POST
    data_selector: queue_name
- name: purge_queue
  endpoint:
    path: /purge_queue
    method: POST
    data_selector: queue
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: streams
  endpoint:
    path: /streams
    method: GET
    data_selector: streams
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: streams
  endpoint:
    path: /streams
    method: GET
    data_selector: streams
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: shovel_status
  endpoint:
    path: /shovel_status
    method: GET
    data_selector: configured_shovels
- name: delete_shovel
  endpoint:
    path: /delete_shovel
    method: POST
    data_selector: deleted_shovel
- name: federation_status
  endpoint:
    path: /federation_status
    method: GET
    data_selector: federation_links
- name: restart_federation_link
  endpoint:
    path: /restart_federation_link
    method: POST
    data_selector: restarted_federation_link
- name: list_amqp10_connections
  endpoint:
    path: /list_amqp10_connections
    method: GET
    data_selector: amqp10_connections
- name: list_mqtt_connections
  endpoint:
    path: /list_mqtt_connections
    method: GET
    data_selector: mqtt_connections
- name: list_stomp_connections
  endpoint:
    path: /list_stomp_connections
    method: GET
    data_selector: stomp_connections
- name: reset_stats_db
  endpoint:
    path: /reset_stats_db
    method: POST
    data_selector: reset_stats
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: GET
    data_selector: list
- name: deprecated_features
  endpoint:
    path: /deprecated_features
    method: GET
    data_selector: list_used
- name: definitions_export_stdout
  endpoint:
    path: /definitions/export
    method: GET
    data_selector: stdout
- name: definitions_export_file
  endpoint:
    path: /definitions/export
    method: GET
    data_selector: file
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: definitions
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: churn
  endpoint:
    path: /show/churn
    method: GET
    data_selector: churn_metrics
- name: cluster_nodes
  endpoint:
    path: /nodes
    method: GET
    data_selector: nodes_list
- name: virtual_hosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts_list
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users_list
- name: queues
  endpoint:
    path: /queues
    method: declare
    data_selector: records
    params:
      vhost: events
- name: streams
  endpoint:
    path: /streams
    method: declare
    data_selector: records
    params:
      vhost: events
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    data_selector: records
    params:
      vhost: events
- name: connections
  endpoint:
    path: /connections
    method: list
    data_selector: records
    params:
      vhost: events
- name: channels
  endpoint:
    path: /channels
    method: list
    data_selector: records
    params:
      vhost: events
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: list
    data_selector: records
- name: deprecated_features
  endpoint:
    path: /deprecated_features
    method: list
    data_selector: records
- name: definitions
  endpoint:
    path: /definitions
    method: export
    data_selector: records
- name: shovels
  endpoint:
    path: /shovels
    method: GET
    data_selector: shovels
    params: {}
- name: federation_upstream
  endpoint:
    path: /federation/upstreams
    method: POST
    data_selector: upstreams
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
- name: users
  endpoint:
    path: /users
    method: GET
- name: queues
  endpoint:
    path: /queues
    method: GET
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
- name: queues
  endpoint:
    path: /queues
    method: declare
    data_selector: queues
    params:
      vhost: events
      name: target.quorum.queue.name
      type: quorum
      durable: true
- name: streams
  endpoint:
    path: /streams
    method: declare
    data_selector: streams
    params:
      vhost: events
      name: events.stream
      max-age: 3D
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    data_selector: exchanges
    params:
      vhost: events
      name: events.all_types.topic
      type: topic
      durable: true
- name: federation_upstreams
  endpoint:
    path: /federation/upstream
    method: declare
    data_selector: federation_upstreams
    params:
      vhost: local-vhost
      name: pollux
      uri: amqp://pollux.eng.megacorp.local:5672/remote-vhost
      ack-mode: on-publish
      prefetch-count: 2000
      exchange-name: overridden.name
      queue-type: quorum
      bind-using-nowait: true
- name: virtual_hosts
  endpoint:
    path: /vhosts
    method: GET
- name: users
  endpoint:
    path: /users
    method: GET
- name: queues
  endpoint:
    path: /queues
    method: GET
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: virtual_hosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: streams
  endpoint:
    path: /api/streams
    method: GET
    data_selector: streams
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
- name: channels
  endpoint:
    path: /api/channels
    method: GET
    data_selector: channels
- name: feature_flags
  endpoint:
    path: /api/feature_flags
    method: GET
    data_selector: feature_flags
- name: health_checks
  endpoint:
    path: /api/health_checks
    method: GET
    data_selector: health_checks
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: records
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: records
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: records
    params: {}
- name: virtual_hosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: '[]'
- name: streams
  endpoint:
    path: /api/streams
    method: GET
    data_selector: '[]'
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: '[]'
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: '[]'
- name: channels
  endpoint:
    path: /api/channels
    method: GET
    data_selector: '[]'
- name: users
  endpoint:
    path: /api/users
    method: GET
    data_selector: '[]'
- name: policies
  endpoint:
    path: /policies
    method: GET
    data_selector: policies
    params: {}
- name: user_limit
  endpoint:
    path: /delete/user_limit
    method: DELETE
    data_selector: user_limit
    params:
      user: a-user
      name: max-connections
- name: queue_declaration
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: queue_declaration
    params:
      vhost: events
      name: target.quorum.queue.name
      type: quorum
      durable: true
- name: stream_queue_declaration
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: stream_queue_declaration
    params:
      vhost: events
      name: target.stream.name
      type: stream
      durable: true
- name: classic_queue_declaration
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: classic_queue_declaration
    params:
      vhost: events
      name: target.classic.queue.name
      type: classic
      durable: true
      auto-delete: false
- name: queues
  endpoint:
    path: /queues
    method: declare
    params:
      type: quorum
      durable: true
- name: streams
  endpoint:
    path: /streams
    method: declare
    params:
      max-age: 3D
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    params:
      type: topic
      durable: true
- name: federation_upstreams
  endpoint:
    path: /federation/upstreams
    method: declare
    params:
      ack-mode: on-publish
      prefetch-count: 2000
      queue-type: quorum
      bind-using-nowait: true
- name: target_quorum_queue
  endpoint:
    path: /vhosts/events/queues/target.quorum.queue.name
    method: POST
    data_selector: result
    params:
      type: quorum
      durable: true
- name: target_stream
  endpoint:
    path: /vhosts/events/streams/target.stream.name
    method: POST
    data_selector: result
    params:
      type: stream
      durable: true
- name: target_classic_queue
  endpoint:
    path: /vhosts/events/queues/target.classic.queue.name
    method: POST
    data_selector: result
    params:
      type: classic
      durable: true
      auto_delete: false
- name: list_streams
  endpoint:
    path: /vhosts/events/streams
    method: GET
    data_selector: streams
    params: {}
- name: policies_list
  endpoint:
    path: /policies/list
    method: GET
    data_selector: policies
    params: {}
- name: policies_list_in_virtual_host
  endpoint:
    path: /policies/list_in
    method: GET
    data_selector: policies
    params:
      vhost: events
- name: stream
  endpoint:
    path: /streams/events.stream
    method: declare
    data_selector: max-age
    params:
      max-age: 3D
- name: queue
  endpoint:
    path: /queues/target.queue.name
    method: delete
    data_selector: none
    params: {}
- name: queue_policy
  endpoint:
    path: /policies
    method: POST
    data_selector: policies
    params:
      priority: 1
- name: vhost_limit
  endpoint:
    path: /vhosts/{vhost}/limits
    method: GET
    data_selector: limits
- name: user_limit
  endpoint:
    path: /users/{user}/limits
    method: GET
    data_selector: limits
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: declare_quorum_queue
  endpoint:
    path: /queues/events/target.quorum.queue.name
    method: POST
    data_selector: result
    params:
      type: quorum
      durable: true
- name: declare_stream
  endpoint:
    path: /streams/events.stream
    method: POST
    data_selector: result
    params:
      max-age: 3D
- name: purge_queue
  endpoint:
    path: /queues/events/target.queue.name/purge
    method: POST
    data_selector: result
    params: {}
- name: delete_queue
  endpoint:
    path: /queues/events/target.queue.name
    method: DELETE
    data_selector: result
    params:
      idempotently: true
- name: queues
  endpoint:
    path: /queues
    method: declare
    data_selector: queue
    params:
      type: quorum
      durable: true
- name: streams
  endpoint:
    path: /streams
    method: declare
    data_selector: stream
    params:
      max-age: 3D
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    data_selector: exchange
    params:
      type: topic
      durable: true
- name: policies_list
  endpoint:
    path: /policies/list
    method: GET
- name: policies_declare
  endpoint:
    path: /policies/declare
    method: POST
- name: target_quorum_queue
  endpoint:
    path: /queues/events/target.quorum.queue.name
    method: declare
    data_selector: queue
    params:
      type: quorum
      durable: true
- name: target_stream
  endpoint:
    path: /streams/events/target.stream.name
    method: declare
    data_selector: stream
    params:
      type: stream
      durable: true
- name: target_classic_queue
  endpoint:
    path: /queues/events/target.classic.queue.name
    method: declare
    data_selector: queue
    params:
      type: classic
      durable: true
      auto_delete: false
- name: events_stream
  endpoint:
    path: /streams/events/events.stream
    method: declare
    data_selector: stream
    params:
      max_age: 3D
- name: purge_target_queue
  endpoint:
    path: /queues/events/target.queue.name
    method: purge
    data_selector: queue
- name: delete_target_queue
  endpoint:
    path: /queues/events/target.queue.name
    method: delete
    data_selector: queue
    params:
      idempotently: true
- name: events_all_types_exchange
  endpoint:
    path: /exchanges/events/events.all_types.topic
    method: declare
    data_selector: exchange
    params:
      type: topic
      durable: true
- name: events_all_type_uncategorized_exchange
  endpoint:
    path: /exchanges/events/events.all_type.uncategorized
    method: declare
    data_selector: exchange
    params:
      type: fanout
      durable: true
      auto_delete: false
- name: local_random_exchange
  endpoint:
    path: /exchanges/events/local.random.c60bda92
    method: declare
    data_selector: exchange
    params:
      type: x-local-random
      durable: true
- name: delete_target_exchange
  endpoint:
    path: /exchanges/events/target.exchange.name
    method: delete
    data_selector: exchange
    params:
      idempotently: true
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: records
- name: streams
  endpoint:
    path: /streams
    method: GET
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: records
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: records
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: records
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: GET
    data_selector: records
- name: deprecated_features
  endpoint:
    path: /deprecated_features
    method: GET
    data_selector: records
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: records
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: policies_list
  endpoint:
    path: /policies/list
    method: GET
    data_selector: policies
    params: {}
- name: policies_list_in
  endpoint:
    path: /policies/list_in
    method: GET
    data_selector: policies
    params:
      vhost: events
- name: create_policy
  endpoint:
    path: /policies/declare
    method: POST
    data_selector: policy
    params:
      vhost: events
      name: ha-all
      pattern: .*
      definition: '{"ha-mode":"all","ha-sync-mode":"automatic"}'
      priority: 1
- name: delete_policy
  endpoint:
    path: /policies/delete
    method: DELETE
    data_selector: policy
    params:
      vhost: events
      name: ha-all
- name: list_matching_object
  endpoint:
    path: /policies/list_matching_object
    method: GET
    data_selector: policies
    params:
      vhost: events
      name: my.queue
      type: queue
- name: queues
  endpoint:
    path: /queues
    method: DECLARE
    data_selector: records
- name: streams
  endpoint:
    path: /streams
    method: DECLARE
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: DECLARE
    data_selector: records
- name: connections
  endpoint:
    path: /connections
    method: LIST
    data_selector: records
- name: vhost_limit
  endpoint:
    path: /api/vhost_limits
    method: GET
    data_selector: limits
    params: {}
- name: user_limit
  endpoint:
    path: /api/user_limits
    method: GET
    data_selector: limits
    params: {}
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: queues
  endpoint:
    path: queues
    method: declare
    data_selector: name
    params:
      type: quorum
      durable: true
- name: streams
  endpoint:
    path: streams
    method: declare
    data_selector: name
    params:
      max-age: 3D
- name: exchanges
  endpoint:
    path: exchanges
    method: declare
    data_selector: name
    params:
      type: topic
      durable: true
- name: queues
  endpoint:
    path: /queues
    method: DECLARE
    data_selector: records
- name: streams
  endpoint:
    path: /streams
    method: DECLARE
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: DECLARE
    data_selector: records
- name: policies
  endpoint:
    path: /policies
    method: GET
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
- name: users
  endpoint:
    path: /users
    method: GET
- name: queues
  endpoint:
    path: /queues
    method: GET
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
- name: queues
  endpoint:
    path: /queues
    method: declare
    data_selector: queues
    params:
      vhost: events
      name: target.quorum.queue.name
      type: quorum
      durable: true
- name: streams
  endpoint:
    path: /streams
    method: declare
    data_selector: streams
    params:
      vhost: events
      name: events.stream
      max-age: 3D
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    data_selector: exchanges
    params:
      vhost: events
      name: events.all_types.topic
      type: topic
      durable: true
- name: policies
  endpoint:
    path: /policies
    method: GET
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: GET
    data_selector: list
    params: {}
- name: deprecated_features
  endpoint:
    path: /deprecated_features
    method: GET
    data_selector: list_used
    params: {}
- name: definitions_export_stdout
  endpoint:
    path: /definitions/export
    method: GET
    data_selector: export_stdout
    params:
      output: stdout
- name: definitions_export_file
  endpoint:
    path: /definitions/export
    method: GET
    data_selector: export_file
    params:
      output: file
      file_path: /path/to/definitions.file.json
- name: operator_policy
  endpoint:
    path: /operator_policies
    method: DELETE
    data_selector: null
    params:
      vhost: events
      name: queue.max-length
- name: runtime_parameters
  endpoint:
    path: /parameters
    method: GET
    data_selector: null
    params:
      list_all: true
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: streams
  endpoint:
    path: /streams
    method: GET
    data_selector: streams
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: queues
  endpoint:
    path: /queues
    method: DECLARE
    data_selector: records
- name: streams
  endpoint:
    path: /streams
    method: DECLARE
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: DECLARE
    data_selector: records
- name: connections
  endpoint:
    path: /connections
    method: LIST
    data_selector: records
- name: channels
  endpoint:
    path: /channels
    method: LIST
    data_selector: records
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: LIST
    data_selector: records
- name: deprecated_features
  endpoint:
    path: /deprecated_features
    method: LIST
    data_selector: records
- name: definitions
  endpoint:
    path: /definitions
    method: EXPORT
    data_selector: records
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: streams
  endpoint:
    path: /streams
    method: GET
    data_selector: streams
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
- name: shovels
  endpoint:
    path: /shovels
    method: GET
    data_selector: shovels
- name: federation
  endpoint:
    path: /federation
    method: GET
    data_selector: federation
- name: policies
  endpoint:
    path: /policies
    method: GET
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
- name: runtime_parameters
  endpoint:
    path: /parameters
    method: GET
- name: local
  endpoint:
    path: /local
    method: GET
- name: staging
  endpoint:
    path: /staging
    method: GET
- name: production
  endpoint:
    path: /production
    method: GET
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: records
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: records
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: records
- name: declare_queue
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: queue
    params:
      vhost: events
      name: target.quorum.queue.name
      type: quorum
      durable: true
- name: declare_stream
  endpoint:
    path: /streams/declare
    method: POST
    data_selector: stream
    params:
      vhost: events
      name: events.stream
      max-age: 3D
- name: declare_exchange
  endpoint:
    path: /exchanges/declare
    method: POST
    data_selector: exchange
    params:
      vhost: events
      name: events.all_types.topic
      type: topic
      durable: true
- name: delete_queue
  endpoint:
    path: /queues/delete
    method: DELETE
    data_selector: queue
    params:
      vhost: events
      name: target.queue.name
      idempotently: true
- name: delete_exchange
  endpoint:
    path: /exchanges/delete
    method: DELETE
    data_selector: exchange
    params:
      vhost: events
      name: target.exchange.name
      idempotently: true
- name: declare_amqp091_shovel
  endpoint:
    path: /shovels/declare_amqp091
    method: POST
    data_selector: shovel
    params:
      name: my-amqp091-shovel
      source-uri: amqp://username:s3KrE7@source.hostname:5672
      destination-uri: amqp://username:s3KrE7@source.hostname:5672
      ack-mode: on-confirm
      source-queue: src.queue
      destination-queue: dest.queue
      predeclared-source: false
      predeclared-destination: false
- name: declare_amqp10_shovel
  endpoint:
    path: /shovels/declare_amqp10
    method: POST
    data_selector: shovel
    params:
      name: my-amqp1.0-shovel
      source-uri: amqp://username:s3KrE7@source.hostname:5672?hostname=vhost:src-vhost
      destination-uri: amqp://username:s3KrE7@source.hostname:5672?hostname=vhost:dest-vhost
      ack-mode: on-confirm
      source-address: /queues/src.queue
      destination-address: /queues/dest.queue
- name: list_shovels
  endpoint:
    path: /shovels/list_all
    method: GET
    data_selector: shovels
- name: delete_shovel
  endpoint:
    path: /shovels/delete
    method: DELETE
    data_selector: shovel
    params:
      name: my-amqp091-shovel
- name: create_federation_upstream_exchanges
  endpoint:
    path: /federation/declare_upstream_for_exchanges
    method: POST
    data_selector: upstream
    params:
      name: pollux
      uri: amqp://pollux.eng.megacorp.local:5672/remote-vhost
      ack-mode: on-publish
      prefetch-count: 2000
      exchange-name: overridden.name
      queue-type: quorum
      bind-using-nowait: true
- name: create_federation_upstream_queues
  endpoint:
    path: /federation/declare_upstream_for_queues
    method: POST
    data_selector: upstream
    params:
      name: clusters.sirius
      uri: amqp://sirius.eng.megacorp.local:5672/remote-vhost
      ack-mode: on-publish
      prefetch-count: 2000
      queue-name: overridden.name
      consumer-tag: overriden.ctag
- name: create_universal_federation_upstream
  endpoint:
    path: /federation/declare_upstream
    method: POST
    data_selector: upstream
    params:
      name: pollux
      uri: amqp://pollux.eng.megacorp.local:5672/remote-vhost
      ack-mode: on-publish
      prefetch-count: 2000
      queue-name: overridden.name
      consumer-tag: overriden.ctag
      exchange-name: overridden.name
      queue-type: quorum
      bind-using-nowait: true
- name: list_federation_links
  endpoint:
    path: /federation/list_all_links
    method: GET
    data_selector: links
- name: rebalance_queue_leaders
  endpoint:
    path: /rebalance/queues
    method: POST
    data_selector: rebalance
- name: policies
  endpoint:
    path: /policies
    method: GET
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
- name: parameters
  endpoint:
    path: /parameters
    method: GET
- name: global_parameters
  endpoint:
    path: /global_parameters
    method: GET
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: relative_memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
- name: queues
  endpoint:
    path: /queues
    method: declare
    data_selector: records
- name: streams
  endpoint:
    path: /streams
    method: declare
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    data_selector: records
- name: connections
  endpoint:
    path: /connections
    method: list
    data_selector: records
- name: channels
  endpoint:
    path: /channels
    method: list
    data_selector: records
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: list
    data_selector: records
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
    params: {}
- name: relative_memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
    params: {}
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: relative_memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: memory_breakdown_in_percent
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
- name: memory_breakdown_in_bytes
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: records
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: records
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: records
    params: {}
- name: definitions
  endpoint:
    path: /definitions
    method: GET
    data_selector: records
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: records
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: records
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: records
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: records
    params: {}
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: streams
  endpoint:
    path: /api/streams
    method: GET
    data_selector: streams
    params: {}
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
    params: {}
- name: channels
  endpoint:
    path: /api/channels
    method: GET
    data_selector: channels
    params: {}
- name: policies
  endpoint:
    path: /policies/list
    method: GET
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
    params: {}
- name: channels
  endpoint:
    path: /channels
    method: GET
    data_selector: channels
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
    params: {}
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
    params: {}
- name: queues
  endpoint:
    path: /queues
    method: declare
    data_selector: queues
    params:
      name: target.quorum.queue.name
      type: quorum
      durable: true
- name: streams
  endpoint:
    path: /streams
    method: list
    data_selector: streams
    params: {}
- name: exchanges
  endpoint:
    path: /exchanges
    method: declare
    data_selector: exchanges
    params:
      name: events.all_types.topic
      type: topic
      durable: true
- name: feature_flags
  endpoint:
    path: /feature_flags
    method: list
    data_selector: feature_flags
    params: {}
- name: commands
  endpoint:
    path: /commands
    method: GET
    data_selector: commands
- name: metrics
  endpoint:
    path: /metrics
    method: GET
    data_selector: metrics
    params: {}
- name: memory_breakdown
  endpoint:
    path: /metrics/memory-breakdown
    method: GET
- name: per_object_metrics
  endpoint:
    path: /metrics/per-object
    method: GET
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
    params: {}
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
    params: {}
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
    params: {}
- name: channels
  endpoint:
    path: /api/channels
    method: GET
    data_selector: channels
    params: {}
- name: feature_flags
  endpoint:
    path: /api/feature_flags
    method: GET
    data_selector: feature_flags
    params: {}
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
    params: {}
- name: detailed_metrics
  endpoint:
    path: /metrics/detailed
    method: GET
    data_selector: metrics
    params: {}
- name: policies_list
  endpoint:
    path: /policies/list
    method: GET
- name: policies_list_in
  endpoint:
    path: /policies/list_in
    method: GET
    params:
      vhost: events
- name: policies_declare_ha
  endpoint:
    path: /policies/declare
    method: POST
    params:
      vhost: events
      name: ha-all
      pattern: .*
      definition: '{"ha-mode":"all","ha-sync-mode":"automatic"}'
      priority: 1
- name: policies_declare_temp
  endpoint:
    path: /policies/declare
    method: POST
    params:
      vhost: events
      name: temp-queues
      pattern: temp\..*
      definition: '{"message-ttl":300000,"expires":600000}'
      priority: 2
- name: rabbitmq_cluster_vhost_status
  endpoint:
    path: /rabbitmq/vhosts/status
    method: GET
    data_selector: status
- name: rabbitmq_cluster_exchange_name
  endpoint:
    path: /rabbitmq/exchanges
    method: GET
    data_selector: exchanges
- name: rabbitmq_cluster_exchange_bindings
  endpoint:
    path: /rabbitmq/exchanges/bindings
    method: GET
    data_selector: bindings
- name: rabbitmq_detailed_stream_consumer_max_offset_lag
  endpoint:
    path: /rabbitmq/stream/consumer/max_offset_lag
    method: GET
    data_selector: max_offset_lag
- name: quorum_queues
  endpoint:
    path: /docs/quorum-queues
    method: GET
- name: streams
  endpoint:
    path: /docs/streams
    method: GET
- name: classic_queues
  endpoint:
    path: /docs/classic-queues
    method: GET
- name: queues
  endpoint:
    path: /api/queues
    method: GET
    data_selector: queues
- name: streams
  endpoint:
    path: /api/streams
    method: GET
    data_selector: streams
- name: exchanges
  endpoint:
    path: /api/exchanges
    method: GET
    data_selector: exchanges
- name: connections
  endpoint:
    path: /api/connections
    method: GET
    data_selector: connections
- name: channels
  endpoint:
    path: /api/channels
    method: GET
    data_selector: channels
- name: feature_flags
  endpoint:
    path: /api/feature_flags
    method: GET
    data_selector: feature_flags
- name: deprecated_features
  endpoint:
    path: /api/deprecated_features
    method: GET
    data_selector: deprecated_features
- name: definitions
  endpoint:
    path: /api/definitions
    method: GET
    data_selector: definitions
- name: list_policies
  endpoint:
    path: /policies/list
    method: GET
- name: create_policy
  endpoint:
    path: /policies/declare
    method: POST
- name: delete_policy
  endpoint:
    path: /policies/delete
    method: DELETE
- name: list_matching_object
  endpoint:
    path: /policies/list_matching_object
    method: GET
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
    data_selector: policies
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: connections
- name: declare_quorum_queue
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: result
    params:
      name: target.quorum.queue.name
      type: quorum
      durable: true
- name: declare_stream
  endpoint:
    path: /streams/declare
    method: POST
    data_selector: result
    params:
      name: events.stream
      max-age: 3D
- name: declare_classic_queue
  endpoint:
    path: /queues/declare
    method: POST
    data_selector: result
    params:
      name: target.classic.queue.name
      type: classic
      durable: true
      auto-delete: false
- name: declare_exchange
  endpoint:
    path: /exchanges/declare
    method: POST
    data_selector: result
    params:
      name: events.all_types.topic
      type: topic
      durable: true
- name: declare_fanout_exchange
  endpoint:
    path: /exchanges/declare
    method: POST
    data_selector: result
    params:
      name: events.all_type.uncategorized
      type: fanout
      durable: true
      auto-delete: false
- name: declare_local_random_exchange
  endpoint:
    path: /exchanges/declare
    method: POST
    data_selector: result
    params:
      name: local.random.c60bda92
      type: x-local-random
      durable: true
- name: show_memory_breakdown_in_bytes
  endpoint:
    path: /memory_breakdown_in_bytes
    method: GET
    data_selector: result
- name: show_memory_breakdown_in_percent
  endpoint:
    path: /memory_breakdown_in_percent
    method: GET
    data_selector: result
- name: list_feature_flags
  endpoint:
    path: /feature_flags/list
    method: GET
    data_selector: result
- name: enable_feature_flag
  endpoint:
    path: /feature_flags/enable
    method: POST
    data_selector: result
    params:
      flag: rabbitmq_4.0.0
- name: enable_all_stable_feature_flags
  endpoint:
    path: /feature_flags/enable_all
    method: POST
    data_selector: result
- name: list_deprecated_features
  endpoint:
    path: /deprecated_features/list
    method: GET
    data_selector: result
- name: export_definitions_stdout
  endpoint:
    path: /definitions/export
    method: GET
    data_selector: result
    params:
      output: stdout
- name: import_definition
  endpoint:
    path: /definitions/import
    method: POST
    data_selector: result
- name: password_hashing
  endpoint:
    path: /passwords/salt_and_hash
    method: POST
    data_selector: ''
    params:
      hashing_algorithm: SHA512
- name: list_policies
  endpoint:
    path: /policies/list
    method: GET
    data_selector: ''
    params: {}
- name: list_policies_specific_vhost
  endpoint:
    path: /policies/list_in
    method: GET
    data_selector: ''
    params:
      vhost: events
- name: create_policy
  endpoint:
    path: /policies/declare
    method: POST
    data_selector: ''
    params:
      vhost: events
      name: ha-all
      pattern: .*
      definition: '{"ha-mode":"all","ha-sync-mode":"automatic"}'
      priority: 1
- name: create_ttl_policy
  endpoint:
    path: /policies/declare
    method: POST
    data_selector: ''
    params:
      vhost: events
      name: temp-queues
      pattern: temp\..*
      definition: '{"message-ttl":300000,"expires":600000}'
      priority: 2
- name: delete_policy
  endpoint:
    path: /policies/delete
    method: DELETE
    data_selector: ''
    params:
      vhost: events
      name: ha-all
- name: list_matching_policies
  endpoint:
    path: /policies/list_matching_object
    method: GET
    data_selector: ''
    params:
      vhost: events
      name: my.queue
      type: queue
- name: list_operator_policies
  endpoint:
    path: /operator_policies/list
    method: GET
    data_selector: ''
    params: {}
- name: list_operator_policies_specific_vhost
  endpoint:
    path: /operator_policies/list_in
    method: GET
    data_selector: ''
    params:
      vhost: events
- name: kubernetes_peer_discovery
  endpoint:
    path: /rabbitmq/discovery/{prefix}/clusters/{cluster name}/nodes/{node name}
    method: GET
    data_selector: nodes
    params: {}
- name: consul_peer_discovery
  endpoint:
    path: /rabbitmq/discovery/{prefix}/clusters/{cluster name}/nodes/{node name}
    method: GET
    data_selector: nodes
    params: {}
- name: etcd_peer_discovery
  endpoint:
    path: /rabbitmq/discovery/{prefix}/clusters/{cluster name}/nodes/{node name}
    method: GET
    data_selector: nodes
    params: {}
- name: key_leases
  endpoint:
    path: /rabbitmq/locks/{prefix}/clusters/{cluster name}/registration
    method: GET
    data_selector: keys
    params: {}
- name: node_registration
  endpoint:
    path: /rabbitmq/discovery/rabbitmq/clusters/default/nodes/rabbit@hostname1
    method: GET
    data_selector: nodes
    params: {}
- name: policies_list
  endpoint:
    path: /policies/list
    method: GET
- name: policies_list_in
  endpoint:
    path: /policies/list_in
    method: GET
    params:
      vhost: events
- name: policies_declare
  endpoint:
    path: /policies/declare
    method: POST
    params:
      vhost: events
- name: policies_delete
  endpoint:
    path: /policies/delete
    method: DELETE
    params:
      vhost: events
- name: policies_list_matching_object
  endpoint:
    path: /policies/list_matching_object
    method: GET
    params:
      vhost: events
- name: operator_policies_list
  endpoint:
    path: /operator_policies/list
    method: GET
- name: operator_policies_list_in
  endpoint:
    path: /operator_policies/list_in
    method: GET
    params:
      vhost: events
- name: operator_policies_declare
  endpoint:
    path: /operator_policies/declare
    method: POST
    params:
      vhost: events
- name: peer_discovery
  endpoint:
    params:
      cluster_formation.peer_discovery_backend: classic_config
- name: dns
  endpoint:
    params:
      cluster_formation.peer_discovery_backend: dns
      cluster_formation.dns.hostname: discovery.eng.example.local
- name: aws
  endpoint:
    params:
      cluster_formation.peer_discovery_backend: aws
      cluster_formation.aws.region: us-east-1
      cluster_formation.aws.access_key_id: ANIDEXAMPLE
      cluster_formation.aws.secret_key: WjalrxuTnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY
- name: peer_discovery
  endpoint:
    path: /rabbitmq/discovery
    method: GET
    data_selector: nodes
- name: operator_policy
  endpoint:
    path: /operator_policies
    method: DELETE
    data_selector: operator_policies
    params:
      name: queue.max-length
- name: runtime_parameters
  endpoint:
    path: /parameters
    method: GET
    data_selector: parameters
    params: {}
- name: cluster_name
  endpoint:
    path: /cluster_formation/etcd/cluster_name
    method: GET
    data_selector: value
- name: node_ttl
  endpoint:
    path: /cluster_formation/etcd/node_ttl
    method: GET
    data_selector: value
- name: lock_timeout
  endpoint:
    path: /cluster_formation/etcd/lock_timeout
    method: GET
    data_selector: value
- name: only_log_warning
  endpoint:
    path: /cluster_formation/node_cleanup/only_log_warning
    method: GET
    data_selector: value
- name: cleanup_interval
  endpoint:
    path: /cluster_formation/node_cleanup/interval
    method: GET
    data_selector: value
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: vhosts
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: users
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: queues
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: exchanges
- name: bindings
  endpoint:
    path: /bindings
    method: GET
    data_selector: bindings
- name: policies
  endpoint:
    path: /policies
    method: GET
    data_selector: list
    params: {}
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
    data_selector: list
    params: {}
- name: runtime_parameters
  endpoint:
    path: /parameters
    method: GET
    data_selector: list
    params: {}
- name: connections
  endpoint:
    path: /connections
    method: GET
    data_selector: records
- name: queues
  endpoint:
    path: /queues
    method: GET
    data_selector: records
- name: exchanges
  endpoint:
    path: /exchanges
    method: GET
    data_selector: records
- name: vhosts
  endpoint:
    path: /vhosts
    method: GET
    data_selector: records
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: records
- name: policies
  endpoint:
    path: /policies
    method: GET
    data_selector: policies
- name: operator_policies
  endpoint:
    path: /operator_policies
    method: GET
    data_selector: operator_policies
- name: parameters
  endpoint:
    path: /parameters
    method: GET
    data_selector: parameters
- name: global_parameters
  endpoint:
    path: /global_parameters
    method: GET
    data_selector: global_parameters
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
- name: relative_memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
- name: relative_memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
    params: {}
- name: relative_memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
    params: {}
- name: memory_breakdown
  endpoint:
    path: /api/nodes/{node}/memory
    method: GET
    data_selector: memory
    params: {}
- name: memory_breakdown_percent
  endpoint:
    path: /api/nodes/{node}/memory/relative
    method: GET
    data_selector: memory
    params: {}
- name: metrics
  endpoint:
    path: /metrics
    method: GET
    data_selector: ''
    params: {}
- name: metrics
  endpoint:
    path: /metrics
    method: GET
    data_selector: ''
- name: metrics
  endpoint:
    path: /metrics
    method: GET
    data_selector: aggregated
- name: memory_breakdown
  endpoint:
    path: /metrics/memory-breakdown
    method: GET
- name: per_object_metrics
  endpoint:
    path: /metrics/per-object
    method: GET
- name: detailed_metrics
  endpoint:
    path: /metrics/detailed
    method: GET
    data_selector: metrics
    params: {}
- name: rabbitmq_cluster_vhost_status
  endpoint:
    path: /path/to/cluster/vhost/status
    method: GET
    data_selector: status
- name: rabbitmq_cluster_exchange_name
  endpoint:
    path: /path/to/cluster/exchange/name
    method: GET
    data_selector: exchange_names
- name: rabbitmq_cluster_exchange_bindings
  endpoint:
    path: /path/to/cluster/exchange/bindings
    method: GET
    data_selector: exchange_bindings
- name: rabbitmq_detailed_stream_consumer_max_offset_lag
  endpoint:
    path: /path/to/detailed/stream/consumer/max/offset/lag
    method: GET
    data_selector: stream_consumer_metrics
- name: prometheus_timeout
  endpoint:
    path: /prometheus/timeout
    method: GET
    data_selector: timeouts
    params: {}
- name: quorum_queues
  endpoint:
    path: /docs/quorum-queues
    method: GET
- name: streams
  endpoint:
    path: /docs/streams
    method: GET
- name: classic_queues
  endpoint:
    path: /docs/classic-queues
    method: GET
- name: etcd
  endpoint:
    path: /rabbitmq/discovery/{prefix}/clusters/{cluster name}/nodes/{node name}
    method: GET
    data_selector: nodes
- name: registration_lock_keys
  endpoint:
    path: /rabbitmq/locks/{prefix}/clusters/{cluster name}/registration
    method: GET
- name: node_registration
  endpoint:
    path: /rabbitmq/discovery/rabbitmq/clusters/default/nodes/rabbit@hostname1
    method: GET
- name: peer_discovery
  endpoint:
    path: /docs/cluster-formation
    method: GET
    data_selector: peer_discovery
    params: {}
- name: endpoints
  endpoint:
    path: /cluster_formation/etcd/endpoints
    method: GET
- name: nodes
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: partitions
notes:
- Default user is 'guest' and can only connect from localhost.
- Automatic recovery is enabled by default.
- Using Pull API is highly discouraged.
- Default username is 'guest' and password is 'guest'
- User 'guest' can only connect from localhost by default
- Tokens expire and the broker will refuse operations on connections with expired
  tokens.
- These tutorials cover the basics of creating messaging applications using RabbitMQ.
- Make sure to use HTTPS for the token endpoint URI in production.
- The DefaultCredentialsRefreshService schedules a refresh after 80% of the token
  validity time.
- Commercial RabbitMQ includes both 24/7 support and features not available in the
  open source version.
- RabbitMQ is free and open source software.
- RabbitMQ is widely used for decoupling services and real-time data processing.
- Extended support lifecycle with critical patches and CVE fixes for more release
  series.
- 247 support from the team that builds and maintains RabbitMQ.
- You need to have the RabbitMQ server installed to go through the tutorials.
- You are currently viewing the documentation for RabbitMQ 4.1.4.
- Documentation for RabbitMQ 3.13.7 is no longer actively maintained.
- VMware Tanzu RabbitMQ includes features and support beyond the open source edition.
- RabbitMQ is a message broker that accepts and forwards messages.
- The queue must be declared before sending messages.
- RabbitMQ requires installation and running on localhost.
- RabbitMQ requires default port 5672.
- Check broker log for resource alarms if sending fails.
- RabbitMQ does not require authentication for localhost connections.
- Ensure RabbitMQ is installed and running on localhost:5672.
- Assumes RabbitMQ is installed and running on localhost on the standard port (5672).
- The connection settings may require adjusting for different hosts or ports.
- Messages are stored in queues, which are bound by the host's memory and disk limits.
- Requires RabbitMQ to be installed and running on localhost:5672
- High connection churn may occur in PHP applications
- Ensure RabbitMQ is installed and running on localhost.
- The tutorial assumes RabbitMQ is installed and running on localhost on the standard
  port (5672).
- RabbitMQ uses AMQP protocol for messaging.
- Ensure that RabbitMQ is installed and running on localhost.
- RabbitMQ accepts and forwards messages.
- Requires RabbitMQ server to be running on localhost at port 5672
- The queue name 'hello' must be declared before publishing messages
- RabbitMQ is a message broker.
- Producer sends messages, consumer receives messages.
- Message durability options let the tasks survive even if RabbitMQ is restarted.
- RabbitMQ uses AMQP 0-9-1 protocol.
- Queue must be declared as durable to ensure messages are not lost.
- Messages should be marked as persistent to survive RabbitMQ restarts.
- Message acknowledgments and prefetch can be set up for work queue.
- Durability options let the tasks survive even if RabbitMQ is restarted.
- Using message acknowledgments and prefetch_count you can set up a work queue.
- The durability options let the tasks survive even if RabbitMQ is restarted.
- Tasks can be distributed among multiple workers.
- Messages should be marked as durable to survive RabbitMQ restarts.
- RabbitMQ supports message acknowledgments to ensure no message is lost.
- Message acknowledgments are turned off by default.
- Queue must be declared as durable to survive RabbitMQ restarts.
- RabbitMQ uses message acknowledgments to ensure messages are not lost.
- Durable queues and persistent messages should be configured to prevent data loss.
- Uses message acknowledgments and BasicQosAsync to set up a work queue.
- Durability options let tasks survive even if RabbitMQ is restarted.
- RabbitMQ supports message acknowledgments to ensure messages are not lost.
- Durability options must be set for both the queue and messages to survive RabbitMQ
  restarts.
- Tasks are sent to a queue for later processing by workers.
- Use durable queues and persistent messages to avoid data loss.
- To ensure durability, both the queue and messages must be marked as durable.
- RabbitMQ allows for round-robin message distribution among workers.
- Messages must be acknowledged to ensure they are not lost.
- Uses RabbitMQ for message queuing  tasks survive RabbitMQ restarts.
- Uses RabbitMQ for message queueing
- Messages are acknowledged after processing
- Messages must be marked as durable to survive RabbitMQ restarts.
- Using message acknowledgments prevents message loss.
- Message acknowledgments and prefetch_count can be set up for work queues.
- Durability options ensure tasks survive RabbitMQ restarts.
- Messages must be marked as durable to prevent loss during RabbitMQ restarts.
- Acknowledgment must be sent on the same channel that received the delivery.
- Uses RabbitMQ for messaging.
- Durable messaging ensures tasks survive RabbitMQ restarts.
- RabbitMQ supports message acknowledgments and prefetch settings.
- RabbitMQ supports message acknowledgments and durability.
- Tasks will be lost if RabbitMQ server stops unless marked as durable.
- Tasks are distributed using a work queue mechanism.
- Messages should be marked as persistent to ensure they are not lost.
- Uses message acknowledgments to ensure no message is lost.
- Durability options are needed to prevent loss of messages on RabbitMQ restart.
- RabbitMQ is installed and running on localhost on the standard port (5672).
- Using message acknowledgments and prefetch you can set up a work queue.
- Marking messages as persistent doesn't fully guarantee that a message won't be lost.
- In most of the cases `prefetchCount` equal to 1 would be too conservative and severely
  limit consumer throughput.
- If all the workers are busy, your queue can fill up. You will want to keep an eye
  on that, and maybe add more workers, or have some other strategy.
- This tutorial assumes RabbitMQ is installed and running on localhost on the standard
  port (5672).
- Messages are persistent by default with Spring AMQP.
- This happens because RabbitMQ just dispatches a message when the message enters
  the queue.
- If all the workers are busy, your queue can fill up.
- By using Spring AMQP you get reasonable values configured for message acknowledgments
  and fair dispatching.
- Uses fanout exchange to broadcast messages to all queues
- RabbitMQ requires the server to be running on localhost.
- Temporary queues are created with random names and are exclusive.
- A producer sends messages to an exchange instead of directly to a queue.
- Fanout exchange broadcasts messages to all bound queues.
- Temporary queues are created with an empty string as a name and are exclusive.
- Requires RabbitMQ server to be running on localhost:5672
- Default exchange is identified by the empty string ('')
- Temporary queues are created with a random name
- The producer can only send messages to an exchange, which will then push them to
  queues.
- Queues are created with a random name when no name is provided.
- The 'logs' exchange is of type 'fanout' and broadcasts messages to all queues bound
  to it.
- Temporary queues are created with a generated name and are deleted when the consumer
  disconnects.
- The producer can only send messages to an exchange.
- The exchange must know what to do with a message it receives.
- Requires RabbitMQ server to be running on localhost at port 5672.
- The fanout exchange broadcasts all messages to all queues.
- Uses AMQP protocol for messaging.
- Temporary queues are created with random names and deleted when the connection closes.
- Using fanout exchange to broadcast messages to all queues.
- Uses direct exchange for routing messages based on severity.
- Uses direct exchange for routing log messages based on severity.
- Uses direct exchange for message routing based on severity.
- RabbitMQ is installed and running on localhost on port 5672.
- In case you use a different host, port or credentials, connections settings would
  require adjusting.
- Uses basic authentication with default credentials 'guest:guest'
- Requires RabbitMQ installed and running on localhost
- Use port 5672 for connections
- Use a direct exchange to filter messages based on severity
- Using direct exchange allows filtering messages based on severity.
- Bindings can take an extra binding key parameter
- A direct exchange allows filtering messages based on their severity
- Bindings can take an extra routingKey parameter.
- To emit a log message, use 'go run emit_log_direct.go severity message'.
- The routing key is used to filter messages based on severity.
- Uses topic exchange for routing messages based on patterns.
- Colors can be one of 'orange', 'black', or 'green'.
- Messages sent to a topic exchange can't have an arbitrary routing_key - it must
  be a list of words, delimited by dots.
- Binding keys must also be in the same form.
- The binding key must also be in the same form.
- RabbitMQ is assumed to be installed and running on localhost on the standard port
  (5672).
- Messages sent to a topic exchange must have a routing key formatted as a list of
  words, delimited by dots.
- Binding keys can use '*' to substitute for one word and '#' to substitute for zero
  or more words.
- Messages sent to a topic exchange can't have an arbitrary routingKey - it must be
  a list of words, delimited by dots.
- The binding key must also be in the same form. Special cases for binding keys include
  '*' (star) for exactly one word and '#' (hash) for zero or more words.
- Example routing keys include 'stock.usd.nyse', 'nyse.vmw', 'quick.orange.rabbit'.
- Messages must have a routing key that consists of words delimited by dots.
- Messages sent to a topic exchange must have a routing key that is a list of words,
  delimited by dots.
- The binding key must also be in the same form with special cases for `*` (star)
  and `#` (hash).
- Messages sent to a topic exchange must have a routing_key that is a list of words
  delimited by dots.
- Binding keys can use '*' and '#' for pattern matching.
- 'When a queue is bound with # (hash) binding key - it will receive all the messages,
  regardless of the routing key.'
- Messages sent to a topic exchange must have a routingKey that is a list of words,
  delimited by dots.
- Make sure it's obvious which function call is local and which is remote.
- Document your system. Make the dependencies between components clear.
- Handle error cases. How should the client react when the RPC server is down for
  a long time?
- Uses RabbitMQ for Remote Procedure Call (RPC) system
- Client sends a request message and server replies with a response message
- Creating a callback queue for every RPC request is inefficient; better to create
  a single callback queue per client.
- Handle error cases when the RPC server is down for a long time.
- Handles RPC requests using callback queues.
- Correlation ID is used to match requests with responses.
- If the RPC server is too slow, you can scale up by just running another one.
- The server responds using the queue from the reply_to field.
- The server uses 'rpc_queue' for requests.
- Clients can create exclusive callback queues.
- Uses AMQP protocol
- Assumes only valid positive integer input for Fibonacci calculation.
- The RPC server can be scaled by running additional instances.
- Callback queue is created for every RPC request.
- RPC service returns Fibonacci numbers.
- Publisher confirms are a RabbitMQ extension to the AMQP 0.9.1 protocol, so they
  are not enabled by default.
- Confirms should be enabled just once, not for every message published.
- The server code sets prefetch count for channel to 1.
- Publisher confirms are not enabled by default.
- Messages are confirmed asynchronously by the broker.
- Publisher confirms are an extension to implement reliable publishing.
- The request-reply pattern in RabbitMQ involves a straightforward interaction between
  the server and the client.
- Publisher confirms are not enabled by default and must be enabled at the channel
  level.
- Confirm callbacks are dispatched in an I/O thread where channels are not supposed
  to do operations.
- Publisher confirms are not enabled by default and must be configured at the channel
  level.
- RabbitMQ will continue to support AMQP 0-9-1 indefinitely.
- Different client libraries have different ways to synchronously deal with publisher
  confirms.
- The client MUST NOT receive a message on one channel and then acknowledge it on
  another.
- The server MUST NOT use a zero value for delivery tags.
- The server SHOULD try to signal redelivered messages when it can.
- The client MUST NOT rely on the redelivered field but should take it as a hint that
  the message may already have been processed.
- The server MUST support at least the en_US locale.
- The server SHOULD respect the persistent property of basic messages and SHOULD make
  a best-effort to hold persistent basic messages on a reliable storage mechanism.
- The server MUST NOT discard a persistent basic message in case of a queue overflow.
- The server MUST validate that a non-zero delivery-tag refers to a delivered message,
  and raise a channel exception if this is not the case.
- Queues can be declared as durable or transient.
- The server supports 0-8, 0-9 and 0-9-1 on the same port.
- FIFO characteristics are guaranteed under the conditions specified in section 4.7.
- Streams are always persistent and replicated.
- Streams allow consumers to attach at any point in the log and read from there.
- Streams are implemented as an immutable append-only disk log.
- Retention configuration per stream can discard the oldest data based on total log
  data size and/or age.
- Retention is evaluated on a per-segment basis.
- Streams persist all data to disks before doing anything; use the fastest disks possible.
- Streams are affected by cluster sizes; more replicas generally lower throughput.
- Replicas of a stream are explicitly managed by the operator.
- A stream requires a quorum of the declared nodes to be available to function.
- The delivery tag is valid only within the channel from which the message was received.
- 'The server SHOULD implement these standard exchange types: fanout, direct.'
- The server MUST pre-declare a direct exchange with no public name to act as the
  default exchange for content Publish methods and for default queue bindings.
- The server MUST support at least 16 exchanges per virtual host and ideally, impose
  no limit except as defined by available resources.
- The server MUST create a default binding for a newly-declared queue to the default
  exchange.
- The server MUST support both durable and transient exchanges.
- The server MUST support both exclusive (private) and non-exclusive (shared) queues.
- RabbitMQ Streams was introduced in RabbitMQ 3.9.
- The server SHOULD interpret this method as meaning that the client is unable to
  process the message at this time.
- The server MUST NOT deliver the message to the same client within the context of
  the current channel.
- The server MUST set the redelivered flag on all messages that are resent.
- Applications MUST NOT rely on the atomicity of transactions that affect more than
  one queue.
- Applications MUST NOT rely on the behaviour of transactions that include messages
  published with the immediate option.
- Applications MUST NOT rely on the behaviour of transactions that include messages
  published with the mandatory option.
- The client MUST NOT use the Commit method on non-transacted channels.
- The client MUST NOT use the Rollback method on non-transacted channels.
- Streams are always durable.
- Streams do not support global QoS prefetch.
- Streams persist all data to disks before doing anything.
- Streams replicate data across multiple nodes and publisher confirms are only issued
  once the data has been replicated to a quorum of stream replicas.
- This tutorial assumes RabbitMQ is installed, running on localhost and the stream
  plugin enabled.
- The stream is limited to be 5 GiB in size.
- Stream is an append-only log abstraction that allows for repeated consumption of
  messages until they expire.
- 'Stream declaration operation is idempotent: the stream will only be created if
  it doesn''t exist already.'
- Each time the producer is run, it will send a single message to the server.
- 'The stream declaration operation is idempotent: the stream will only be created
  if it doesn''t exist already.'
- Uses RabbitMQ Streams for offset tracking
- The consumer must have a name to store and retrieve the last stored offset value
- A stream is an append-only log abstraction that allows for repeated consumption
  of messages until they expire.
- Make sure to enable the stream and stream management plugins.
- RabbitMQ Streams provide server-side offset tracking to store the progress of a
  given consumer in a stream.
- The consumer must have a name.
- The offset is stored every 10 messages.
- RabbitMQ Streams provides server-side offset tracking to store the progress of a
  given consumer in a stream.
- The consumer must have a name to use Server-Side Offset Tracking.
- Uses server-side offset tracking to store the progress of a consumer.
- RabbitMQ Marks are a symbol of the quality and community support associated with
  the RabbitMQ open source software.
- The Apache 2.0 license gives you the right to use, copy, distribute and modify the
  RabbitMQ software.
- The consumer must have a name. It is the key to store and retrieve the last stored
  offset value.
- Publishers can publish to a destination that varies from protocol to protocol.
- An attempt to publish to a non-existent queue (topic) will result in a channel-level
  exception with the code of `404 Not Found`.
- This strategy can be considered an anti-pattern and is documented primarily for
  completeness.
- It involves publishing a message and immediately waiting for the outstanding acknowledgement
  to arrive.
- Consumers are typically registered during application startup.
- Automatic connection recovery is recommended for consuming applications.
- Publishers publish to a destination that varies from protocol to protocol.
- Single active consumer can be enabled when declaring a queue with the x-single-active-consumer
  argument set to true.
- Publisher confirms provide a mechanism for application developers to keep track
  of what messages have been successfully accepted by RabbitMQ.
- Queues can be durable or transient.
- Temporary queues can be a reasonable choice for workloads with transient clients.
- Publishers can be more dynamic and begin publishing in reaction to a system event.
- A single queue is generally considered to be an anti-pattern, and not just for resource
  utilisation reasons.
- When a connection is blocked, no more data sent by this connection will be read,
  parsed or processed on the connection.
- Concurrent publishing on a shared channel is not supported by client libraries.
- no more than 500 channels can be opened on each node at the same time
- Automatically recovering connections that use auto-delete and exclusive queues should
  make sure that these queues are server-named.
- Channels cannot exist without a connection.
- A channel only exists in the context of a connection and never on its own.
- RabbitMQ is a messaging broker.
- Acknowledgements on both consumer and publisher side are important for data safety
  in applications that use messaging.
- Single Active Consumer feature cannot be enabled with a policy.
- Finding a suitable prefetch value is a matter of trial and error and will vary from
  workload to workload.
- Values in the 100 through 300 range usually offer optimal throughput and do not
  run significant risk of overwhelming consumers.
- Queues can have their length limited.
- Queues and messages can have a TTL.
- Plugins are activated when a node is started or at runtime when a CLI tool is used.
- The enabled_plugins file is usually located in the node data directory or under
  /etc.
- Each channel consumes a relatively small amount of memory.
- For a plugin to be activated at boot, it must be enabled.
- The file can be generated by deployment tools.
- A significant majority of 3rd-party plugin activation issues come down to insufficient
  filesystem permissions
- Messaging-based systems can fail in different ways, including network connection
  problems and congestion.
- Acknowledgements guarantee at least once delivery; without them, message loss is
  possible.
- RabbitMQ natively supports both AMQP 1.0 and AMQP 0.9.1 out of the box, without
  requiring any additional plugins.
- AMQP clients should use address format v2.
- Address format v1 is deprecated in RabbitMQ 4.0 and will be unsupported in a future
  RabbitMQ version.
- Consumer acknowledgements and publisher confirms are essential for data safety.
- RabbitMQ does not support suspending or resuming a link including link recovery.
- The behaviour of `undeliverable-here` may change in a future RabbitMQ version.
- Applications must close connections to conserve resources.
- Using TLS is highly recommended for production systems.
- Plugins extend core broker functionality in a variety of ways
- A set of curated plugins is available
- The enabled plugins file is commonly known as the enabled plugins file.
- 'Setting the heartbeat timeout value too low can lead to false positives: connection
  peer being considered unavailable while it is not really the case'
- Deactivating heartbeats is highly discouraged unless TCP keepalives are used instead
  with an adequately low inactivity detection period
- Prometheus plugin is recommended for production monitoring.
- Management plugin has limitations and is better suited for development environments.
- Health checks can be performed at various stages for comprehensive monitoring.
- Use CLI tools for specific checks related to RabbitMQ operations.
- Plugins that ship with the RabbitMQ distributions are often referred to as tier
  1 plugins.
- Provided that a standard distribution package is used they do not need to be installed
  but do need to be enabled before they can be used.
- The plugin serves metrics on port 15692 by default.
- Management plugin can serve metrics via HTTP API on port 15672.
- RabbitMQ requires the use of Simple Authentication and Security Layer (SASL) for
  AMQP 1.0 connections.
- Health checks can verify the state of an individual node or the entire cluster.
- The probability of false positives can be considered approaching 0 except for upgrades
  and maintenance windows.
- 'RabbitMQ does not support the following AMQP 1.0 features: ''Suspending'' or ''resuming''
  a link including link recovery, ''exactly once'' delivery, and Terminus Expiry Policy.'
- 'DO NOT USE: this health check is long deprecated and in modern versions it is a
  no-op'
- Sets the interval to 60 seconds
- Streams are a persistent and replicated data structure which models an append-only
  log with non-destructive consumer semantics.
- The plugin supports TCP listener option configuration.
- When a TLS listener is set up, you may want to deactivate all non-TLS ones.
- Must ONLY be enabled for new clusters before any clients declare durable subscriptions
- 'Setting the heartbeat timeout to a really low value can lead to false positives:
  connection peer being considered unavailable while it is not really the case'
- Values within the 5 to 20 seconds range are optimal for most environments
- MQTT clients must authenticate and have appropriate permissions for the virtual
  host.
- The MQTT plugin is included in the RabbitMQ distribution and must be enabled on
  all cluster nodes using rabbitmq-plugins enable rabbitmq_mqtt.
- MQTT clients can specify a set of credentials when they connect.
- The plugin supports anonymous authentication but its use is highly discouraged.
- The MQTT specification does not define consistency or replication requirements for
  retained message stores, therefore RabbitMQ allows for custom ones to meet the consistency
  and availability needs of a particular environment.
- The plugin serves metrics via the HTTP API on port 15672 by default.
- The MQTT plugin is included in the RabbitMQ distribution.
- Uses RabbitMQ HTTP API for health checks and metrics.
- Anonymous connections are highly discouraged and subject to certain limitations.
- Clients must provide credentials if anonymous connections are disabled.
- Monitoring can increase load on the system being monitored.
- Recommended metric collection interval for production is 30 seconds.
- Default listener port is 1883
- Default user login/passcode is guest/guest
- MQTT clients will be able to connect provided that they have a set of credentials
  for an existing user with the appropriate permissions.
- The use of anonymous connections is highly discouraged and it is a subject to certain
  limitations
- The authenticated user must exist in the configured authentication / authorisation
  backend(s).
- Clients must not supply username and password.
- Stream plugin must be enabled using rabbitmq-plugins.
- Default listener port is 5552.
- Anonymous connections are discouraged and have limitations.
- use DETS (disk-based) store for retained messages
- only used by DETS store (in milliseconds)
- Uses OAuth 2.0 for authentication.
- Anonymous authentication is highly discouraged and subject to certain limitations.
- The STOMP Adapter will listen on all interfaces on port 61613 by default.
- To change the listener port, edit the configuration file.
- Uses OAuth 2.0
- Durable subscriptions allow clients to disconnect from and reconnect to the STOMP
  broker as needed, without missing messages that are sent to the topic.
- MQTT clients can specify a set of credentials when they connect. The credentials
  can be a username and password pair, or a x.509 certificate.
- By default, the Web STOMP plugin will listen on all interfaces on port 15674 and
  have a default user login/passcode of guest/guest.
- We highly recommend creating a separate user for production systems.
- The use of anonymous connections is highly discouraged and it is a subject to certain
  limitations.
- Default user login/passcode is guest/guest.
- User is only allowed to connect from localhost by default.
- By default, the Web MQTT plugin exposes a WebSocket endpoint on port 15675.
- The default user login and password is guest/guest.
- The use of anonymous connections is highly discouraged and it is a subject to certain
  limitations enforced for a reasonable level of security by default.
- By default the Web MQTT plugin exposes a WebSocket endpoint on port 15675.
- Default user login and password of guest/guest.
- Uses guest/guest as default user login/passcode
- MQTT plugin listens on all interfaces on port 1883 by default
- RabbitMQ supports MQTT versions 3.1, 3.1.1, and 5.0 via a plugin that ships in the
  core distribution.
- Using the mqtt.durable_queue_type option, it is possible to opt in to use quorum
  queues for subscribers whose MQTT session lasts longer than their MQTT network connection.
- OAuth 2.0 authentication requires separate configuration in the management UI.
- Anonymous connections are highly discouraged and subject to limitations.
- Management UI has a number of limitations such as overhead and only stores recent
  data.
- OAuth 2.0 authentication requires configuration in the management UI.
- MQTT clients can interoperate with other protocols.
- When using management.oauth_enabled = true, it is still possible to authenticate
  with HTTP basic authentication against the HTTP API.
- To switch to authenticate using OAuth 2 exclusively for management HTTP access,
  set the management.disable_basic_auth configuration key to true.
- Users must have appropriate permissions to connect.
- Management UI access is controlled via the RabbitMQ permission tags system.
- RabbitMQ 3.13.1 and earlier versions require the OpenId Connect Discovery endpoint
  end_session_endpoint returned for OAuth 2.0 authentication to work.
- The plugin supports retained messages with some limitations.
- Retained messages are stored node-local and not replicated.
- OAuth 2.0 authentication must be configured separately for management UI
- Management UI access is controlled via user tags
- TLS must be configured in the broker to use TLS for STOMP connections
- Uses OAuth2 with Bearer token for management API access.
- Durable subscriptions allow clients to disconnect and reconnect without missing
  messages.
- Temporary queues are managed by the broker and are private to each session.
- Reverse proxy setup for RabbitMQ may require careful handling of encoded slashes
  in paths if default virtual host is used.
- The Web STOMP plugin makes it possible to use STOMP over a WebSocket connection.
- The WebSocket endpoint is available on the /ws path.
- OAuth 2.0 authentication requires separate configuration for management UI.
- The Web STOMP plugin will listen on all interfaces on port 15674 and have a default
  user login/passcode of guest/guest.
- This user is only allowed to connect from localhost by default.
- management.oauth_enabled = true
- management.oauth_scopes = openid profile rabbitmq.*
- The Web MQTT plugin exposes a WebSocket endpoint on port 15675.
- Default user login and password is guest/guest, allowed to connect from localhost.
- This key must only be used if private key is password protected
- The management UI has a number of limitations related to monitoring.
- OAuth 2.0 requires configuration of the OAuth provider.
- This means that RabbitMQ should not need to present a client_secret when authenticating
  users.
- For these cases, it is possible to configure oauth_client_secret.
- Response compression is enabled by default.
- RabbitMQ nodes do not log any HTTP API requests by default.
- Uses OAuth 2.0 for authentication in the management UI.
- Uses OAuth2  requires setup of connected app in api
- OAuth 2.0 authentication is configurable for the management UI.
- Uses OAuth2 for authentication
- Basic authentication is also supported
- The management UI requires authentication and authorisation much like RabbitMQ requires
  it from connecting clients.
- Usually RabbitMQ nodes do not perform peer verification of HTTP API clients but
  it can be enabled if needed. Clients then will have to be configured with a certificate
  and private key pair.
- Uses OAuth2 with Bearer token for authorization when basic auth is disabled
- Endpoints GET /definitions and POST /definitions require token in the query string
  parameter
- The management plugin shows message rates globally and for each queue, channel,
  exchange, and vhost.
- Detailed message rates are disabled by default.
- When OAuth 2 is enabled, the management UI only accepts OAuth 2 authentication.
- The federation plugin is included in the RabbitMQ distribution.
- All nodes of the cluster should have the federation plugin enabled.
- nocanon is required only if default RabbitMQ virtual host is used
- AllowEncodedSlashes On required for Apache virtual host if default RabbitMQ virtual
  host is used
- The management UI requires authentication and authorization.
- OAuth 2.0 authentication can be configured to use JWT-encoded access tokens.
- The defined policy will make the exchanges whose names begin with 'amq.' federate
  using the upstream set 'all'.
- Federation connections can be secured with TLS.
- Uses OAuth2 with refresh token  requires setup of connected app in api
- To enable it, use rabbitmq-plugins enable rabbitmq_federation.
- Ensure rabbitmq_federation_management plugin is enabled
- OAuth 2.0 authentication in the management UI requires separate configuration.
- To enable federation, use rabbitmq-plugins enable rabbitmq_federation
- Management UI is recommended for easier configuration
- Using TLS requires client certificate and key pair configured
- Reconnection period is configurable in upstream definition
- This command will be available only if federation plugin is enabled
- OAuth 2.0 authentication must be configured separately for the management UI.
- Both HTTP basic authentication and OAuth 2.0 are allowed.
- To switch to OAuth 2.0 exclusively, set management.disable_basic_auth to true.
- Some objects like Contact may return nulls in deeply nested fields
- Requires federation plugin to be enabled
- Use 'amqps' for TLS-enabled federation links
- Federation can transmit messages between brokers in different administrative domains.
- Federation links can be treated as special kind of clients by operators.
- To enable federation, use rabbitmq-plugins enable rabbitmq_federation.
- Uses RabbitMQ federation plugin to replicate messages between brokers.
- If management UI is used, it is recommended to enable rabbitmq_federation_management
- Federation links are started when there is a configured upstream, a matching policy,
  and a connection to the target upstream.
- Information about federation upstreams is stored in the RabbitMQ database, along
  with users, permissions, queues, etc.
- Exchanges with internal property set to true cannot be federated.
- The default exchange cannot be federated.
- Federated queues include a number of limitations or differences compared to their
  non-federated peers as well as federated exchanges.
- Applications that use basic.get cannot retrieve messages over federation if there
  aren't any in a local queue.
- You cannot use the `federation-upstream` and `federation-upstream-set` keys together
  in a policy.
- Shovel is a minimalistic message pump.
- Dynamic shovels are automatically defined on all nodes of the hosting cluster.
- Virtual hosts can be created using CLI tools or an HTTP API endpoint.
- Creating a virtual host involves a blocking cluster-wide transaction.
- The built-in exchanges should now be federated because they are matched by the policy.
- Use rabbitmq-plugins enable rabbitmq_federation to enable federation.
- Virtual hosts provide logical grouping and separation of resources.
- A virtual host can be created using CLI tools or an HTTP API.
- It is recommended that rabbitmq_federation_management is also enabled
- Uses TLS with certificates for secure connections
- Ensure CA is trusted on both ends of the federation link
- Ensure that the rabbitmq_federation_management plugin is enabled.
- The default exchange cannot be federated as it relies on node-local optimizations.
- Parameters reside in the database used by RabbitMQ for definitions of virtual hosts,
  exchanges, queues, bindings, users and permissions.
- Federated queues will not propagate bindings from the downstream to the upstreams.
- You cannot use the federation-upstream and federation-upstream-set keys together
  in a policy.
- The default value for prefetch-count is 1000.
- The default value for reconnect-delay is 1 second.
- Policies dynamically configure optional arguments for queues, exchanges, and streams.
- Policies are matched and applied every time an exchange or queue is created.
- Policies are a declarative mechanism for configuring properties of groups of queues,
  streams, exchanges.
- The apply-to argument can be 'exchanges', 'queues', 'classic_queues', 'quorum_queues',
  'streams', or 'all'.
- Blanket policies use negative priorities.
- Modification of operator policies via the HTTP API and Web UI can be disabled in
  configuration.
- The `--definitions-keys` parameter accepts a single definition key or a command-separated
  list of keys.
- Virtual hosts must be created using CLI tools or the HTTP API.
- Deleting a virtual host will permanently delete all entities in it.
- Operator policies can be modified in a number of ways, very similarly to regular
  policies.
- Virtual hosts are created and deleted using rabbitmqctl or the HTTP API.
- Modification of operator policies via the HTTP API and Web UI can be disabled in
  configuration. This makes operator policies read-only for all users via the HTTP
  API and Web UI.
- Policies cannot be used to configure queue type.
- Policies can change at any time and their effects may take a moment to become effective.
- When multiple policies match an entity and they all have equal priorities, the effective
  one will be chosen undeterministically.
- Parameters can be set by invoking rabbitmqctl or through the HTTP API.
- Global parameters are used to store various cluster-level metadata.
- Policies can change at any time and are applied every time an exchange or queue
  is created.
- Policies are used for dynamically configuring properties of queues and exchanges.
- Policies can change at runtime.
- Policies can change at any time and are matched every time an exchange or queue
  is created.
- The new --definition object will be merged into the existing policy definition.
- Policies are a declarative mechanism of configuring certain properties of groups
  of queues, streams, exchanges.
- Policies can change at any time. When a policy definition is updated, its effect
  on matching exchanges and queues will be reapplied.
- Policies are a declarative mechanism for configuring properties of queues, streams,
  exchanges.
- The type of a queue cannot be configured by policies.
- Operator policies can unexpectedly change queue attributes and, in turn, application
  assumptions and semantics.
- Policies automatically match against exchanges and queues, and help determine how
  they behave.
- At most one policy matches a queue or exchange.
- Operator policies can unexpectedly change queue attributes and are limited to a
  few arguments.
- Operator policies allow enforcement of certain policies while letting other users
  manage them.
- Operator policies can unexpectedly change queue attributes and application assumptions.
- CLI tools require a compatible Erlang/OTP version to be installed.
- Tools assume that system locale is a UTF-8 one.
- Operator policies can unexpectedly change queue attributes and may enforce certain
  policies.
- RabbitMQ CLI tools require a compatible Erlang/OTP version to be installed.
- The tools assume that system locale is a UTF-8 one.
- An incorrectly placed cookie file or cookie value mismatch are most common scenarios
  for such failures.
- AMQP 0-9-1 uses SASL for authentication. Typically the PLAIN mechanism is used.
- Policies cannot be used to configure queue type, by design.
- Quorum queues should be considered the default choice when needing a replicated,
  highly available queue.
- Quorum queues support both Queue TTL and message TTL.
- Operator policies can unexpectedly change queue attributes.
- Modification of operator policies via the HTTP API and Web UI can be disabled.
- If the results are empty, this means that no policies in the target virtual host
  have matched the target object (queue, stream, exchange).
- Quorum queues adopt a different replication and consensus protocol and give up support
  for certain 'transient' in nature features.
- Quorum queues are optimized for certain use cases where data safety is the top priority.
- Policies is a declarative mechanism of configuring certain properties of groups
  of queues, streams, exchanges.
- At most one policy matches a queue or exchange. Matching policies are then sorted
  by priority and the one with the highest priority will take effect.
- Operator policies allow for certain policies to be enforced by the operator.
- Operator policies are merged with regular policy definitions.
- Quorum queues are designed for excellent data safety as well as reliable and fast
  leader election properties.
- Quorum queues are optimized for use cases where data safety is the top priority.
- Quorum queues can be configured via RabbitMQ policies.
- The minimum factor value that makes practical sense is three.
- Quorum queues cannot provide any safety guarantees for messages that have not been
  confirmed to the publisher.
- Most commands only support the online mode (when target node is running).
- Quorum queues are designed to provide data safety under network partition and failure
  scenarios.
- Most commands can be used to operate on remote nodes.
- In environments with heavy quorum queue usage and/or large messages flowing through
  them, it is very important to overprovision disk space, that is, have the extra
  spare capacity.
- Quorum queues depend heavily on consumers acknowledging messages in a timely manner,
  so a reasonably low delivery acknowledgement timeout must be used.
- With larger messages, decreasing the number of entries per segment file can be beneficial
  to reduce the size of segment files and allow for more frequent truncation (removal)
  of those files.
- Larger messages can be stored in a blob store as an alternative, with relevant metadata
  being passed around in messages flowing through quorum queues.
- Quorum queues should be used for critical applications where data safety is a priority.
- Quorum queues are not suitable for temporary queues or scenarios where latency is
  critical.
- AMQP 0-9-1 clients need host address and port to connect.
- Username and password may be used for authentication.
- Quorum queues cannot provide safety guarantees for messages not confirmed to the
  publisher.
- Quorum queues are optimized for data safety and performance.
- Values between 256 and 4096 in steps of 256 are most commonly used.
- RabbitMQ has inbuilt support for TLS.
- TLS can be enabled for all protocols supported by RabbitMQ.
- RabbitMQ has inbuilt support for TLS. This includes client connections and popular
  plugins.
- Quorum queues are not designed to be used for every problem.
- Peer verification is highly recommended in production environments.
- Disabling peer verification can make sense in certain environments (e.g. development).
- To suppress verification, set System.Net.Security.SslPolicyErrors.RemoteCertificateNotAvailable
  and System.Net.Security.SslPolicyErrors.RemoteCertificateChainErrors flags in SslOption.
- RabbitMQ .NET client 5.x series uses TLSv1.0 by default.
- Starting with RabbitMQ .NET client 6.0 the default changes to SslProtocols.None.
- Modern .NET frameworks versions default to TLSv1.2.
- Clients may or may not have their own certificates.
- Mutual peer verification involves enabling peer verification for client connections
  on the RabbitMQ side and enabling peer verification of the server in application
  code.
- Client libraries usually support both modes of operation  with or without peer
  verification.
- The recommended number of members for a quorum queue is the quorum of cluster nodes
  (but no fewer than three).
- TLS has evolved over time and has multiple versions in use.
- Disabling older TLS versions is a way to mitigate many of those attacks.
- Quorum queues have been optimized further in RabbitMQ 4.1.x and now feature lower
  memory footprints and improved consumer delivery rates.
- It is possible to configure what cipher suites will be used by RabbitMQ.
- Not all suites will be available on all systems.
- To mitigate BEAST attack, disable TLSv1.0 support.
- Quorum queues are designed for excellent data safety and high availability.
- Quorum queues keep all dead-lettered message bodies in memory.
- Peer verification is primarily controlled using ssl_options.verify and ssl_options.fail_if_no_peer_cert.
- Mutual peer verification is a joint responsibility of RabbitMQ nodes and client
  connections.
- Disabling TLSv1.0 limits the number of client platforms supported.
- BEAST attack is a known vulnerability that affects TLSv1.0.
- Quorum queues have been optimized further in RabbitMQ 4.1.x.
- TLS support includes client connections and popular plugins.
- For client connections, RabbitMQ can handle TLS connections or use a proxy for TLS
  termination.
- When peer verification is enabled, clients should check whether the hostname of
  the server matches SAN or CN fields in the server certificate.
- For a client certificate to be understood on the .NET platform, they can be in a
  number of formats including DER and PKCS#12 but not PEM.
- On the .NET platform, trusted certificates are managed by putting them into any
  of a number of stores.
- The following example adds a certificate to the store of user Root (also known as
  Trust in some .NET implementation).
- The .NET client by default requires peer verification to succeed.
- It is highly recommended that both digitalSignature and keyEncipherment options
  are set for certificates that will be used by both RabbitMQ nodes and client libraries.
- Server-preferred cipher suite ordering is enforced.
- To avoid malicious clients, configure honor_cipher_order and honor_ecc_order to
  true.
- It is recommended to use certificates issued by a widely trusted commercial CA in
  production environments.
- Mutual peer verification ('mTLS') is a joint responsibility of RabbitMQ nodes and
  client connections.
- Server TLS certificates (public keys) and private keys have expiration dates and
  will need to be replaced (rotated) every so often.
- 'The replacement process involves the following steps: Replace the files on disk,
  Clear the certificate and private key store cache on the node.'
- Without the second step, the new certificate/key pair will be used by the node after
  a period of time, as the TLS implementation in the runtimes purges its certificate
  store cache.
- The two examples above generate private keys that are 2048 bits in size.
- 'It is possible to use longer (and thus more secure but also slower to generate)
  keys by providing a different value to `openssl genrsa`, e.g.:'
- Another option would be to generate a key using Elliptic Curve Cryptography.
- Query parameters are added to the URI in the usual way.
- The client will pick sensible defaults when they are omitted.
- To verify that TLS has been enabled on the node, restart it and inspect its log
  file.
- Default log output is to a file if no outputs are explicitly configured.
- When using RABBITMQ_LOGS, all logging-related rabbitmq.conf settings will be ignored.
- Only administrative users can have write access to the system-wide stores.
- Uses microseconds since UNIX epoch for timestamp format
- If only console logging is activated, this command will fail with a 'file not found'
  (enoent) error.
- The rabbitmq-diagnostics log_tail_stream command can only be used against a running
  RabbitMQ node and will fail if the node is not running or the RabbitMQ application
  on it was stopped using rabbitmqctl stop_app.
- RabbitMQ nodes log to a file by default, if no outputs are explicitly configured.
- Logging to a file can be deactivated with log.file = false.
- This command will fail with a 'file not found' (enoent) error if only console logging
  is activated.
- The rabbitmq-diagnostics log_tail_stream command can only be used against a running
  RabbitMQ node.
- Nodes log to a file by default, if no outputs are explicitly configured.
- The environment variable takes precedence over the configuration file. When it is
  set, all logging-related rabbitmq.conf settings will be effectively ignored.
- This log severity is meant to be used when troubleshooting peer discovery activity.
- Debug logging can be activated to log a lot of information useful for troubleshooting.
- This setting should only be used as a last resort measure when overriding log format
  is a hard requirement of log collection tooling
- To create a TLS-enabled connection to RabbitMQ, we need to set some new fields in
  the ConnectionFactory's Parameters field.
- TLS has been around since the mid-90s, and there are multiple TLS versions available,
  although older versions are retired by the industry as newer and more secure ones
  are developed.
- Starting with RabbitMQ .NET client 6.0 the default changes to SslProtocols.None,
  which means the default is picked by the .NET framework or the operating system
  depending on app context switches.
- RabbitMQ nodes only log to a file if explicitly configured to do so using the configuration
  keys listed.
- This is semantically equivalent to using `tail -f /path/to/rabbit@hostname.log`.
- If only console logging is activated, this command will fail with a 'file not found'
  (`enoent`) error.
- The `rabbitmq-diagnostics log_tail_stream` command can only be used against a running
  RabbitMQ node and will fail if the node is not running or the RabbitMQ application
  on it was stopped using `rabbitmqctl stop_app`.
- RabbitMQ has inbuilt support for TLS including client connections and popular plugins.
- Common approaches to TLS for client connections include configuring RabbitMQ to
  handle TLS connections or using a proxy.
- This setting can lead to incomplete log messages and should be used only as a last
  resort measure.
- Mutual peer verification requires enabling peer verification on both RabbitMQ and
  client connections.
- RabbitMQ starts logging early on node start.
- The `certmgr` command line tool manages certificates in a specified store.
- To create a TLS-enabled connection to RabbitMQ, set fields in the ConnectionFactory's
  Parameters field.
- It is highly recommended that both of the above options (bits) are set for certificates
  that will be used by both RabbitMQ nodes and client libraries.
- To avoid malicious clients that intentionally negotiate weak cipher suites, configure
  honor_cipher_order and honor_ecc_order to true.
- Client Authentication required
- Classic queues are the default queue type as long as the default queue type is not
  overridden for the virtual host.
- Classic queues do not support poison message handling, unlike quorum queues.
- 'It is possible to use longer (and thus more secure but also slower to generate)
  keys by providing a different value to openssl genrsa, e.g.: openssl genrsa -out
  private_key.pem 4096.'
- Another option would be to generate a key using Elliptic Curve Cryptography. Instead
  of openssl genrsa use openssl ecparam.
- Transient queues are discouraged and will be removed in RabbitMQ 4.0.
- Support for transient queues is deprecated and will be removed in RabbitMQ 4.0.
- When logging to a file, the recommended rotation option is logrotate.
- TTL specifies the time period that the messages and queues 'live for'.
- Setting TTL (expiration) on queues generally only makes sense for transient (non-durable)
  classic queues.
- RabbitMQ nodes log to a file by default if no outputs are explicitly configured.
- Logging to a file can be deactivated with 'log.file = false'.
- The default behaviour for RabbitMQ when a maximum queue length or size is set and
  the maximum is reached is to drop or dead-letter messages from the front of the
  queue.
- RabbitMQ nodes only log to a file if explicitly configured to do so using the configuration
  keys listed below.
- RabbitMQ no longer supports the 'lazy' mode. This page is provided for historical
  reference only.
- When debug logging is enabled, the node will log a lot of information that can be
  useful for troubleshooting.
- This log severity is meant to be used when troubleshooting, say, the peer discovery
  activity.
- RabbitMQ starts logging early on node start. Many important pieces of information
  about node's state and configuration will be logged during or after node boot.
- Hardcoded x-arguments are strongly recommended against since they cannot be updated
  without redeploying applications.
- This log severity is meant to be used when troubleshooting.
- Values between 1 and 5 are highly recommended for priority queues.
- Using more priorities consumes more CPU resources by using more Erlang processes.
- RabbitMQ supports logging to a file, standard output, and Syslog.
- Logging to a file is the default behavior unless specified otherwise.
- RabbitMQ slightly deviates from the AMQP 0-9-1 spec when it comes to how the prefetch
  is applied to multiple consumers on a channel.
- This setting can lead to incomplete log messages and should only be used as a last
  resort measure when overriding log format is a hard requirement of log collection
  tooling.
- Multi-line messages can be truncated to a single line.
- Logging to a file is one of the most common options for RabbitMQ installations.
- RabbitMQ nodes only log to a file if explicitly configured to do so.
- RabbitMQ comes with default built-in settings.
- For production deployment tuning, there is a way to configure many things in the
  broker as well as plugins.
- This command will continuously tail and stream lines added to the log file.
- RabbitMQ uses a configuration file named rabbitmq.conf for server and plugin settings.
- The advanced.config file may be used for advanced settings that cannot be expressed
  in rabbitmq.conf.
- Encrypted configuration entries won't make the system perfectly secure.
- 'To use encrypted values, a few steps must be taken: Generate a unique passphrase,
  Encrypt a value using `rabbitmqctl encrypt_conf_value` or `rabbitmqctl encode`,
  Use the CLI-produced value in `rabbitmq.conf` or `advanced.config`, Specify a config
  entry decode passphrase in `advanced.config`.'
- Classic format is deprecated, prefer new style config format.
- Classic queues use the non-replicated FIFO queue implementation.
- Sensitive configuration entries can be encrypted.
- For all other cases, there is a way to configure many things in the broker as well
  as plugins.
- RabbitMQ comes with default built-in settings. Those can be entirely sufficient
  in some environment (e.g. development and QA).
- Cluster name can be overridden via rabbitmq.conf
- Cluster tags can be configured using rabbitmq.conf
- Node tags can be preconfigured via rabbitmq.conf
- Current implementation provides low latency with low and stable memory usage.
- Most settings are configured using the main configuration file named rabbitmq.conf.
- Configuration file changes take effect after a node restart.
- When a dead letter exchange is specified, the user must have read permissions on
  the declared queue and write permissions on the dead letter exchange.
- Cookies are necessary for the website to function and cannot be switched off in
  Broadcoms systems.
- Using more priorities consumes more CPU resources.
- RabbitMQ can use a default prefetch that will be applied if the consumer doesn't
  specify one.
- Default configuration file location is distribution-specific.
- Configuration files should use the new style config format in rabbitmq.conf.
- Overrides primary config file location
- Overrides advanced config file location
- Environment variable interpolation is supported in rabbitmq.conf
- Default configuration file locations vary between operating systems
- Cluster name is set to the name of the first node in the cluster by default.
- RabbitMQ uses a configuration file named rabbitmq.conf
- Default configuration file location is platform-specific
- Most settings are configured using the first two methods.
- 'Effective configuration is computed using the following steps: `rabbitmq.conf`
  is translated into the internally used (advanced) config format. These configuration
  is merged into the defaults; `advanced.config` is loaded if present, and merged
  into the result of the step above.'
- Effective configuration should be verified together with config file location.
- Configuration affects many areas of the system, including plugins.
- Changes take effect after a node restart.
- The classic format is deprecated. Please prefer the new style config format in rabbitmq.conf
  accompanied by an advanced.config file as needed.
- RabbitMQ configuration can be managed using multiple methods including configuration
  files and environment variables.
- Default configuration file locations vary between operating systems and package
  types.
- Configuration changes take effect after a node restart.
- Cluster name can be overridden via rabbitmq.conf.
- Cluster tags and node tags can be configured in rabbitmq.conf.
- Effective configuration can be inspected using rabbitmq-diagnostics environment
- 'Uses default configuration files: rabbitmq.conf, advanced.config'
- RabbitMQ uses a configuration file named rabbitmq.conf.
- RabbitMQ supports configuration via environment variables.
- Changes to rabbitmq.conf and advanced.config take effect after a node restart.
- Effective configuration is computed using the merging of rabbitmq.conf and advanced.config.
- To use encrypted values, a few steps must be taken.
- 'Effective configuration is computed using the following steps: rabbitmq.conf is
  translated into the internally used (advanced) config format. These configuration
  is merged into the defaults, advanced.config is loaded if present, and merged into
  the result of the step above.'
- The classic format is deprecated. Please prefer the new style config format in rabbitmq.conf.
- RabbitMQ provides a default configuration file named rabbitmq.conf.
- Effective configuration can be printed using the rabbitmq-diagnostics environment
  command.
- Cluster name is set to the name of the first node by default.
- Sensitive configuration values can be encrypted.
- Encrypted values can be specified in rabbitmq.conf and advanced.config.
- Cluster tags are arbitrary key-value pairs that describe a cluster.
- They allow deployments of RabbitMQ to conform to regulations in various countries
  requiring that no sensitive data should appear in plain text in configuration files.
- The passphrase doesn't have to be hardcoded in the configuration file, it can be
  in a separate file.
- RabbitMQ can also request an operator to enter the passphrase when it starts by
  using {passphrase, prompt}.
- Sensitive advanced.config and select rabbitmq.conf entries can be encrypted.
- Default settings are sufficient for development and QA environments.
- Effective configuration is computed using the steps outlined in the documentation.
- The passphrase doesn't have to be hardcoded in the configuration file, it can be
  in a separate file
- Effective configuration is computed using the merged values from rabbitmq.conf and
  advanced.config files.
- Configuration files take effect after a node restart.
- Nevertheless, they allow deployments of RabbitMQ to conform to regulations in various
  countries requiring that no sensitive data should appear in plain text in configuration
  files.
- The encryption mechanism uses PBKDF2 to produce a derived key from the passphrase.
- The default hash function is SHA512 and the default number of iterations is 1000.
- The default cipher is AES 256 CBC.
- RabbitMQ uses configuration files for server and plugin settings.
- Encrypted values allow deployments to conform to regulations.
- The config_entry_decoder.passphrase key controls the passphrase that RabbitMQ will
  use to decrypt the encrypted values.
- Values that we originally encrypted to be used advanced.config can be moved to rabbitmq.conf.
- The classic format is deprecated. Please prefer the new style config format.
- Cluster and node tags can be configured using rabbitmq.conf
- Cluster name defaults to the name of the first node in the cluster
- Cluster and node tags can be configured in rabbitmq.conf
- Default configuration settings can be modified in rabbitmq.conf
- Configuration changes take effect after a node restart
- Values of certain keys can be prefixed with `encrypted`.
- RabbitMQ configuration changes take effect after a node restart.
- Sensitive advanced.config and select rabbitmq.conf entries can be encrypted
- Encrypted configuration entries won't make the system perfectly secure
- Sensitive configuration entries can be encrypted to conform to regulations.
- Effective configuration can be verified using the rabbitmq-diagnostics environment
  command.
- If any of the values are overridden, their equivalents must be used when encrypting
  values using CLI tools.
- A RabbitMQ node can be configured using a number of mechanisms.
- The classic config format is deprecated. Please prefer the new style config format.
- --cipher, --hash and --iterations must match their counterparts un `config_entry_decoder`
- rabbitmq.conf and advanced.config changes take effect after a node restart.
- Windows service users will need to re-install the service if configuration file
  location or any values in `rabbitmq-env-conf.bat` changed.
- 'Set environment variables via command line, i.e. run commands like the following:
  set RABBITMQ_BASE=C:\Data\RabbitMQ'
- 'Most settings are configured using the first two methods: configuration files and
  environment variables.'
- RabbitMQ supports both modern and classic configuration formats.
- Changes in configuration files take effect after a node restart.
- When changing file or directory locations, it is important to make sure that they
  have sufficient permissions for RabbitMQ node OS process to read and write from.
- By default, RabbitMQ nodes configure runtime schedulers to disable the speculatively
  waiting.
- Most of the settings can be configured using environment variables.
- To disable crash dump files, set the ERL_CRASH_DUMP_BYTES environment variable to
  0.
- RabbitMQ nodes can be configured using configuration files or environment variables.
- RabbitMQ is compatible with any AMQP-1.0-compliant client library.
- Applications are strongly encouraged to use RabbitMQ AMQP 1.0 client libraries for
  the best experience.
- Cluster name is set to the name of the first node in the cluster.
- Libraries translate the API calls into the address format v2.
- Connections are expected to be long-lived objects, applications should avoid connection
  churn.
- Setting the stream filter value in a message annotation
- An application can still close a consumer without pausing it, at the risk of processing
  the same messages several times.
- Sensitive advanced.config and select rabbitmq.conf entries (e.g. password, URL containing
  credentials) can be encrypted.
- Default limit value on most Linux distributions is usually 1024, which is very low
  for a messaging broker (or generally, any data service).
- Stream filter values must be set as annotations in messages.
- RabbitMQ packages or nodes will not create any configuration files.
- Environment variables can be used to override the location of the configuration
  file.
- Applications must settle messages or they will run out of credits and the broker
  will stop dispatching messages to them.
- Only quorum queues support the modification of message annotations with the modified
  outcome.
- Libraries use the ANONYMOUS SASL authentication mechanism by default.
- Increase statistics emission interval from default 5 seconds to 15 or 30 seconds.
- Speculative busy waiting is controlled using the +sbwt and related runtime flags.
- It is difficult to completely avoid duplicate messages, this is why processing should
  be idempotent.
- RabbitMQ is not a JMS provider but includes a plugin needed to support the JMS Queue
  and Topic messaging models.
- The plugin and the JMS client are meant to work and be used together.
- The library is open-source and dual-licensed under the Apache License v2 and the
  Mozilla Public License v2.0.
- RabbitMQ release artifacts are signed using GnuPG.
- Signature files use the .asc extension.
- Applications must close the environment to release its resources when it exits.
- Direct reply-to eliminates the need for a reply queue.
- The RPC client must consume in the automatic acknowledgement mode.
- Applications should close the environment to release its resources when it exits.
- A load balancer in front of RabbitMQ would make it virtually impossible to use this
  exchange type effectively
- Messages published on the node with no consumers will be dropped
- A protocol extension to AMQP 0-9-1 has been introduced, enabling the broker to notify
  the client when a connection is blocked or unblocked.
- Use policies to define alternate exchanges.
- The 'guest' user can only connect from localhost.
- It is highly recommended to pre-configure a new user with a generated username and
  password.
- By default, the guest user is prohibited from connecting from remote hosts; it can
  only connect over a loopback interface (localhost).
- Production environments should not use the default user.
- Create new user accounts with generated credentials.
- Create new user accounts with generated credentials instead.
- Default user credentials can be encrypted.
- Changes to user permissions may only take effect when the user reconnects.
- Users in LDAP must exist in the internal database as well, but do not need a password
  there.
- The client library is named `amqp_client` and distributed via Hex.pm together with
  its key dependency, `rabbit-common`.
- Inspecting server logs is crucially important when investigating authentication-related
  issues.
- A failed authentication attempt will result in a server log message indicating invalid
  credentials.
- To verify a signature, use gpg --verify followed by the signature file and the artifact.
- Default user cannot connect from remote hosts for a reason. Enabling such connections
  can dramatically decrease the security of the cluster. Consider creating a unique
  user with generated credentials for all production clusters.
- If credentials are reported as correct, connections from localhost succeed but remote
  connections fail, the issue is default user connectivity limitations.
- Ensure JAVA_HOME is correctly set and that the rabbitmq-java-client and rabbitmq_codegen
  directories are in the same directory.
- The 'guest' user can only connect from localhost by default.
- The 'guest' user can only connect from localhost
- Production environments should not use the default user. Create new user accounts
  with generated credentials instead.
- The RPC client must use the same connection and channel for both consuming from
  amq.rabbitmq.reply-to and for publishing the request message.
- default is 'guest', and its access is limited to localhost only.
- A load balancer in front of RabbitMQ would make it virtually impossible to use this
  exchange type effectively.
- The design of this exchange type assumes that there are online consumers on each
  of the nodes in the cluster. Otherwise, messages published on the node with no consumers
  will be dropped.
- Applications must opt-in to use a different authentication mechanism such as EXTERNAL.
- Uses capabilities table in client-properties to receive blocked connection notifications
- Default user 'guest' can only connect from localhost
- It is highly recommended to create a new user with generated credentials instead
  of using 'guest'
- Default user credentials can be overridden in configuration file.
- If security is a serious concern, you should probably combine the use of this feature
  with TLS-enabled connections, possibly with peer certificate chain verification
  of clients performed by the server.
- Default user cannot connect from remote hosts for a reason. Enabling such connections
  can dramatically decrease the security of the cluster.
- guest user can only connect from localhost
- The default user 'guest' can only connect from localhost.
- Remote connections using the 'guest' user will be refused.
- Highly recommended to pre-configure a new user with generated credentials
- The most common scenario with authorization failures is when a user was created
  but not granted permissions for the virtual host the client tries to connect to.
- Default user credentials can also be encrypted.
- Default user can only connect from localhost
- It is highly recommended to pre-configure a new user with a generated username and
  password
- For production environments, remove the ANONYMOUS mechanism.
- Production environments should create new users with generated credentials instead
  of using the default user
- A separate user with generated credentials must be created for clients connecting
  from remote hosts.
- For production environments, remove anonymous login mechanism.
- Highly recommended to pre-configure a new user with a generated username and password
- Remote connections that use the default user will be refused
- Default user cannot connect from remote hosts for a reason.
- Enabling such connections can dramatically decrease the security of the cluster.
- Consider creating a unique user with generated credentials for all production clusters.
- Inspecting server logs is crucially important when investigating authorization-related
  issues.
- Default user 'guest' can only connect from localhost.
- Highly recommended to create a new user with generated credentials instead of using
  the default user.
- Assumes a Linux shell.
- Enabling remote connections for the guest user is highly discouraged as it dramatically
  decreases the security of the system.
- It is highly recommended to pre-configure a new user with generated credentials
- Default user can only connect from localhost; remote connections will be refused.
- Highly recommended to pre-configure a new user with a generated username and password
  or delete the guest user.
- Anonymous login should be removed in production environments.
- Applications must opt-in to use a different authentication mechanism such as EXTERNAL
- Creating a unique user with generated credentials is recommended for production
  environments
- Production environments should not use the default user
- RabbitMQ tools use a shared secret authentication mechanism.
- RabbitMQ node logs its effective user's home directory location early on boot.
- An incorrectly placed cookie file or cookie value mismatch are the most common scenarios
  for authentication failures.
- Using the default user in production is highly discouraged
- default is "guest", and its access is limited to localhost only.
- 'Most settings are configured using the first two methods: Configuration files and
  Environment Variables.'
- The guest user can only connect from localhost.
- For production environments, remove the ANONYMOUS authentication mechanism.
- Default configuration file is named rabbitmq.conf
- Environment variable interpolation is supported
- Default cluster name is set to the name of the first node in the cluster.
- The 'guest' user can only connect from localhost, remote connections will be refused.
- By default, the 'guest' user can only connect from localhost.
- Environment variables can configure server parameters.
- Some settings in RabbitMQ can be tuned using environment variables, most are configured
  using a main configuration file named rabbitmq.conf.
- A common naming practice uses numerical prefixes in filenames to make it easier
  to reason about the order, or make sure a 'defaults file' is always loaded first,
  regardless of how many extra files are generated at deployment time.
- Environment variables used by the service would not be updated otherwise.
- Changing configuration file location or any values in rabbitmq-env-conf.bat requires
  re-installation of the service.
- This user will only be created on first node boot.
- An additional configuration file can be used to configure settings that cannot be
  expressed in the main file's configuration format.
- Most settings are configured using the configuration file named rabbitmq.conf.
- Cluster tags can be configured using rabbitmq.conf.
- CLI tools use a shared secret authentication mechanism.
- Environment variable interpolation in `rabbitmq.conf` is supported.
- 'Most settings are configured using the first two methods: Configuration File(s)
  and Environment Variables.'
- 'Most settings are configured using the first two methods: Configuration Files and
  Environment Variables.'
- Some settings in RabbitMQ can be tuned using environment variables.
- If rabbitmq-env.conf doesn't exist, it can be created manually in the location specified
  by the RABBITMQ_CONF_ENV_FILE variable.
- Windows service users will need to re-install the service if configuration file
  location or any values in rabbitmq-env-conf.bat have changed.
- In the context of deployment automation this means that environment variables such
  as RABBITMQ_BASE and RABBITMQ_CONFIG_FILE should ideally be set before RabbitMQ
  is installed.
- The classic format is deprecated.
- The use of classic config format should only be limited to the advanced.config file.
- By default, cluster name is set to the name of the first node in the cluster.
- Uses a directory of .conf files loaded in alphabetical order
- Configuration affects many areas of the system, including plugins
- Sensitive configuration entries can be encrypted
- For production deployment tuning, configuration is necessary.
- Environment variables should be set before RabbitMQ is installed.
- Environment variables can be used to configure certain server parameters.
- Users and deployment tool should use the specified locations when creating the files.
- Node tags can be preconfigured via rabbitmq.conf.
- Most are configured using a main configuration file named rabbitmq.conf.
- The active configuration file can be verified by inspecting the RabbitMQ log file.
- On Windows systems, it is named rabbitmq-env-conf.bat.
- Global runtime parameters are virtual-host-independent
- Configuration affects many areas of the system.
- Changes in `rabbitmq.conf` and `advanced.config` take effect after a node restart.
- Environment variables should ideally be set before RabbitMQ is installed.
- Environment variable interpolation supported in rabbitmq.conf
- Uses environment variable interpolation in rabbitmq.conf.
- In the context of deployment automation, environment variables such as RABBITMQ_BASE
  and RABBITMQ_CONFIG_FILE should ideally be set before RabbitMQ is installed.
- Sensitive configuration entries can be encrypted using rabbitmqctl.
- RabbitMQ config file changes take effect after a node restart.
- Sensitive configuration entries can be encrypted for security.
- Consult the log file and/or management UI for config file location.
- Effective configuration is computed by merging `rabbitmq.conf` and `advanced.config`.
- Configuration values can be encrypted for security
- Most settings are configured using the configuration file and environment variables.
- cluster_name is set to the name of the first node in the cluster by default.
- Certain server parameters can be configured using environment variables.
- Most settings are configured using configuration files or environment variables.
- Environment variables such as RABBITMQ_BASE and RABBITMQ_CONFIG_FILE should ideally
  be set before RabbitMQ is installed.
- Consult the log file and/or management UI to verify config file location.
- RabbitMQ displays cluster name value in the management UI.
- Most settings are configured using a configuration file.
- RabbitMQ config file should be set before RabbitMQ is installed.
- On Windows systems, the configuration file is named rabbitmq-env-conf.bat.
- The classic format is deprecated. Please prefer the new style config format in 'rabbitmq.conf'.
- The default hash function is SHA512 and the default number of iterations is 1000.
  The default cipher is AES 256 CBC.
- Default config file locations vary between operating systems and package types.
- This guide covers a number of topics related to configuration.
- Sensitive configuration values can be encrypted using rabbitmqctl.
- Encrypted values won't make the system perfectly secure but help conform to regulations.
- Windows service users will need to re-install the service if configuration file
  location or any values in `rabbitmq-env-conf.bat` have changed.
- Windows service users will need to re-install the service if configuration file
  location or any values in 'rabbitmq-env-conf.bat' have changed.
- Sensitive advanced.config and rabbitmq.conf entries can be encrypted.
- Default limit value on most Linux distributions is usually 1024, which is very low
  for a messaging broker.
- Configuration file location or any values in rabbitmq-env-conf.bat have changed.
- Sensitive configuration values can be encrypted for security.
- Most settings are configured using configuration files and environment variables.
- The environment variable takes precedence over the configuration file.
- RabbitMQ nodes can log to multiple outputs.
- The default log level is info.
- 'To set log level to debug on a running node: rabbitmqctl -n rabbit@target-host
  set_log_level debug.'
- 'To set the level back to info: rabbitmqctl -n rabbit@target-host set_log_level
  info.'
- RabbitMQ can also request an operator to enter the passphrase when it starts by
  using `{passphrase, prompt}`.
- RabbitMQ supports logging to multiple outputs including file, console, and syslog.
- Default log output is to a file unless explicitly configured otherwise.
- The environment variable RABBITMQ_LOGS takes precedence over the configuration file.
- If only console logging is activated, this command will fail with a "file not found"
  (`enoent`) error.
- Uses configuration files rabbitmq.conf and advanced.config for settings
- Environment variables can be used to configure settings
- Uses log.exchange configuration key to activate log forwarding to amq.rabbitmq.log
- Virtual host creation involves a blocking cluster-wide transaction.
- When a number of virtual hosts is created in a loop, CLI and HTTP API clients can
  outpace the actual rate of virtual host creation and experience timeouts.
- Cluster tags can be used to attach deployment-specific information.
- Virtual hosts are created and deleted using CLI tools or the HTTP API.
- Environment variables like RABBITMQ_BASE and RABBITMQ_CONFIG_FILE should be set
  before RabbitMQ is installed.
- Configuration file paths must exclude certain characters.
- Deleting a virtual host will permanently delete all entities (queues, exchanges,
  bindings, policies, permissions, etc) in it.
- This soft limit cannot go higher than the hard limit (which defaults to 4096 in
  many distributions).
- SHA-256 is used by default for password hashing.
- Passwordless users can be created for authentication mechanisms that support it.
- RabbitMQ supports multiple authentication mechanisms.
- SHA-256 is used by default.
- RabbitMQ supports multiple authentication mechanisms
- SHA-256 is used by default for password hashing
- Credential validators have limitations with config file grammar and shell interpretation
- RabbitMQ supports JWT tokens compliant with the Rich Authorization Request extension.
- Logging to console is activated by setting log.console to true.
- LDAP plugin must be enabled to use LDAP for authentication and authorization.
- TLS client peer verification is enabled by default starting with Erlang 26.
- If logging to a file plus another output is necessary, a file output must be explicitly
  listed next to the other desired log outputs.
- LDAP support cannot be used on Erlang installations where the library is not available.
- The plugin primarily targets OpenLDAP and Microsoft Active Directory.
- Logging in JSON format is supported.
- LDAP plugin is necessary for authentication and authorization.
- Requires the installation of the Erlang 'eldap' library.
- LDAP plugin must be enabled for authentication and authorisation.
- LDAP servers typically use port 389 by default.
- Log files is a very important aspect of system observability.
- Default value of auth_ldap.other_bind is as_user.
- Default value of auth_ldap.dn_lookup_bind is as_user.
- This setting can lead to incomplete log messages and should only be used as a last
  resort measure.
- Using LDAP for authentication and/or authorisation introduces another moving part
  into the system.
- The environment variable RABBITMQ_LOGS cannot be combined with the configuration
  file settings.
- This plugin provides a way to cache authentication and authorization backend results
  for a configurable amount of time.
- Cache expiration is currently time-based.
- 'Multi-line messages can be truncated to a single line: This setting can lead to
  incomplete log messages and should only be used as a last resort measure when overriding
  log format is a hard requirement of log collection tooling.'
- AMQP 0-9-1 requires brokers to close the TCP connection if an authentication failure
  occurs during connection establishment.
- The broker will report failures differently depending on the presence of the authentication_failure_close
  capability.
- Logging feature is deactivated by default.
- Virtual hosts are created using CLI tools or an HTTP API endpoint.
- A newly created vhost will have a default set of exchanges but no other entities
  and no user permissions.
- Policies can change at any time.
- Operator policies can be modified in a number of ways, very similarly to regular
  policies
- If a virtual host is created via a definition file, adding a new metadata key, "protected_from_deletion",
  that is set to true, will mark the virtual host as protected when it is created.
- Policies is a declarative, virtual host-scoped mechanism for dynamically reconfiguring
  optional arguments for queues, exchanges, streams, and some plugins.
- SHA-256 is used by default. More algorithms can be provided by plugins.
- removes all keys related to classic queue mirroring (that feature was removed in
  RabbitMQ 4.x) from all policy definitions in virtual host vh-1
- RabbitMQ expects the audience in the token to match resource_server_id.
- Uses rabbitmqadmin CLI for managing policies
- Operator policies enforce limits but try not to override user-provided policies
- The default configuration allows all users to access all objects in all vhosts,
  but does not make them administrators.
- LDAP plugin is usually combined with rabbitmq_auth_backend_cache for improved latency.
- LDAP servers typically use port 389.
- Since queue (stream) type is set at declaration time and cannot be changed, policies
  cannot be used to configure queue type, by design.
- When multiple policies match an entity and they all have equal priorities, the effective
  one will be chosen undeterministically. Such cases should be avoided by paying attention
  to what priorities various policies use.
- Uses simple bind for authentication
- Policies can match only queues of a specific type, all queues, only exchanges, or
  all queues and exchanges.
- Operator policies enforce limits but try to not override user-provided policies
  where possible.
- Negative authentication and/or authorization decisions are not cached by default.
- No policies in the target virtual host have matched the target object if the results
  are empty.
- RabbitMQ offers explicit authentication failure notifications for clients that advertise
  their capacity to receive such notifications.
- Limits can be configured using CLI tools or the HTTP API.
- Policies can be used to configure federation, alternate exchanges, dead lettering,
  per-queue TTLs, and queue length limits.
- Policies cannot be used to configure queue type or maximum number of priorities.
- Operator policies can change queue attributes unexpectedly.
- Modification of operator policies via the HTTP API can be disabled.
- Policies cannot be used to configure queue type by design.
- Parameters can be set, cleared and listed via HTTP API.
- Khepri became the default backend as of RabbitMQ 4.2.0.
- Mnesia support will be removed in a future version.
- Definitions are stored in an internal database and replicated across all cluster
  nodes.
- Modern releases support definition import directly in the core, without the need
  to preconfigure the management plugin.
- removes all keys related to classic queue mirroring (that feature was removed in
  RabbitMQ 4.x)
- Requires management plugin to be enabled
- Networking is a broad topic. There are many configuration options that can have
  positive or negative effect on certain workloads.
- Operator policies can unexpectedly change queue attributes and enforce limits.
- Proxy protocol is turned off by default and needs to be turned on for individual
  protocols supported by RabbitMQ.
- When proxy protocol is turned on, clients won't be able to connect to RabbitMQ directly
  unless they themselves support the protocol.
- This particular configuration only makes sense for single-node clusters.
- Policies can change at any time and apply to queues, exchanges, and streams.
- Networking is a broad topic with many configuration options.
- Operator policies can unexpectedly change queue attributes and semantics.
- It is possible to use IPv6 for inter-node and CLI tool communication but use IPv4
  for client connections or vice versa.
- Using the same IP version (e.g. IPv6) across the board or a dual stack setup is
  recommended.
- Policies are used for configuring certain properties of groups of queues, streams,
  exchanges.
- When using a low number of clients, new connection rate is very unevenly distributed.
- When the number of clients reaches tens of thousands or more, it is important to
  ensure the server can accept inbound connections.
- When overriding the max open file handle limit to a higher value, the `ERL_MAX_PORTS`
  environment variable must be overridden accordingly.
- Lowering TCP buffer sizes will result in a proportional throughput drop, so an optimal
  value between throughput and per-connection RAM use needs to be found for every
  workload.
- Setting send and receive buffer sizes to different values is dangerous and is not
  recommended. Values lower than 8 KiB are not recommended.
- Policies use regular expressions for matching.
- This guide focuses on Linux when covering OS-specific subjects, as it is the most
  common platform RabbitMQ is deployed on.
- Some optional arguments cannot be configured using a policy.
- Operator policies are used to enforce certain policy attributes.
- To verify conflicting priorities, list the policies in the virtual host.
- On MacOS systems with Application Firewall enabled, Erlang runtime processes must
  be allowed to bind to ports and accept connections.
- Policies are designed for parameters that can change at runtime.
- Every cluster member must be able to resolve hostnames of every other cluster member,
  its own hostname, as well as machines on which command line tools such as rabbitmqctl
  might be used.
- Using such generated cookie files are appropriate in development environments only.
- Operator policies require careful management to avoid conflicts
- Multiple policies with equal priorities can lead to non-deterministic behavior
- When the cookie is misconfigured (for example, not identical), RabbitMQ nodes will
  log errors such as 'Connection attempt from disallowed node'.
- RabbitMQ clustering has several modes of dealing with network partitions, primarily
  consistency oriented.
- RabbitMQ nodes must be configured in a certain way and satisfy a number of requirements
  such as open port access.
- 'Odd numbers of cluster nodes are highly recommended: 1, 3, 5, 7, etc.'
- Two node clusters are highly recommended against as they cannot achieve a majority.
- Quorum queues allow queue contents to be replicated across multiple cluster nodes.
- Using client-local strategy is usually a good choice if connections are evenly distributed.
- A node will try to contact that peer 10 times by default, with 30 second response
  timeouts.
- Use the Parallel pod management policy when running RabbitMQ on Kubernetes.
- A node that was removed from the cluster when stopped with rabbitmqctl stop_app
  must be either reset or decomissioned.
- Multiple policies with equal priorities may lead to non-deterministic policy selection.
- In some cases the last node to go offline cannot be brought back up.
- It can be removed from the cluster using the forget_cluster_node command.
- Alternatively force_boot command can be used on a node to make it boot without trying
  to sync with any peers.
- Policies are virtual host-scoped, that is, belong to a particular virtual host and
  only apply to the objects in that virtual host.
- Nodes must be configured in a certain way and satisfy a number of requirements such
  as open port access.
- RabbitMQ nodes must be able to resolve hostnames of every other cluster member.
- Clusters are highly recommended to have an odd number of nodes.
- Two node clusters are highly recommended against due to connectivity loss issues.
- Quorum queues require a majority of replicas to be online for operations.
- A node that was removed from the cluster when stopped must be either reset or decomissioned.
- Operator policies can change queue attributes unexpectedly and should be used to
  enforce limits.
- Resetting the node removes all resources and data that were previously present on
  that node.
- Virtual-scoped parameters are used by the federation and shovel plugins.
- Nodes that have been joined to a cluster can be stopped at any time.
- If the majority of nodes is still online after a node is stopped, this does not
  affect the rest of the cluster.
- Cluster tags are stored in a global parameter named 'cluster_tags'.
- Parameters can be set using rabbitmqctl or rabbitmqadmin.
- Mnesia will still be supported.
- RabbitMQ nodes must be able to resolve hostnames of every other cluster member
- Every cluster node must have the same Erlang cookie
- Definitions can be exported to a file and then imported into another cluster or
  used for schema backup or data seeding.
- When definitions are exported for just one virtual host, some information will be
  excluded from the exported file.
- Odd numbers of cluster nodes are highly recommended
- Two node clusters are highly recommended against
- 'Queue leader distribution can be controlled in three ways: by setting queue-leader-locator,
  by setting queue_leader_locator in the configuration file, or by setting x-queue-leader-locator
  as an optional queue argument'
- Using client-local strategy is usually a good choice if the connections that declare
  queues are evenly distributed between nodes
- The disadvantage of the balanced strategy is that the connection that declared the
  queue may not have the best possible performance when using this queues
- For backwards compatibility, queue-master-locator, x-queue-master-locator, and queue_master_locator
  are still supported by classic queues, but these are deprecated
- Definitions are considered sensitive information.
- Use HTTPS when possible.
- When proxy protocol is turned on and connections go through a compatible proxy,
  no action or modifications are required from client libraries.
- To reset a running and responsive node, first stop RabbitMQ on it using rabbitmqctl
  stop_app and then reset it using rabbitmqctl reset.
- Uses RabbitMQ configuration files for settings
- Networking settings can be OS-specific
- Such configurations can be hard to troubleshoot and reason about, so using the same
  IP version across the board or a dual stack setup is recommended.
- All RabbitMQ brokers start out as running on a single node.
- Nodes can be joined into clusters, and subsequently turned back into individual
  brokers again.
- Clusters are recommended to have an odd number of nodes (1, 3, 5, 7, etc.)
- Two node clusters are highly recommended against due to inability to form a consensus.
- Four or six node clusters have the same availability characteristics as three and
  five node clusters.
- RabbitMQ brokers tolerate the failure of individual nodes.
- Nodes can be stopped and started at will as long as they can contact a known cluster
  member.
- Uses IPv6 for inter-node communication - CLI tools won't connect to nodes not using
  IPv6.
- When overriding the max open file handle limit to a higher value, the ERL_MAX_PORTS
  environment variable must be overridden accordingly.
- Users running RabbitMQ on Kubernetes must also consult the following section that
  explains how to avoid a well known cluster restart deadlock scenario specific to
  Kubernetes.
- A stopping node picks an online cluster member to sync with after restart.
- Nodes will try to contact a known peer for up to 5 minutes by default.
- Nodes will perform hostname resolution early on node boot.
- Every cluster member must be able to resolve hostnames of every other cluster member.
- RabbitMQ clients communicate over TCP-based protocols.
- Odd numbers of cluster nodes are highly recommended.
- Two node clusters are highly recommended against.
- Using the same IP version across the board or a dual stack setup is recommended.
- Once instructed to use IPv6, CLI tools won't be able to connect to nodes that do
  not use IPv6 for inter-node communication.
- To avoid data loss it's crucial to set up a fixed and resolvable hostname.
- Whenever the hostname changes RabbitMQ node must be restarted.
- A better solution is to use DNS, for example, Amazon Route 53 if running on EC2.
- RabbitMQ nodes must be configured to satisfy a number of requirements such as open
  port access.
- Nodes must be reset before joining a cluster, which removes all existing resources
  and data.
- Cluster nodes must come online within 5 minutes by default after a node restart.
- Checks that explicitly or implicitly assume a fully booted node that's rejoined
  its cluster peers will fail and block further node deployments.
- One health check that does not expect a node to be fully booted and have schema
  tables synced is rabbitmq-diagnostics ping.
- RabbitMQ nodes use hostnames to communicate with each other.
- RabbitMQ nodes must be configured to resolve hostnames of every other cluster member.
- Nodes must be configured to satisfy clustering requirements such as open port access.
- Clusters are meant to be used across LAN. It is not recommended to run clusters
  that span WAN.
- Quorum queues and streams require a majority of replicas online.
- Using client-local strategy is usually a good choice if the connections that declare
  queues are evenly distributed between nodes.
- RabbitMQ nodes must have unique node names.
- All nodes in a cluster must be able to resolve hostnames of every other cluster
  member.
- To reset a running and responsive node, first stop RabbitMQ on it using `rabbitmqctl
  stop_app` and then reset it using `rabbitmqctl reset`.
- For Kubernetes users, set DNS cache interval for CoreDNS to a value in the 5-10
  second range.
- 'Odd numbers of cluster nodes are highly recommended: 1, 3, 5, 7 and so on.'
- The disadvantage of the balanced strategy is that the connection that declared the
  queue may not have the best possible performance.
- A node that was removed from the cluster when stopped with rabbitmqctl stop_app
  must be either reset or decomissioned. If started without a reset, it won't be able
  to rejoin its original cluster.
- 'Odd numbers of cluster nodes are highly recommended: 1, 3, 5, 7, and so on.'
- Two node clusters are highly recommended against since it's impossible for cluster
  nodes to identify a majority.
- For backwards compatibility, queue-master-locator, x-queue-master-locator, and queue_master_locator
  are still supported by classic queues but are deprecated.
- If the last node to go offline cannot be brought back up, it can be removed from
  the cluster using the forget_cluster_node command.
- Use force_boot command on a node to make it boot without trying to sync with any
  peers.
- Reset a running and responsive node by stopping RabbitMQ and then using rabbitmqctl
  reset.
- A node that was removed from the cluster when stopped with rabbitmqctl stop_app
  must be either reset or decommissioned.
- Nodes must resolve hostnames of every other cluster member.
- Use an odd number of nodes for clustering.
- Clustering is meant to be used across LAN. It is not recommended to run clusters
  that span WAN.
- Queue leaders should be reasonably evenly distributed across cluster nodes.
- A node must be reset before it can join an existing cluster.
- RabbitMQ nodes and CLI tools use a cookie to determine whether they are allowed
  to communicate with each other.
- Nodes can be started and stopped at will, as long as they can contact a cluster
  member node known at the time of shutdown.
- Users running RabbitMQ on Kubernetes must consult specific sections to avoid cluster
  restart deadlock scenarios.
- The cluster peer discovery mechanisms support node health checks and forced removal
  of nodes not known to the discovery backend.
- When target node is not running, it can still be removed from the cluster using
  rabbitmqctl forget_cluster_node.
- Alternatively force_boot rabbitmqctl command can be used on a node to make it boot
  without trying to sync with any peers.
- Nodes must be configured in a certain way and satisfy requirements such as open
  port access.
- All data/state required for the operation of a RabbitMQ broker is replicated across
  all nodes.
- Clusters are set up by re-configuring existing RabbitMQ nodes into a cluster configuration.
- Use `forget_cluster_node` command to remove nodes from the cluster.
- Use `force_boot` command to boot a node without syncing with peers.
- To reset a running node, use `rabbitmqctl stop_app` followed by `rabbitmqctl reset`.
- For Kubernetes users, the DNS cache interval for CoreDNS should be set to a value
  in the 5-10 second range.
- A messaging client can connect to any node and perform any operation.
- In case of a node failure, clients should be able to reconnect to a different node.
- Every queue and stream has a primary replica called the leader.
- Queue leader distribution can be controlled by setting queue-leader-locator.
- In some cases the last node to go offline cannot be brought back up. It can be removed
  from the cluster using the `forget_cluster_node` command.
- Uses Erlang cookie for authentication between nodes
- Every cluster node must have the same cookie
- Node failure handling allows for individual node failures.
- Quorum queues allow for parallel replication as long as a majority of replicas are
  online.
- RabbitMQ clustering is meant to be used across LAN, not WAN.
- Nodes must be able to resolve hostnames of every other cluster member.
- Erlang cookie must be identical across all nodes.
- Upon restart the node will try to contact that peer 10 times by default, with 30
  second response timeouts.
- If the peer does not become available, the restarted node will give up and voluntarily
  stop.
- Nodes must be configured to satisfy a number of requirements such as open port access.
- Resetting a node will delete all of its data, cluster membership information, configured
  runtime parameters, users, virtual hosts and any other node data.
- Two node clusters are highly recommended against as they cannot achieve consensus.
- Using 'client-local' strategy is usually a good choice if connections that declare
  queues are evenly distributed.
- For backwards compatibility, 'queue-master-locator', 'x-queue-master-locator' and
  'queue_master_locator' are still supported but deprecated.
- If the hostname changes, a new empty database is created.
- Using rabbit@localhost as the broker nodename will not work for clustering.
- Investigate setting the environment variable RABBITMQ_USE_LONGNAME=true if using
  the full hostname.
- Nodes in a cluster must be configured to satisfy a number of requirements such as
  open port access.
- RabbitMQ nodes can communicate with each other using a shared secret called the
  Erlang cookie.
- Nodes will try to contact a known peer for up to 5 minutes (by default).
- Users running RabbitMQ on Kubernetes must consult specific sections to avoid a known
  cluster restart deadlock scenario.
- 'Queue leader distribution can be controlled in three ways: a policy, by setting
  queue-leader-locator, by the configuration file, or by setting the optional queue
  argument.'
- One health check that does not expect a node to be fully booted and have schema
  tables synced is 'rabbitmq-diagnostics ping'.
- To reset a running and responsive node, stop RabbitMQ using `rabbitmqctl stop_app`
  and then reset it using `rabbitmqctl reset`.
- A cluster of nodes must maintain resolvable hostnames to communicate.
- Whenever the hostname changes, RabbitMQ node must be restarted.
- 'All nodes in a RabbitMQ cluster are equal peers: there are no special nodes in
  RabbitMQ core.'
- Nodes must be reset before joining a cluster.
- For backwards compatibility, some options are deprecated.
- Nodes must be configured to satisfy requirements for clustering, such as open port
  access.
- All nodes in a RabbitMQ cluster are equal peers.
- All RabbitMQ brokers start out as running on a single node. These nodes can be joined
  into clusters, and subsequently turned back into individual brokers again.
- Erlang cookie generation should be done at cluster deployment stage, ideally using
  automation and orchestration tools.
- rabbit@rabbit2 retains the residual state of the cluster
- rabbit@rabbit1 and rabbit@rabbit3 are freshly initialised RabbitMQ brokers
- For backwards compatibility, queue-master-locator and related settings are still
  supported but deprecated.
- Use an odd number of nodes in a cluster
- Two-cluster nodes are strongly discouraged
- Resetting a node will delete all of its data, cluster membership information, configured
  runtime parameters, users, virtual hosts and any other node data. It will also alter
  its internal identity.
- Non-replicated queue contents on a reset node will be lost.
- Nodes can have a firewall enabled on them.
- Configurable limits are a protection mechanism that allows cluster operators to
  prevent applications from using enough resources to affect other applications or
  cluster stability.
- RabbitMQ nodes must be configured to satisfy clustering requirements such as open
  port access.
- Modern versions of RabbitMQ (3.8.0+) only support backup restore from disk when
  they are restored to a RabbitMQ node with exactly the same node name as the node
  the data was backed up from.
- Node renaming is not supported if either quorum queues or streams are used.
- It is better to rely on other disaster recovery solutions, or use a separate standby
  cluster for disaster recovery.
- Nodes will try to contact that peer 10 times by default, with 30 second response
  timeouts.
- The window of time for nodes to come online can be adjusted using configuration
  settings.
- Note that `rabbit@rabbit2` retains the residual state of the cluster, whereas `rabbit@rabbit1`
  and `rabbit@rabbit3` are freshly initialised RabbitMQ brokers.
- This is usually only necessary if the last node to shut down or a set of nodes will
  never be brought back online.
- No colocation with other data services (e.g. data stores) or disk, network I/O heavy
  applications
- RabbitMQ was not designed to run in environments with a single CPU core, or being
  colocated with other disk and network I/O-heavy tools.
- Consider using independent clusters for separate parts of the system where possible.
- It is strongly discouraged to use two-cluster nodes.
- Cluster Operator does not support disabling any RabbitMQ feature flags.
- Queue leader distribution can be controlled in three ways.
- When the Erlang runtime system exits abnormally, a file named erl_crash.dump is
  written to the directory where RabbitMQ was started from.
- The termination reason will be available within the first few lines, starting with
  Slogan.
- Node health checks and forced removal of nodes is opt-in and deactivated by default.
- RabbitMQ nodes address each other using a node name, a combination of a prefix and
  domain name.
- The management plugin can collect metrics and display them in the UI.
- The Prometheus plugin is recommended for production environments.
- Using 'client-local' strategy is usually a good choice if the connections that declare
  queues are evenly distributed between nodes.
- Use the Prometheus plugin for production monitoring
- Management plugin is suitable for development environments
- A node that was removed from the cluster when stopped with rabbitmqctl stop_app
  must be either reset or decommissioned. If started without a reset, it won't be
  able to rejoin its original cluster.
- Health checks can be used to both assess the state and liveness of a node but also
  as readiness probes by deployment automation and orchestration tools, including
  during upgrades.
- The health checks can be used selectively and combined.
- Earlier versions of RabbitMQ used an intrusive health check that has since been
  deprecated and should be avoided.
- This health check is long deprecated and in modern versions it is a no-op
- Use 'forget_cluster_node' command to remove node from cluster if it cannot be brought
  back up
- Use 'force_boot' command on a node to make it boot without syncing with peers
- To reset a running node, stop it using 'rabbitmqctl stop_app' and then reset with
  'rabbitmqctl reset'
- Nodes must be configured to satisfy requirements for clustering such as open port
  access.
- RabbitMQ has inbuilt support for TLS for client connections and popular plugins.
- TLS settings can be configured using both the configuration file and classic config
  format.
- 'Two common approaches for client connections: Configure RabbitMQ to handle TLS
  or use a proxy for TLS termination.'
- Uses mutual TLS for authentication
- Hostname verification must be enabled separately using the ConnectionFactory#enableHostnameVerification()
  method
- Nodes must be configured in a certain way and satisfy requirements for clustering.
- RabbitMQ nodes must have the same Erlang cookie for communication.
- Clusters are recommended to have odd numbers of nodes (1, 3, 5, 7, etc.)
- Two node clusters are highly recommended against due to consensus issues.
- Modern .NET frameworks versions default to TLSv1.2
- In order to completely detach it from the cluster, such stopped node must be reset.
- Enabling peer verification involves configuring both client and server.
- Nodes in a cluster must be able to resolve hostnames of every other cluster member.
- Erlang cookie must be the same across all nodes for communication.
- Modern releases of the library will attempt to use the latest TLS version supported
  by the runtime.
- To mitigate the BEAST attack, disable TLSv1.0 support.
- Nodes must be configured in a certain way to form a cluster.
- Every cluster member must be able to resolve hostnames of every other member.
- It is highly recommended that both digitalSignature and keyEncipherment options
  are set for certificates.
- Using client-local strategy is usually a good choice if connections declaring queues
  are evenly distributed.
- RabbitMQ supports TLS for client connections and inter-node communication.
- RabbitMQ nodes use hostnames to communicate with each other. Therefore, all node
  names must be able to resolve names of all cluster peers.
- By default RabbitMQ names the database directory using the current hostname of the
  system. If the hostname changes, a new empty database is created.
- Disabling peer verification can make sense in certain environments (e.g., development).
- TLS 1.3 is the most recent and secure option.
- To verify provided TLS versions, use openssl s_client with an appropriate TLS version
  flag.
- All RabbitMQ brokers start out as running on a single node and can be joined into
  clusters.
- 'Cipher suite order is important: preferred suites should be listed first.'
- Different suites have different security and CPU load characteristics.
- 'All nodes in a cluster are highly recommended to run the same major version of
  Erlang: 26.2.0 and 26.1.2 can be mixed but 25.3.2.8 and 26.2.0 can potentially introduce
  breaking changes in inter-node communication protocols.'
- Uses TLS for secure connections
- Configurable limits are a protection mechanism that allows cluster operators to
  prevent such applications from using enough resources to affect other applications
  or cluster stability.
- Client's TCP connection can fail or experience serious packet loss that would make
  RabbitMQ nodes consider them unavailable.
- Some client libraries provide a mechanism for automatic recovery from network connection
  failures.
- RabbitMQ runs on the Erlang virtual machine and requires a compatible version of
  Erlang.
- oauth_enabled is a mandatory field
- oauth_client_id is a mandatory field. It is the OAuth Client Id associated with
  this RabbitMQ cluster in the OAuth Provider.
- oauth_scopes is a mandatory field which must be set at all times except in the case
  when OAuth providers automatically grant scopes associated to the oauth_client_id.
- For production environments, delete the default user (`guest`)
- It is recommended to use a separate user per application
- For production environments, it is almost always a good idea to disable anonymous
  logins
- Management UI requires authentication and authorization.
- The management UI and API are suitable for development but have limitations.
- Management UI is a public app and cannot securely store credentials such as the
  client_secret
- To switch to authenticate using OAuth 2 exclusively for management HTTP access,
  set management.disable_basic_auth to true
- 'Single node clusters can be sufficient when simplicity is preferred over everything
  else: development, integration testing and certain QA environments.'
- It is recommended to use clusters with an odd number of nodes (3, 5, 7, etc) so
  that when one node becomes unavailable, the service remains available and a clear
  majority of nodes can be identified.
- It is important to pick a partition handling strategy before going into production.
- With multi-node clusters, data locality becomes an important consideration.
- Environments that have to sustain a large number of concurrent client connections
  will benefit from more cluster nodes as long as the connections are distributed
  across them.
- Users who find themselves in need of clusters with node counts in double digits
  should consider using independent clusters for separate parts of the system where
  possible.
- It is recommended that servers use NTP or similar to ensure clocks remain in sync.
- Applications that use resources inefficiently or leak them will eventually affect
  the rest of the system.
- Messaging protocols generally assume long-lived connections.
- Short lived connections should be avoided when possible.
- High connection churn must be tuned to release TCP connections much quicker than
  kernel defaults.
- Some client libraries support automatic connection recovery after network failures.
- Channels also consume resources in both client and server.
- Polling consumers is a feature that application developers should avoid in most
  cases.
- Management UI access is controlled via the RabbitMQ permission tags system
- OAuth 2.0 authentication requires separate configuration
- Management UI is a public app and cannot securely store client_secret.
- To use OAuth 2 exclusively for management HTTP access, set management.disable_basic_auth
  to true.
- The Operator provides provisioning of single-node and multi-node RabbitMQ clusters
- It should provide reasonably safe defaults where possible
- RabbitMQ implements the OpenID Connect RP-Initiated Logout 1.0 specification to
  logout users from the management UI and from the OAuth Provider.
- The management UI has a number of limitations including basic user interface and
  only stores recent data.
- Uses OAuth 2.0 Authorization Code Flow for user authentication
- Management UI by default does not allow Basic Authentication when OAuth 2.0 is enabled
- Monitoring can be intrusive and increase load on the system being monitored.
- Health checks can be used to assess the state and liveness of a node.
- Management UI is a public app and cannot securely store credentials such as client_secret.
- The management plugin serves metrics via the HTTP API on port 15672 with Basic HTTP
  Authentication.
- Health checks are executed periodically by machines or interactively by operators.
- Higher stages of health checks have a higher probability of false positives.
- The management UI and its HTTP API is a built-in monitoring option for RabbitMQ.
- It is possible to use both HTTP and HTTPS on different ports
- OAuth 2.0 authentication is supported in the management UI.
- Management UI only accepts OAuth 2 authentication when OAuth is enabled.
- RabbitMQ supports TLS for client connections.
- Using a proxy for TLS termination is an option.
- Enabling peer verification is highly recommended in production environments.
- Mutual TLS authentication requires enabling peer verification on both RabbitMQ and
  client connections.
- The mirrors have significantly higher bandwidth quotas.
- There are no cipher suites supported by both TLSv1.3 and TLSv1.2.
- BEAST attack is a known vulnerability that affects TLSv1.0. To mitigate it, disable
  TLSv1.0 support.
- The packages may work on other RPM-based distributions if dependencies are satisfied
  but their testing and support is done on a best effort basis.
- This guide covers various topics related to TLS in RabbitMQ, with a focus on client
  connections.
- Uses mutual TLS authentication for peer verification.
- The RabbitMQ RPM package is suitable for both RHEL 9 (modern) and RHEL 8-based (older)
  distributions
- Standard Red Hat, CentOS Stream, and CentOS-derivative repositories provide Erlang
  versions that are typically out of date
- Uses TLS 1.2 for this connection
- Peer verification is required by default
- The node is set up to run as system user `rabbitmq`.
- Default user `guest` with password `guest` can only connect from localhost.
- 'The trust store plugin supports two sources of trusted leaf client certificates:
  A local directory with certificates and a set of HTTPS endpoints that follows a
  certain convention.'
- Permissions are verified at the time the queue is declared.
- A single message can be dead lettered multiple times.
- The array in both AMQP 1.0 and AMQP 0.9.1 is ordered by recency.
- The reason is a name describing why the message was dead-lettered.
- sets the interval to 60 seconds
- Connection errors are used to communicate unrecoverable errors.
- Errors that can be corrected and retried are communicated using channel exceptions.
- Automatic recovery from network connection failures is supported by some client
  libraries.
- must ONLY be enabled for new clusters before any clients declare durable subscriptions
- MQTT clients can specify a set of credentials when they connect, which can be a
  username and password pair, or a x.509 certificate.
- MQTT clients must authenticate with a username and password pair or a x.509 certificate
- Anonymous authentication is discouraged and comes with limitations
- oauth_client_id is a mandatory field
- oauth_scopes is a mandatory field which must be set at all times except in the case
  when OAuth providers automatically grant scopes associated to the oauth_client_id
- The default message store is rabbit_mqtt_retained_msg_store_dets.
- The use of anonymous connections is highly discouraged.
- Prefer external monitoring options where possible.
- From the OAuth 2.0 point of view, the management UI is a public app which means
  it cannot securely store credentials such as the client_secret.
- Uses OAuth 2.0 for authentication
- Management UI access requires user permissions
- Anonymous connections are discouraged and subject to limitations.
- For remote client connections, create new users with full permissions.
- OAuth 2.0 Authorization Code Flow is initiated from the management UI.
- management.oauth_enabled must be set to true to enable OAuth 2.
- To use OAuth 2 exclusively, set management.disable_basic_auth to true.
- MQTT plugin will listen on all interfaces on port 1883 by default
- Default user login/passcode is 'guest'/'guest'
- TLS must be configured in the broker for secure connections
- RabbitMQ 3.13.1 and earlier versions require the OpenId Connect Discovery endpoint
  `end_session_endpoint` returned for OAuth 2.0 authentication to work.
- If the OpenId Connect Discovery endpoint does not return an `end_session_endpoint`,
  you can configure it in the OAuth 2.0 authentication backend plugin.
- Management UI is a public app which cannot securely store credentials such as the
  client_secret.
- Management UI shows a button with the label Click here to login.
- The server must be configured with the TLS options fail_if_no_peer_cert set to true
  and verify set to verify_peer.
- The MQTT plugin creates a classic queue, quorum queue, or MQTT QoS 0 queue per MQTT
  subscriber.
- Anonymous connections are highly discouraged.
- Uses OAuth2 with Authorization Code Flow  requires user interaction
- Management UI can support both OAuth 2 and Basic Authentication
- Uses DETS (disk-based) store for retained messages
- Retained messages are node-local and not replicated
- now deprecated management.load_definitions
- Set management_agent.disable_metrics_collector = true to disable metrics collection
  in the Management plugin.
- MQTT packets and subscriptions with QoS 0 provide much better performance than QoS
  1.
- Decrease TCP buffer sizes as described in section TCP Listener Options.
- Less topic levels in an MQTT topic and MQTT topic filter perform better than more
  topic levels.
- In workloads with high subscription churn, increase Mnesia configuration parameter
  dump_log_write_threshold.
- When connecting many clients, increase the maximum number of Erlang processes and
  the maximum number of open ports.
- OAuth 2.0 support requires configuration in the management UI.
- OAuth 2.0 Authorization Code Flow is used to authenticate and authorize users.
- Basic authentication can be enabled or disabled depending on configuration.
- The RabbitMQ STOMP adapter relaxes the protocol on CONNECT and supports a number
  of non-standard headers on certain frames.
- Usually RabbitMQ nodes do not perform peer verification of HTTP API clients but
  it can be enabled if needed.
- OAuth 2.0 authentication requires minimum configuration to function.
- management.oauth_disable_basic_auth = true
- Plugins can be enabled or disabled using the rabbitmq-plugins CLI tool.
- The enabled plugins file contains a list of plugin names ending with a dot.
- See ./ssl#peer-verification for details.
- Disabling statistics reduces CPU resource consumption.
- 'Error: {:enabled_plugins_mismatch, ''/path/to/installation1/etc/rabbitmq/enabled_plugins'',
  ''/path/to/installation2/etc/rabbitmq/enabled_plugins''}'
- When a plugin must be disabled, it should be removed from the list and the node
  must be restarted.
- All plugins below have been discontinued.
- A poorly written plugin can result in the entire node becoming unavailable or misbehaving
- When testing with a RabbitMQ node and/or a real RabbitMQ client it is important
  to inspect logs for both server and client.
- If the node is configured to use TLS but a message about a TLS listener being enabled
  is not logged, it is possible that the configuration file was placed at an incorrect
  location and was not read by the broker or the node was not restarted after config
  file changes.
- Packages may work on other RPM-based distributions if dependencies are satisfied
  but their testing and support is done on a best effort basis.
- These repository mirrors only provide 64-bit x86 (amd64) packages of Erlang.
- The `crypto` module is missing in the Erlang/OTP installation used or it is out
  of date.
- The broker keyfile or certificate file is invalid.
- This error is related to client verification.
- This is a generic error that could have many causes.
- The server has tried verifying integrity of a piece of data it received and the
  check failed.
- Default user credentials can only be used when connecting to the broker as localhost
- Uses TLS for inter-node and CLI tool communication
- Shovels support AMQP 0.9.1 and AMQP 1.0 sources and destinations.
- A shovel behaves like a well-written client application, which connects to its source
  and destination, consumes and republishes messages.
- This is the recommended way of defining alternate exchanges.
- Policies can also be defined using the management plugin.
- RabbitMQ supports multiple authentication mechanisms using username/password pairs.
- Users can be created without a password for certain authentication mechanisms.
- Hardcoded x-arguments are strongly recommended against since they cannot be updated
  without redeploying applications and deleting the queue before it can be redeclared.
- Policies can be updated at any moment.
- Uses SHA-256 for password hashing
- The plugin supports anonymous authentication but its use is highly discouraged and
  it is a subject to certain limitations enforced for a reasonable level of security
  by default.
- Credential validators must be specified in the config file.
- Credential validators have limitations that have to do both with the config file
  grammar and shell interpretation of certain characters when credentials are specified
  on the command line.
- The MQTT plugin must be enabled on all cluster nodes using rabbitmq-plugins.
- OAuth 2.0 tokens must be digitally signed.
- Tokens must have a value in the `aud` field that matches `resource_server_id`.
- If mqtt.allow_anonymous is set to false, clients must provide credentials.
- Uses default user login/passcode of guest/guest
- For TLS, core RabbitMQ server certificates and key are required
- The plugin creates a dedicated queue per MQTT subscriber.
- LDAP plugin must be enabled for authentication and authorization.
- LDAP servers must be configured for the plugin to connect.
- Plugin supports anonymous authentication but its use is highly discouraged.
- To use TLS for MQTT connections, TLS must be configured in the broker.
- It is recommended that production clusters that rely on LDAP for authentication
  and authorization use it in combination with the caching backend.
- MQTT 3.1 does not define consistency or replication requirements for retained message
  stores.
- Less topic levels (in an MQTT topic and MQTT topic filter) perform better than more
  topic levels.
- In workloads with high subscription churn, increase Mnesia configuration parameter
  dump_log_write_threshold (e.g. RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS="-mnesia dump_log_write_threshold
  20000").
- When connecting many clients, increase the maximum number of Erlang processes (e.g.
  RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS="+P 10000000") and the maximum number of open
  ports (e.g. ERL_MAX_PORTS=10000000).
- Default value of auth_ldap.dn_lookup_base is none.
- Default value of auth_ldap.dn_lookup_attribute is none.
- The STOMP plugin supports STOMP versions 1.0 through 1.2.
- To enable TLS-enabled STOMP connections, add a TLS listener for STOMP.
- Cache expiration is currently time-based
- If no queue parameters are specified, queue will be assumed to be durable, non-exclusive,
  non-autodeleted.
- Messages sent to a topic destination that has no active subscribers are simply discarded.
- Plugins extend core broker functionality in a variety of ways.
- A number of features are implemented as plugins that ship in the core distribution.
- 'Plugins extend core broker functionality in a variety of ways: with support for
  more protocols, system state monitoring, additional AMQP 0-9-1 exchange types, node
  federation, and more.'
- 3rd party plugins can be installed separately.
- Definitions are exported as a JSON file in a number of ways.
- User data contains password hashes as well as password hashing function information.
- The enabled plugins file is commonly known as the enabled plugins file and is usually
  located under the etc directory or under the node's data directory.
- RabbitMQ nodes must listen on an 'internal network-local' interface that would allow
  cluster peers to connect but not be exposed to the public Internet.
- Such configurations can be hard to troubleshoot and reason about, so using the same
  IP version (e.g. IPv6) across the board or a dual stack setup is recommended.
- Instructs the node to only listen for inter-node communication connections on a
  local interface.
- This affects both connections from cluster peers and CLI tools.
- For multi-node clusters, nodes must listen on an "internal network-local" interface
  that would allow cluster peers to connect but not be exposed to the public Internet.
- Decreasing TCP buffer size will decrease RAM used for every client connection.
- Lowering TCP buffer sizes will result in a proportional throughput drop.
- Setting send and receive buffer sizes to different values is dangerous and not recommended.
- Values lower than 8 KiB are not recommended.
- Networking is a very broad topic. Therefore, this guide covers multiple topics,
  such as Interfaces the node listens on for client connections.
- In clusters with heavy inter-node traffic increasing the distribution buffer size
  may have a positive effect on throughput. Values lower than 64 MB are not recommended.
- The crypto module is missing in the Erlang/OTP installation used or it is out of
  date.
- The broker keyfile or certificate file is invalid. Confirm that the keyfile matches
  the certificate and that both are in PEM format.
- This error is related to client verification. The client is presenting an invalid
  certificate or no certificate.
- The erl_inetrc file at /etc/rabbitmq/erl_inetrc will control hostname resolution
  settings.
- 'For IPv6-only environments, it must include the line: {inet6,true}.'
- Default value for tcp_listen_options.backlog is 128.
- Requires configuring runtime flags for TLS communication
- Erlang runtime processes must be allowed to bind to ports and accept connections
  on MacOS with Application Firewall enabled.
- Dynamic shovels are the modern shovel type. When in doubt, prefer dynamic shovels.
- Local shovels do not use any connection, so no TLS is used.
- Nodes must be configured to resolve hostnames of every other cluster member.
- Credential validators have limitations regarding config file grammar.
- Clients should connect to one of the nodes hosting the replicas of the target stream.
- Nodes must be configured to satisfy requirements for clustering.
- Erlang cookie must be identical across all nodes for communication.
- Two node clusters are highly recommended against since it's impossible for cluster
  nodes to identify a majority and form a consensus in case of connectivity loss.
- For publishing, stream clients can connect to any node, and that node will forward
  all relevant operations to the node that hosts the leader replica of the stream.
- Updated hashing algorithm will be applied to newly created users or when password
  is changed.
- Nodes can be removed remotely, that is, from a different host, as long as CLI tools
  on said host can connect and authenticate to the target node.
- All nodes in a RabbitMQ cluster are equal peers
- Credential validators have limitations regarding config file grammar and shell interpretation.
- Uses password hashing for user authentication
- Stream consumers should connect to one of the nodes hosting the replicas of the
  target stream.
- Passwordless users can be created with the internal authentication backend.
- Uses internal authentication backend with username/password pairs.
- Supports multiple authentication mechanisms.
- Requires configuration of the resource service ID and issuer URL.
- A very basic check that will succeed for the nodes that are currently waiting for
  a peer to sync schema from.
- A RabbitMQ cluster must have at least one resource server identifier configured.
- Nodes will perform hostname resolution early on node boot
- RabbitMQ clustering is meant to be used across LAN. It is not recommended to run
  clusters that span WAN.
- If we want to re-initialise `rabbit@rabbit2` we follow the same steps as for the
  other nodes.
- LDAP support requires installation of the erlang-eldap package.
- Uses LDAP for authentication and authorisation
- LDAP servers typically use port 389
- LDAP support requires enabling the plugin.
- LDAP cannot be used on Erlang installations where the library is not available.
- Nodes must be reset to rejoin the cluster after being stopped.
- Default value of auth_ldap.dn_lookup_base and auth_ldap.dn_lookup_attribute is none.
- 'Using an odd number of nodes is highly recommended: 1, 3, 5, 7, and so on.'
- Using LDAP for authentication and/or authorization introduces another moving part
  into the system.
- Enabling LDAP traffic logging is highly recommended.
- RabbitMQ clustering has several modes of dealing with network partitions, primarily
  consistency oriented. Clustering is meant to be used across LAN. It is not recommended
  to run clusters that span WAN.
- If you want to use the full hostname for your nodename, you may want to investigate
  setting the environment variable RABBITMQ_USE_LONGNAME=true.
- Erlang cookie must be the same across all nodes.
- In case of a node failure, clients should be able to reconnect to a different node,
  recover their topology and continue operation.
- For short-lived queues, client-local is probably a better choice.
- For backwards compatibility, queue-master-locator, x-queue-master-locator and queue_master_locator
  are still supported by classic queues. However, these are deprecated in favour of
  the options listed.
- Khepri will become the default backend in RabbitMQ 4.2.0.
- Most health checks, even relatively basic ones, implicitly assume that the node
  has finished booting. They are not suitable for nodes that are awaiting schema table
  sync from a peer.
- A cluster of 3 nodes, A, B and C is formed
- Whenever the hostname changes RabbitMQ node must be restarted
- Such nodes will fail to rejoin the cluster if its data directory path changes as
  a result.
- A node that was removed from the cluster when stopped with `rabbitmqctl stop_app`
  must be either reset or decomissioned.
- Definitions can be imported during or after node startup time.
- Nodes in a cluster must have unique names.
- An odd number of nodes is recommended for cluster formation.
- Client connection listeners can be *suspended* to prevent new client connections
  from being accepted.
- The loopback interface will be implicitly added to that list.
- Forcing node boot may be necessary if the last node to shut down will never be brought
  back online.
- Starting with RabbitMQ 4.1, connections automatically adjust their TCP buffer size
  based on message rates and sizes.
- When optimising for the number of concurrent connections, make sure your system
  has enough file descriptors to support not only client connections but also files
  the node may use.
- Decreasing TCP buffer size will decrease how much RAM the node uses for every client
  connection.
- RabbitMQ settings are configured via RabbitMQ configuration file(s).
- Erlang runtime must be configured for inbound connections.
- 'When `epmd` is configured to use IPv6 exclusively but RabbitMQ nodes are not, RabbitMQ
  will log an error message similar to this: Protocol ''inet_tcp'': register/listen
  error: econnrefused.'
- Every queue and stream in RabbitMQ has a primary replica called the leader.
- 'Queue leader distribution can be controlled in three ways: a policy, by setting
  queue-leader-locator; the configuration file, by setting queue_leader_locator; or
  an optional queue argument, by setting the x-queue-leader-locator.'
- For backwards compatibility, queue-master-locator, x-queue-master-locator and queue_master_locator
  are still supported by classic queues. However, these are deprecated.
- A node rejoining after a node name or host name change can start as a blank node
  if its data directory path changes as a result.
- Nodes must be configured with unique names.
- Nodes must be able to resolve hostnames of every other cluster member
- Erlang cookie must be the same across all nodes for communication
- Client connections, channels and queues will be distributed across cluster nodes.
- RabbitMQ clustering is not recommended to span WAN; use Shovel or Federation plugins
  instead.
- RabbitMQ nodes use a shared secret called the Erlang cookie for authentication.
- Every cluster node must have the same cookie.
- For publishing, stream consumers should connect to one of the nodes hosting the
  replicas of the target stream.
- The client-provided queue argument takes precedence when both are used.
- Cluster peer discovery mechanisms support node health checks and forced removal
  of nodes not known to the discovery backend.
- 'Queue leader distribution can be controlled in three ways: a policy, by setting
  queue-leader-locator; the configuration file, by setting queue_leader_locator; optional
  queue argument, by setting the x-queue-leader-locator.'
- For backwards compatibility, queue-master-locator, x-queue-master-locator and queue_master_locator
  are still supported by classic queues but are deprecated.
- A health check that does not expect a node to be fully booted and have schema tables
  synced is rabbitmq-diagnostics ping.
- A node rejoining after a node name or host name change can start as a blank node
  if its data directory path changes.
- Exclusive queues are always declared locally.
- In addition to that, by default RabbitMQ names the database directory using the
  current hostname of the system.
- An odd number of nodes is highly recommended for clustering.
- RabbitMQ clustering has several modes of dealing with network partitions, primarily
  consistency-oriented.
- If started without a reset, it won't be able to rejoin its original cluster.
- Nodes `rabbit@rabbit1` and `rabbit@rabbit3` are freshly initialised RabbitMQ brokers.
- '`rabbit@rabbit2` retains the residual state of the cluster.'
- In some cases the last node to go offline cannot be brought back up. It can be removed
  from the cluster using the forget_cluster_node rabbitmqctl command.
- RabbitMQ nodes must be configured to satisfy clustering requirements.
- The protocol includes a topology discovery operation, so well-behaved client libraries
  will select one of the suitable nodes.
- The disadvantage of the balanced strategy is that the connection that declared the
  queue may not have the best possible performance when using this queues.
- Nodes that have been joined to a cluster can be stopped at any time. They can also
  fail or be terminated by the OS.
- RabbitMQ clustering has several modes of dealing with network partitions, primarily
  consistency oriented. Clustering is meant to be used across LAN.
- RabbitMQ nodes address each other using node names.
- Nodes must have distinct node names, data store locations, log file locations, and
  bind to different ports.
- A restarted node will sync the schema and other information from its peers on boot.
- Nodes in a RabbitMQ cluster are equal peers.
- Three node clusters can tolerate a single node failure (or unavailability) and still
  maintain quorum.
- It is recommended to use clusters with an odd number of nodes (3, 5, 7, etc).
- When in doubt, use the pause_minority strategy with an odd number of nodes (3, 5,
  7, and so on).
- Environments that have to sustain a large number of concurrent client connections
  will benefit from more cluster nodes.
- Diagnostic information is displayed if the connection failed, the target node was
  not running, or rabbitmqctl could not authenticate to the target node successfully.
- 'Queue leader distribution can be controlled in three ways: a policy, by setting
  queue-leader-locator, the configuration file, by setting queue_leader_locator, and
  optional queue argument, by setting the x-queue-leader-locator.'
- For backwards compatibility, queue-master-locator, x-queue-master-locator, and queue_master_locator
  are still supported by classic queues but are deprecated in favour of the options
  listed above.
- RabbitMQ names the database directory using the current hostname of the system.
- It's crucial to set up a fixed and resolvable hostname to avoid data loss.
- Using rabbit@localhost as the broker nodename will not allow clustering to work.
- Using DNS, such as Amazon Route 53, is recommended for resolvable hostnames.
- Setting the environment variable RABBITMQ_USE_LONGNAME=true may be beneficial if
  using the full hostname.
- RabbitMQ nodes must be configured to use the same Erlang cookie for inter-node communication.
- An odd number of nodes is recommended for clustering.
- Quorum queues allow queue contents to be replicated across multiple cluster nodes
  with parallel replication and a predictable leader election and data safety behavior
  as long as a majority of replicas are online.
- The disadvantage of the balanced strategy is that the connection that declared the
  queue may not have the best possible performance when using these queues, if a different
  node is picked.
- Most health checks even relatively basic ones implicitly assume that the node has
  finished booting. They are not suitable for nodes that are awaiting schema table
  sync from a peer.
- Nodes must be configured to satisfy clustering requirements.
- An odd number of nodes is recommended for quorum.
- For backwards compatibility, queue-master-locator (policy argument), x-queue-master-locator
  (queue argument) and queue_master_locator (configuration option) are still supported
  by classic queues. However, these are deprecated in favour of the options listed
  above.
- Nodes in a RabbitMQ cluster must be able to resolve hostnames of every other cluster
  member.
- Most health checks, even relatively basic ones, implicitly assume that the node
  has finished booting.
- rabbitmqadmin is a command line tool that uses the HTTP API.
- Idempotent deletion (does not fail if the user doesn't exist)
- Clients should be able to reconnect to a different node, recover their topology
  and continue operation.
- Can force boot a node without syncing with peers using rabbitmqctl command
- Reset a running node using rabbitmqctl commands
- Hostname resolution is a prerequisite for successful inter-node communication.
- RabbitMQ nodes must be configured to satisfy certain requirements for clustering.
- In environments where nodes are deployed and verified sequentially, such as Kubernetes
  with the OrderedReady pod management policy, the restart can run into deadlock unless
  a number of recommendations is followed.
- Nodes must have the same Erlang cookie to communicate.
- The `client-local` strategy is usually a good choice if the connections that declare
  queues are evenly distributed between nodes.
- When the entire cluster is brought down, the last node to go down is the only one
  that didn't have any running peers at the time of shutdown.
- The disadvantage of the balanced strategy is that the connection that declared the
  queue may not have the best possible performance when using this queues, if a different
  node is picked.
- rabbitmqadmin v2 is a command line tool that uses the HTTP API.
- It supports various operations such as listing objects, creating, deleting, and
  accessing metrics.
- Removing a node from the cluster requires stopping it first.
- A node that was removed while stopped must be reset before restarting.
- Nodes must use the same Erlang cookie for communication.
- rabbitmqadmin v1 is the original CLI tool for the HTTP API, historically developed
  as part of the management plugin and distributed with it.
- It is no longer under active development.
- It is necessary to make sure the nodes have distinct node names, data store locations,
  log file locations, and bind to different ports.
- Three node clusters are the next step up. They can tolerate a single node failure
  (or unavailability) and still maintain quorum.
- The cost of propagating such changes goes up with the number of cluster nodes, both
  during operations and node restarts.
- It is therefore recommended that servers use NTP or similar to ensure clocks remain
  in sync.
- It supports many of the operations available in the management UI.
- This command deletes ALL virtual hosts whose names start with 'test-'
- rabbitmqadmin v2 is built for interactive use by humans.
- Many commands output formatted tables that are harder to parse.
- Override --hashing-algorithm if RabbitMQ nodes are configured to use SHA512
- This is useful for pre-computing password hashes for user management scripts or
  when working with RabbitMQ definitions files.
- Not a replacement for rabbitmqctl or rabbitmq-plugins.
- RabbitMQ commands can be executed via rabbitmqadmin CLI tool.
- Using TLS is supported for secure communication.
- It supports many operations available in the management UI.
- rabbitmqadmin v2 is a command line tool for the HTTP API
- It supports many operations available in the management UI
- Default configuration file path is at $HOME/.rabbitmqadmin.conf
- Consider switching to `rabbitmqadmin` v2. The original `rabbitmqadmin` is no longer
  under active development.
- The page cache is not maintained or controlled by RabbitMQ nodes.
- Erlang uses generational garbage collection for each Erlang process.
- This tool is meant for interactive use and may not be ideal for scripting without
  flags.
- In modern RabbitMQ versions, all types of queues (classic, quorum, streams) either
  don't store messages in memory at all or store only a limited amount of messages
  in memory.
- Some monitoring tools do not include the size of page cache into process monitoring
  metrics.
- Garbage collection can briefly double the memory used by a queue.
- RabbitMQ will reduce the speed of connections which are publishing too quickly for
  queues to keep up.
- No configuration is required.
- Supports both HTTP and HTTPS connections.
- User authentication may be required based on RabbitMQ configuration.
- Using an absolute memory threshold is highly recommended in containerized environments
  such as Kubernetes.
- Using a relative memory threshold is not recommended in containerized environments
  such as Kubernetes.
- Default ranges for single stat metrics will not be optimal for all RabbitMQ deployments.
- The thresholds used by the Grafana dashboards have to have a default value.
- RabbitMQ ships with built-in Prometheus & Grafana support.
- Metrics are exposed on a dedicated TCP port, 15692 by default.
- It is possible to bump plugin side HTTP request timeouts using the prometheus.tcp.idle_timeout,
  prometheus.tcp.inactivity_timeout, prometheus.tcp.request_timeout settings.
- If a load balancer or proxy is used between the Prometheus node and the RabbitMQ
  nodes it scrapes, the inactivity_timeout and idle_timeout values should be at least
  as large, and often greater than, the timeout and inactivity values used by the
  load balancer.
- The plugin exposes all RabbitMQ metrics on a dedicated TCP port, in Prometheus text
  format.
- For production systems, we recommend a minimum value of 15s for Prometheus scrape
  interval and a 10000 (10s) value for RabbitMQ's collect_statistics_interval.
- Both intervals are 5000 ms (5 seconds) by default.
- Create a queue policy for high availability
- If a load balancer or proxy is used, inactivity_timeout and idle_timeout should
  be larger than the load balancer's timeout values.
- RabbitMQ exposes metrics on a dedicated TCP port, 15692 by default.
- Prometheus will scrape metrics every 60 seconds by default.
- RabbitMQ metrics are updated every 5 seconds by default.
- For production systems, a minimum value of 15s for Prometheus scrape interval is
  recommended.
- Quorum queues use a log-based storage mechanism implemented by RabbitMQ's Raft implementation.
- 'Classic queues have two storage implementations available to them: v1 and v2.'
- Incorrect permissions (e.g. files being owned by root or another superuser account
  that installed them) is a very common issue with TLS setups.
- RabbitMQ management plugin must be enabled for API access.
- Ensure proper permissions are set for the user.
- New broker logfile entries will be generated during many of the preceding steps.
- Make sure you are using the recommended version of Erlang.
- On Linux, BSD and MacOS directory permissions can also affect node's ability to
  read the files.
- If an error is reported, confirm that the certificates and keys were generated correctly
  and that a matching certificate/private key pair is used.
- Before performing any other TLS troubleshooting steps it is important to verify
  config file location and effective configuration.
- It is important to inspect logs for both server and client.
- This is a generic error that could have many causes. Make sure you are using the
  recommended version of Erlang.
- Increasing the net_ticktime across all nodes in a cluster will make the cluster
  more resilient to short network outages.
- Lowering net_ticktime can help to improve the responsiveness during cluster-wide
  queries.
- Requires configuring runtime flags for TLS-enabled connections
- CLI tools must use TLS to connect to nodes expecting TLS-enabled connections
- TLS is required for inter-node communication and CLI tools.
- Retry peer discovery operations up to ten times
- The discovery mechanism to use is specified in the config file.
- Peer discovery plugins are configured just like the core server and other plugins.
- In most cases, no configuration should be necessary beyond enabling this plugin.
- If you use a different ordinal start value in your StatefulSet, configure cluster_formation.k8s.ordinal_start.
- Default key prefix is rabbitmq.
- Each cluster must use a unique name.
- Highly recommended to use private DNS hostnames for node names.
- Consider race conditions during initial cluster formation.
- Uses TLS for secure communication with RabbitMQ clusters.
- Automatic node removal has a number of negative side effects operators should be
  aware of.
- Peer discovery mechanisms that use HTTP to interact with its dependencies can proxy
  their requests using an HTTP proxy.
- Nodes determine if its peer is down if another node is unable to contact it for
  a period of time, 60 seconds by default.
- RabbitMQ will automatically pause cluster nodes which determine themselves to be
  in a minority after seeing other nodes go down.
- Erlang 28 is not currently supported by RabbitMQ.
- RabbitMQ versions prior to 4.0.4 are not compatible with Erlang 27.
- Consider switching to rabbitmqadmin v2. The original rabbitmqadmin is no longer
  under active development.
- Erlang memory breakdown reports only memory is currently being used, and not the
  memory that has been allocated for later use or reserved by the operating system.
- This cache improves I/O operation efficiency and is evicted (cleared) when the OS
  detects that a high percentage of available memory is in use.
- The page cache is not maintained or controlled by RabbitMQ nodes. It is maintained,
  controlled and evicted (cleared) by the operating system kernel.
- Memory breakdown can be produced using CLI tools, both `rabbitmq-diagnostics` and
  `rabbitmqadmin`.
- Memory and binary heap breakdowns can be expensive to calculate.
- Some monitoring tools do not include the size of page cache into process monitoring
  metrics. Others add it to the residential set size (RSS) footprint of the process.
- A flow-controlled connection will show a state of `flow` in `rabbitmqctl`, management
  UI and HTTP API responses.
- Support for Prometheus metric collector ships in the rabbitmq_prometheus plugin.
- Default ranges for the single stat metrics will not be optimal for all RabbitMQ
  deployments.
- If a load balancer or proxy is used, the inactivity_timeout and idle_timeout values
  should be at least as large, and often greater than, the timeout and inactivity
  values used by the load balancer.
- Default scrape interval is every 60 seconds for Prometheus and every 5 seconds for
  RabbitMQ.
- For production systems, a minimum scrape interval of 15s for Prometheus is recommended.
- Streams use a log-based storage mechanism and keep very little data in memory.
- If the node is configured to use TLS but a message about SSL listener is not logged,
  it is possible that the configuration file was placed at an incorrect location and
  was not read by the broker or the node was not restarted after config file changes.
- Client is presenting an invalid certificate or no certificate.
- Troubleshooting of network connectivity issues is a broad topic.
- An effective troubleshooting strategy typically uses the process of elimination
  to pinpoint the issue.
- Lowering net_ticktime can help to improve the responsiveness during such events
  but any decision to change net_ticktime should be done carefully.
- Switching inter-node and CLI tool communication requires configuring a few runtime
  flags.
- CLI tools configured to use TLS won't be able to connect to a node that does not
  expect TLS-enabled CLI tool connections.
- TLS configuration requires a CA certificate bundle and a certificate/key pair for
  every cluster node and CLI tool host.
- TLS-enabled nodes won't accept unencrypted connections from CLI tools and peers.
- Plugin must be enabled before it can be used.
- Nodes register with etcd on boot by creating a key in a conventionally named directory.
- Default key prefix is simply 'rabbitmq'. It rarely needs overriding but that's supported.
- If multiple RabbitMQ clusters share an etcd installation, each cluster must use
  a unique name.
- Uses peer discovery mechanisms that require specific configuration.
- Inability to reach the discovery services will lead to node's inability to join
  the cluster.
- Each cluster must use a unique name when sharing an etcd installation.
- Node TTL is configurable.
- If a node fails to perform peer discovery and exhausts all retries, enable debug
  logging is highly recommended for troubleshooting.
- The defaults cover five seconds of unavailability of services, API endpoints or
  nodes involved in peer discovery.
- Make sure that VMs are not suspended while running
- Erlang 24.3 is the only maintained (updated) series of Erlang 24.
- As of Erlang 25.1, OpenSSL 3.0 support in Erlang is considered to be mature enough
  to consider for production.
- 'Erlang 25 before 25.0.2 and 24 before 24.3.4.2 are affected by CVE-2022-37026,
  a CVE with critical severity (CVSS 3.x Base Score: 9.8).'
- Erlang 23 support was discontinued on July 31st, 2022.
errors:
- 'java.net.ConnectException: Connection failed'
- 'IOException: Connection closed unexpectedly'
- '401 Unauthorized: Recheck username or password'
- 'CONNECTION_FORBIDDEN: User cannot connect from this host'
- 'ConnectException: Apply retry logic.'
- 'RESOURCE_ALARM: Check the broker log file for resource alarms.'
- 'DISK_FREE_LIMIT_EXCEEDED: Reduce free disk space threshold.'
- 'RESOURCE_ALARM: Check broker log file for resource alarms.'
- 'RESOURCE_ALARM: Check broker log for resource alarms.'
- 'AUTHENTICATION_FAILED: Recheck provided credentials.'
- 'RESOURCE_ALARM: Check broker log file for resource alarms'
- '401 Unauthorized: Check credentials for RabbitMQ'
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- 'Connection refused: Check if RabbitMQ server is running.'
- 'ACCESS_REFUSED: Verify user permissions on the RabbitMQ server.'
- 'CHANNEL_ERROR: A channel-level protocol exception occurred.'
- 'NOT_FOUND: The specified queue does not exist.'
- 'CHANNEL_ERROR: Ensure that the channel is properly configured.'
- 'Failed to connect to RabbitMQ: Check connection string'
- 'Failed to declare a queue: Ensure queue name is correct'
- 'Failed to open a channel: Check RabbitMQ service status'
- 'Failed to declare a queue: Queue name already exists with different parameters.'
- 'Failed to connect to RabbitMQ: Check RabbitMQ server status.'
- 'Failed to declare a queue: Ensure the queue name is valid.'
- 'Failed to publish a message: Check message format and connection.'
- 'AMQP protocol error: Invalid queue parameters.'
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency.'
- '404 Not Found: Check the queue name or URL.'
- '500 Internal Server Error: Server encountered an unexpected condition.'
- 'AMQQueueDeclareNonDurable: Queue must be declared as durable to ensure messages
  are saved.'
- 'CONNECTION_REFUSED: Check if RabbitMQ server is running.'
- 'CHANNEL_ERROR: Ensure correct queue or exchange names.'
- '405 Method Not Allowed: Check the HTTP method used.'
- '404 Not Found: Verify the endpoint path.'
- '401 Unauthorized: Recheck connection settings or credentials'
- 'Failed to connect to RabbitMQ: Check connection settings.'
- 'Failed to declare an exchange: Check exchange name and type.'
- 'Error: Check your connection settings or RabbitMQ server status.'
- 'Failed to connect to RabbitMQ: Ensure RabbitMQ is running and credentials are correct.'
- 'Failed to declare an exchange: Check if the exchange name is correct.'
- 'Failed to publish a message: Verify the routing key and message body.'
- Check connection settings if unable to connect to RabbitMQ server
- 'Unknown correlation_id: Discard the message as it doesn''t belong to our requests.'
- Error handling is required for cases when the RPC server is down.
- 'Failed to connect to RabbitMQ: check connection settings.'
- 'Failed to declare a queue: ensure proper permissions.'
- 'InvalidOperationException: Thrown when the channel is null.'
- 'Exception: General catch for any errors during processing.'
- 'basic.return-ed: Indicates that a message could not be handled by the broker.'
- 'TIMEOUT: Confirmation waiting exceeds timeout period.'
- 'NACK: Message could not be confirmed by the broker.'
- Exception thrown if message is not confirmed within the timeout or if it is nack-ed.
- '501 (frame error): oversized frame'
- '503 (command invalid): non-zero channel number for method frames'
- '504 (channel error): zero channel number in content frame'
- '0: No guarantees are provided for messages that have not been confirmed using the
  publisher confirm mechanism.'
- 'ASYNC_SEND_ERROR: Ensure the program doesn''t exit before the message reaches the
  broker.'
- '404 Not Found: Publishing to a non-existent queue or exchange'
- '404 Not Found: Publishing to a non-existent queue or exchange.'
- '404 Not Found: Attempt to consume from a non-existent queue'
- 'PRECONDITION_FAILED: Consumer acknowledgement timeout'
- '404 Not Found: Attempt to consume from a non-existent queue.'
- 'PRECONDITION_FAILED: Delivery acknowledgement timeout.'
- '404 Not Found: Attempt to publish to a non-existent queue or exchange.'
- '403 ACCESS_REFUSED: Queue name violates broker reserved name rule.'
- '406 PRECONDITION_FAILED: Queue attributes do not match during declaration.'
- 'RESOURCE_LOCKED: Cannot obtain exclusive access to locked queue.'
- '404 Not Found: Attempt to publish to a non-existent queue (topic) will result in
  a channel-level exception.'
- '406 PRECONDITION_FAILED: Redeclaring an existing queue or exchange with non-matching
  properties'
- '403 ACCESS_REFUSED: Accessing a resource the user is not allowed to access'
- '404 NOT_FOUND: Binding, consuming, or publishing to a non-existing queue or exchange'
- '405 RESOURCE_LOCKED: Accessing an exclusive queue from a different connection'
- 'not_allowed: "number of channels opened (22) has reached the negotiated channel_max
  (22)"'
- 'PRECONDITION_FAILED: Consumer delivery acknowledgement timeout.'
- '406 PRECONDITION_FAILED: Redeclaring an existing queue or exchange with non-matching
  properties.'
- '403 ACCESS_REFUSED: Accessing a resource the user is not allowed to access.'
- '404 NOT_FOUND: Binding a non-existing queue or exchange.'
- '405 RESOURCE_LOCKED: Accessing an exclusive queue from a connection other than
  its declaring one.'
- Trying to register an exclusive consumer with SAC will result in an error.
- PRECONDITION_FAILED - unknown delivery tag 100
- Double Acking and Unknown Tags
- '404 NOT_FOUND: Binding a non-existing queue or exchange'
- '404 NOT_FOUND: Consuming from a queue that does not exist'
- '404 NOT_FOUND: Publishing to an exchange that does not exist'
- '405 RESOURCE_LOCKED: Accessing an exclusive queue from a connection other than
  its declaring one'
- 'not_allowed: number of channels opened has reached the negotiated channel_max'
- 'plugins_not_found: Check the plugin name or directory'
- '{:enabled_plugins_mismatch, ''/path/to/installation1/etc/rabbitmq/enabled_plugins'',
  ''/path/to/installation2/etc/rabbitmq/enabled_plugins''}'
- Connection failures require re-establishing the connection.
- Messages in transit may need to be retransmitted if delivery fails.
- 'unknown delivery tag: Acknowledging on a different channel will result in an unknown
  delivery tag protocol exception.'
- aborted field in transfer frame
- 'RESOURCE_EXHAUSTED: Connection limit reached on target node'
- 'PROTOCOL_ERROR: Check for incorrect framing or connection state violations'
- 'plugins_not_found: Double check the name of the plugin.'
- 'enabled_plugins_mismatch: Check the paths for the enabled plugins file.'
- False positives may occur with low timeout values
- Setting heartbeat timeout to 0 disables heartbeats
- 'plugins_not_found: Check the plugin name and directory'
- 'Error: {:plugins_not_found, [:rabbitmq_managemenr]}'
- 'plugins_not_found: Plugin not found'
- 'enabled_plugins_mismatch: Mismatch between enabled plugins file paths'
- '401 Unauthorized: Check Basic Auth credentials.'
- '404 Not Found: Ensure the requested resource exists.'
- '3rd Party Plugin Not Found: Check plugin installation'
- 'Plugin Cannot be Enabled: Verify enabled plugins file'
- '401 Unauthorized: Check username and password for Basic Auth.'
- If the check succeeded, exit code will be 0
- '401 Unauthorized: Recheck username and password for Basic Authentication'
- '401 Unauthorized: Check credentials for Basic Authentication.'
- '401 Unauthorized: Check your credentials.'
- '404 Not Found: Ensure the endpoint exists.'
- '500 Internal Server Error: Check the server logs for details.'
- maximum connect time
- QoS not supported
- 'web_mqtt.proxy_protocol = true: The feature is deactivated by default.'
- 'Error downloading OpenID provider configuration: OAuth 2.0 authentication option
  will be disabled.'
- 'AUTHENTICATION_FAILED: Check credentials or permissions'
- 'CONNECTION_REFUSED: Verify server address and port'
- 'TIMEOUT: Network issues or server unresponsive'
- '160: Maximum connect time - Token expiration causes client disconnection'
- '155: QoS not supported - QoS 2 messages are not supported.'
- '4Mb frame size limit exceeded: Connection closed'
- OAuth 2.0 authentication option will be disabled if RabbitMQ cannot download the
  OpenID provider configuration.
- '400 Bad Request: Check your request format.'
- '400 Bad Request: Request body exceeds the maximum HTTP request body limit.'
- '401 Unauthorized: Recheck authorization settings or credentials.'
- '401 Unauthorized: Recheck OAuth scopes or token expiration.'
- '400 Bad Request: Body size exceeds the maximum limit.'
- 'Failure rate is too high: max tolerated rate depends on upstream''s reconnect-delay.'
- Link no longer can locate its source queue or exchange.
- Cannot propagate bindings from the downstream to the upstreams.
- Messages cannot be transferred from A to C via B unless there is also a consumer
  at B.
- '412 Precondition Failed: Refusing to delete virtual host ''vhost-name'' because
  it is protected from deletion.'
- '412 Precondition Failed: Refusing to delete virtual host ''vh1'' because it is
  protected from deletion'
- 'Failure rate is too high: max tolerated rate depends on upstream''s reconnect-delay'
- Link no longer can locate its 'source' queue or exchange
- Policy changes may result in a link considering itself no longer necessary
- '412 Precondition Failed: Refusing to delete virtual host because it is protected
  from deletion'
- 'QUEUE_NOT_FOUND: Ensure the queue exists and is correctly named.'
- 'UPSTREAM_NOT_FOUND: Check if the upstream is defined correctly.'
- '409 Conflict: Policy already exists with a higher priority.'
- '404 Not Found: The specified policy does not exist.'
- 'HTTP request failed with status 412: Precondition Failed'
- '409 Conflict: Policy with the same name already exists with a different definition.'
- Conflicting priorities may lead to non-deterministic behavior.
- Policy pattern or target type does not match object's name or type.
- Connection attempt from disallowed node
- Could not auto-cluster
- Authentication failed (rejected by the remote node), please check the Erlang cookie
- Policy name length limit is 255 bytes.
- At most one policy matches a queue or exchange.
- 'QUERY_TIMEOUT: Break down filters or add selectivity.'
- 'CONFLICT: Multiple policies have conflicting priorities.'
- 'Shared Secret Mismatch Between The Host and the Container: When CLI tools are run
  in the host, the local shared secret must match that in the container.'
- 'Shared Secret Seeding Race Condition: If the shared secret used by the container
  is not pre-seeded, the node must be allowed to boot before CLI commands can be run
  against it.'
- 'BEAST attack: disable TLSv1.0 support to mitigate.'
- 'Unknown CA: Indicates no trusted and otherwise valid certificate is found.'
- 'Certificate Expired: Indicates the certificate is expired or not yet valid.'
- 'Delivery limit exceeded: message dropped or dead-lettered.'
- 'Unknown CA: Peer verification fails if no trusted and otherwise valid certificate
  is found.'
- 'Certificate Expired: Certificates that are expired or aren''t yet valid will be
  rejected.'
- 'Unknown CA: Peer verification failed due to no trusted certificate found.'
- 'Certificate Expired: Peer verification failed due to expired certificate.'
- no suitable cipher suite found
- Failed to start due to missing CA certificate bundle.
- TLS connection rejected if client fails to provide a certificate.
- 'enoent: Command will fail if only console logging is activated'
- 'SSL_HANDSHAKE_ERROR: Check your TLS configuration or certificate paths.'
- 'CERTIFICATE_VERIFY_FAILED: Ensure the CA certificates are correctly configured.'
- Certificate removed from store.
- Successfully connected and opened a channel.
- Successfully declared a queue.
- Successfully deleted the queue.
- Cannot forward any dead-letter messages from source quorum queue 'qq.input' in vhost
  'my-vhost' with configured dead-letter-exchange exchange 'amq.topic' in vhost 'my-vhost'
  and configured dead-letter-routing-key 'my-app.events.type.abc'
- 'CONNECTION_REFUSED: Check if RabbitMQ server is running and accessible.'
- 'AUTHENTICATION_FAILED: Verify username and password.'
- 'RESOURCE_NOT_FOUND: Ensure the specified queue exists.'
- 'INVALID_FILTER: Ensure the filter value is valid.'
- 'MESSAGE_NOT_FOUND: The specified message does not exist.'
- 'busy_dist_port: Indicates a busy distribution port during high inter-node traffic.'
- Throttle API calls or reduce frequency
- Break down filters or add selectivity
- 'BAD signature: Verify origin of the package and signature file.'
- '401 Unauthorized: Check the credentials and authorization mechanism.'
- access to vhost '/' refused for user 'user2'
- 'PLAIN login refused: user ''guest'' can only connect via localhost'
- 'USER_NOT_FOUND: The specified user does not exist.'
- 'PLAIN login refused: user ''user2'' - invalid credentials'
- 'BAD signature: If the signature is invalid, verify the package origin and signing
  key.'
- 'access_refused: access to queue ''user3.q1'' in vhost ''gw1'' refused for user
  ''user2'''
- basic.return will be sent if the mandatory flag was set.
- '401 Unauthorized: Check credentials or permissions.'
- 'operation queue.declare caused a channel exception access_refused: access to queue
  ''user3.q1'' in vhost ''gw1'' refused for user ''user2'''
- access to queue 'user3.q1' in vhost 'gw1' refused for user 'user2'
- Invalid challenge reply
- TCP connection succeeded but Erlang distribution failed
- If a user is found in LDAP then the password will be checked against LDAP and subsequent
  authorisation checks will be performed against the internal database.
- Double acknowledgements of a delivery will be logged.
- If only console logging is activated, this command will fail with a 'file not found'
  (enoent) error.
- '412 Precondition Failed: Refusing to delete virtual host ''{name}'' because it
  is protected from deletion'
- '412 Precondition Failed: Refusing to delete virtual host because it is protected
  from deletion.'
- Authentication attempts with a blank password will be rejected.
- 'Connection timeout: Check LDAP server availability.'
- 'Invalid credentials: Verify the username and password.'
- 'AUTHENTICATION_FAILURE: Check LDAP server settings and user credentials'
- 'CONNECTION_TIMEOUT: Verify LDAP server is reachable'
- ACCESS_REFUSED
- Credential validation limitations may affect user management
- '401 Unauthorized: Check audience in token.'
- 'Invalid Policy Name: Check the naming conventions.'
- '401 Unauthorized: Recheck credentials or bind configuration'
- 'ACCESS_REFUSED: Authentication failure'
- '403 Forbidden: Check user permissions.'
- '404 Not Found: User or limit does not exist.'
- Multiple policies matching an entity with equal priorities will result in undetermined
  behavior.
- 'NOT_FOUND: Policy or object does not exist.'
- Unaccepted TCP connections are put into a queue with bounded length. This length
  has to be sufficient to account for peak load hours and possible spikes.
- 'EPMD_NOT_RUNNING: Ensure that epmd is running and reachable.'
- 'CONNECTION_REFUSED: Check if RabbitMQ is running and listening on the expected
  ports.'
- 'AUTHENTICATION_FAILED: Verify credentials and permissions.'
- 'epmd: up and running on port 4369 with data: name rabbit at port 25672'
- 'Protocol ''inet_tcp'': register/listen error: econnrefused'
- 'Invalid challenge reply: Connection attempt from node rejected'
- 'TCP connection succeeded but Erlang distribution failed: suggestion: hostname mismatch?'
- 'Timeout contacting cluster nodes: [rabbit@node1].'
- Policy pattern or target type does not match the object's name or type.
- 'inconsistent_cluster: Node thinks it''s clustered with node, but disagrees'
- 'timeout_waiting_for_tables: Identify the timeout waiting for Mnesia tables'
- 'BOOT FAILED: Timeout contacting cluster nodes'
- 'timeout_waiting_for_tables: Timeout contacting cluster nodes.'
- 'inconsistent_cluster: Node thinks it''s clustered with another node, but it disagrees'
- Connection attempt from disallowed node.
- Could not auto-cluster.
- Authentication failed (rejected by the remote node).
- 'timeout_waiting_for_tables: Waiting for Mnesia tables failed due to timeout.'
- 'timeout_waiting_for_tables: Timeout contacting cluster nodes'
- 'inconsistent_cluster: Node rabbit@rabbit1 thinks it''s clustered with node rabbit@rabbit2,
  but rabbit@rabbit2 disagrees'
- Incompatibilities between patch releases of Erlang/OTP versions are very rare.
- 'Connection attempt from disallowed node: Invalid challenge reply.'
- 'Could not auto-cluster: Check cookie configuration.'
- TCP connection succeeded but Erlang distribution failed.
- '401 Unauthorized: API responded with a 401 Unauthorized'
- Kernel pid terminated (application_controller) ({application_start_failure,rabbit,{{timeout_waiting_for_tables,[rabbit_user,rabbit_user_permission,rabbit_topic_permission,rabbit_vhost,rabbit_durable_r
- Authentication failed (rejected by the remote node)
- '401 Unauthorized: Recheck Basic Auth credentials'
- '401 Unauthorized: Check username and password'
- '404 Not Found: Ensure the endpoint is correct'
- 'BEAST attack: Mitigate by disabling TLSv1.0 support.'
- Fatal - Unknown CA
- Fatal - Certificate Expired
- 'TCP connection succeeded but Erlang distribution failed: check the Erlang cookie.'
- 'FATAL - Unknown CA: Peer verification failed due to untrusted certificate.'
- 'FATAL - Certificate Expired: Certificate validity check failed.'
- 'Connection attempt from disallowed node: Ensure the Erlang cookie is identical
  across nodes.'
- 'Could not auto-cluster: Verify hostname resolution and cookie configuration.'
- '401 Unauthorized: API responded with incorrect credentials'
- '400 Bad Request: Request body exceeds the maximum HTTP request body limit'
- '401 Unauthorized: Check username and password.'
- '401 Unauthorized: Ensure correct authentication'
- '404 Not Found: Verify endpoint URL and parameters'
- '401 Unauthorized: Check your username and password.'
- '404 Not Found: Ensure the resource path is correct.'
- If a client fails to provide a certificate, the TLS connection will be rejected.
- TLS connection fails if certificate files are missing or inaccessible.
- 'Unknown CA: The connection is closed if no trusted certificate is found.'
- 'Certificate Expired: The connection is closed if the certificate is expired.'
- 'Unknown CA: Peer verification failed.'
- 'Certificate Expired: Certificate is no longer valid.'
- Error if no node is running.
- If RabbitMQ cannot download the OpenID provider configuration, it shows an error
  message and the OAuth 2.0 authentication option will be disabled in the management
  UI
- If RabbitMQ cannot download the OpenID provider configuration, it shows an error
  message and the OAuth 2.0 authentication option will be disabled in the management
  UI.
- '401 Unauthorized: Check user credentials or permissions'
- '400 Bad Request: Request body exceeds the maximum limit.'
- '400 Bad Request: Request body exceeds the maximum allowed size'
- '401 Unauthorized: Check OAuth credentials or scopes'
- '155: QoS not supported: Disconnect client if QoS 2 is used'
- '160: Maximum connect time: Disconnect client if token expires'
- 'Frame size limit exceeded: Connection closed.'
- '400 Bad Request: Request body exceeds maximum limit.'
- '401 Unauthorized: Invalid token or insufficient scopes.'
- 'ERROR: {:plugins_not_found, [:plugin_name]}: Check the plugin name.'
- 'ERROR: {:enabled_plugins_mismatch, ''path1'', ''path2''}: Check the enabled plugins
  file paths.'
- 'plugins_not_found: Double check the plugin name'
- 'Error: {:enabled_plugins_mismatch, ''/path/to/installation1/etc/rabbitmq/enabled_plugins'',
  ''/path/to/installation2/etc/rabbitmq/enabled_plugins''}'
- '400 Bad Request: Invalid request parameters'
- '404 Not Found: Resource not found'
- 'ERROR: {:plugins_not_found, [:rabbitmq_managemenr]}'
- 'ERROR: {:enabled_plugins_mismatch, ''/path/to/installation1/etc/rabbitmq/enabled_plugins'',
  ''/path/to/installation2/etc/rabbitmq/enabled_plugins''}'
- 'error: rabbitmq-components.mk must be updated!'
- '{undef, [{crypto,hash,...}: The `crypto` module is missing in the Erlang/OTP installation
  used or it is out of date.'
- '{ssl_upgrade_error, ekeyfile}: The broker keyfile or certificate file is invalid.'
- '{ssl_upgrade_failure, ... certify ...}: This error is related to client verification.'
- '{ssl_upgrade_error, ...}: This is a generic error that could have many causes.'
- '{tls_alert,"bad record mac"}: The server has tried verifying integrity of a piece
  of data it received and the check failed.'
- Authentication attempts that use a blank password will be unconditionally rejected.
- 'Invalid password: Must meet validation criteria.'
- 'User not found: Check username.'
- 'Access denied: Check user permissions.'
- 'Invalid username or password: Recheck credentials'
- '403 Forbidden: Check user permissions'
- '404 Not Found: Verify the endpoint path'
- 'AUTHENTICATION_FAILED: Check LDAP credentials and server configuration'
- 'SERVER_UNREACHABLE: Verify LDAP server address and network connectivity'
- '2: The client identifier is not allowed by the server.'
- '160: Maximum connect time'
- '155: QoS not supported'
- '401 Unauthorized: Recheck your credentials or authentication configuration.'
- Frame size limit exceeds 4MB.
- Insufficient filesystem permissions
- Incorrect plugin directory
- Plugin version is incompatible with RabbitMQ core
- 'plugins_not_found: Check the name or the plugin directory'
- '401 Unauthorized: Recheck username and password.'
- 'Error: {:plugins_not_found, [:plugin_name]}: Double check the plugin name.'
- 'Error: {:enabled_plugins_mismatch, ''path1'', ''path2''}: Check that rabbitmq-plugins
  and the server use the same enabled plugins file.'
- Unaccepted TCP connections are put into a queue with bounded length.
- Connections will be rejected by the operating system if pending connection queue
  length grows beyond the default value of 128.
- 'EPMD_PORT_NOT_OPEN: Ensure port 4369 is open for CLI tools and clustering to function.'
- When a node or CLI tool needs to contact node it will fail to start if processes
  and tools such as SELinux prevent RabbitMQ from binding to a port.
- '{undef, [{crypto,hash,...}: The crypto module is missing in the Erlang/OTP installation
  used or it is out of date.'
- '401 Unauthorized: Authentication attempts that use a blank password will be unconditionally
  rejected.'
- Timeout contacting cluster nodes
- 'Error while waiting for Mnesia tables: {timeout_waiting_for_tables, ...}'
- 'Unauthorized: Check user credentials.'
- 'Invalid password: Ensure password meets validation criteria.'
- 'Error: inconsistent_cluster: Node thinks it''s clustered with another node, but
  the other node disagrees.'
- Using the classic config format is not supported for every configuration.
- Requires management plugin to be enabled
- '401 Unauthorized: Recheck credentials or permissions'
- '403 Forbidden: Check user permissions for the requested action'
- EPMD port must be open for CLI tools and clustering to function.
- 'Error: inconsistent_cluster: Node rabbit@rabbit1 thinks it''s clustered with node
  rabbit@rabbit2, but rabbit@rabbit2 disagrees'
- 'timeout_waiting_for_tables: Check logs for timeout errors while waiting for Mnesia
  tables during node startup.'
- Authentication failed (rejected by the remote node), please check the Erlang cookie.
- 'inconsistent_cluster: Node rabbit@rabbit1 thinks it''s clustered with node rabbit@rabbit2,
  but rabbit@rabbit2 disagrees.'
- 'timeout_waiting_for_tables: Error while waiting for Mnesia tables'
- 'timeout_waiting_for_tables: Node startup failure due to timeout contacting cluster
  nodes.'
- 'Timeout contacting cluster nodes: [rabbit@node1]'
- 'Error: inconsistent_cluster: Node rabbit@rabbit1 thinks it''s clustered with node
  rabbit@rabbit2, but rabbit@rabbit2 disagrees.'
- 'Connection attempt from disallowed node: Check cookie configuration.'
- 'TCP connection succeeded but Erlang distribution failed: Verify hostname and cookie.'
- 'inconsistent_cluster: Node thinks it''s clustered with node, but the other node
  disagrees'
- Node removal is explicit (manual) or opt-in.
- '404 Not Found: Verify the resource path.'
- '401 Unauthorized: Check authentication credentials.'
- '404 Not Found: Check the endpoint path or resource name'
- '403 Forbidden: Ensure you have the correct permissions'
- If the Erlang VM tries to allocate more memory than is available, the VM itself
  will either crash or be killed by the OOM killer.
- If Erlang VM tries to allocate more memory than is available, the VM itself will
  either crash or be killed by the OOM killer.
- If timeouts are exceeded, consider adjusting prometheus.tcp.idle_timeout, prometheus.tcp.inactivity_timeout,
  prometheus.tcp.request_timeout.
- '404 Not Found: Check the endpoint path or resource availability.'
- '401 Unauthorized: Verify authentication credentials.'
- '403 Forbidden: Ensure user has sufficient permissions.'
- 'Entries containing `{undef, [{crypto,hash,...` : The `crypto` module is missing
  in the Erlang/OTP installation used or it is out of date.'
- 'Entries containing `{ssl_upgrade_error, ekeyfile}` or `{ssl_upgrade_error, ecertfile}`
  : This means the broker keyfile or certificate file is invalid.'
- 'Entries containing `{ssl_upgrade_failure, ... certify ...}` : This error is related
  to client verification.'
- 'Entries containing `{ssl_upgrade_error, ...}` : This is a generic error that could
  have many causes.'
- 'Entries containing `{tls_alert,"bad record mac"}` : The server has tried verifying
  integrity of a piece of data it received and the check failed.'
- '{ssl_upgrade_error, ekeyfile}: The broker keyfile or certificate file is invalid.
  Confirm that the keyfile matches the certificate and that both are in PEM format.'
- '{ssl_upgrade_failure, ... certify ...}: This error is related to client verification.
  The client is presenting an invalid certificate or no certificate.'
- '{undef, [{crypto,hash,...'
- '{ssl_upgrade_error, ekeyfile}'
- '{ssl_upgrade_error, ecertfile}'
- '{ssl_upgrade_failure, ... certify ...}'
- '{ssl_upgrade_error, ...}'
- '{tls_alert,"bad record mac"}'
- Node 'rabbit@node1.local' thinks it's clustered with node 'rabbit@node2.local',
  but 'rabbit@node2.local' disagrees.
- Trying to join discovered peers failed. Will retry after a delay of 500 ms, 4 retries
  left...
- 'Could not auto-cluster with node rabbit@hostname2: {badrpc,nodedown}'
- 'Could not auto-cluster with node rabbit@hostname3: {badrpc,nodedown}'
- 'inconsistent_database: Check for network partition between nodes.'
- '404 Not Found: Verify the requested resource exists.'
- '400 Bad Request: Check the request parameters for correctness.'
- '401 Unauthorized: Check username and password for API access.'
- If metrics are not available, ensure all RabbitMQ endpoints are Up on the Prometheus
  Targets page.
- '{undef, [{crypto,hash,...}'
- 'RACE_CONDITION: Prevent multiple nodes forming separate clusters.'
- 'CVE-2022-37026: A CVE with critical severity (CVSS 3.x Base Score: 9.8)'
- RabbitMQ 3.8 was released in October 2019, and reached end of life on July 31st,
  2022, we strongly discourage its use.
- RabbitMQ 3.7 was released on 2017-11-28, and reached end of life on 2020-09-30,
  we strongly discourage its use.
- RabbitMQ 3.6 was released on 2015-12-22, and reached end of life on 2018-05-31,
  we strongly discourage its use.
- RabbitMQ 3.5 was released on 2015-03-11, and reached end of life on 2016-10-31,
  we strongly discourage its use.
- RabbitMQ 3.4 was released 2014-10-21, and reached end of life 2015-10-31, we strongly
  discourage its use.
auth_info:
  mentioned_objects:
  - OAuth2ClientCredentialsGrantCredentialsProvider
  - OAuth2ClientCredentialsGrantCredentialsProviderBuilder
  - rabbitmqctl
  - management UI
  - HTTP API
  - anonymous_login_user
  - anonymous_login_pass
  - OAuth 2.0
  - JWT
  - oauth2
  - JWT-encoded access tokens
  - OAuth2
  - OauthToken
  - oauth_client_id
  - oauth_scopes
  - auth_oauth2.issuer
  - OpenId Connect Discovery endpoint
  - OAuth 2.0 authentication backend plugin
  - Erlang/OTP
  - shared secret authentication
  - AuthProvider
  - NamedCredential
  - rabbitmqadmin
  - SaslConfig
  - AuthMechanism
  - AuthMechanismFactory
  - OAuth 2
  - X.509 certificates
  - authorization
  - permissions
  - scopes
  - Authorization Server
  - Requesting Party
  - User-Managed Access
  - rabbit_auth_backend_oauth2
  - resource_server_id
  - issuer
  - Erlang cookie
  - auth_oauth2
  - rabbitmq_management
  - OAuth 2.0 Authorization Code Flow with PKCE
  - auth_oauth2.resource_server_id
  - auth_oauth2.additional_scopes_key
  - rabbit_auth_backend_ldap
  - rabbit_auth_backend_internal
  - user_dn_pattern
  - user_bind_pattern
  - auth_ldap.dn_lookup_attribute
  - auth_ldap.dn_lookup_base
  - auth_ldap.dn_lookup_bind
  - auth_ldap.log
client:
  base_url: localhost
  headers:
    Accept: application/json
source_metadata: null
