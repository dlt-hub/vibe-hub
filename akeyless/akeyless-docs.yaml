resources:
- name: secrets
  endpoint:
    path: /api/v1/secrets
    method: GET
    data_selector: records
- name: alias_details
  endpoint:
    path: /alias-details
    method: POST
    data_selector: object
    params:
      account-alias: string
      auth-method-name: string
      json: boolean
- name: get-ldap-auth-config
  endpoint:
    path: /gateway-get-ldap-auth-config
    method: POST
- name: get-log-forwarding
  endpoint:
    path: /gateway-get-log-forwarding
    method: POST
- name: get-migration
  endpoint:
    path: /gateway-get-migration
    method: POST
- name: get-producer
  endpoint:
    path: /gateway-get-producer
    method: POST
- name: get-remote-access
  endpoint:
    path: /gateway-get-remote-access
    method: POST
- name: alias_details
  endpoint:
    path: /alias-details
    method: POST
    data_selector: json
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create
    method: POST
    data_selector: response
    params: {}
- name: iam_user_mode
  endpoint:
    path: /dynamic-secrets/aws/iam_user
    method: POST
    data_selector: credentials
    params: {}
- name: assumed_role_mode
  endpoint:
    path: /dynamic-secrets/aws/assumed_role
    method: POST
    data_selector: credentials
    params: {}
- name: dynamic_aws_secret
  endpoint:
    path: /dynamic-secret/create/aws
    method: POST
- name: dynamic_aws_secret
  endpoint:
    path: /dynamic-secret/get-value
    method: GET
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create
    method: POST
    data_selector: result
- name: mysql
  endpoint:
    path: /dynamic-secret/create/mysql
    method: POST
    data_selector: result
- name: postgresql
  endpoint:
    path: /dynamic-secret/create/postgresql
    method: POST
    data_selector: result
- name: redshift
  endpoint:
    path: /dynamic-secret/create/redshift
    method: POST
    data_selector: result
- name: mssql
  endpoint:
    path: /dynamic-secret/create/mssql
    method: POST
    data_selector: result
- name: mongodb
  endpoint:
    path: /dynamic-secret/create/mongodb
    method: POST
    data_selector: result
- name: oracledb
  endpoint:
    path: /dynamic-secret/create/oracledb
    method: POST
    data_selector: result
- name: cassandra
  endpoint:
    path: /dynamic-secret/create/cassandra
    method: POST
    data_selector: result
- name: hanadb
  endpoint:
    path: /dynamic-secret/create/hanadb
    method: POST
    data_selector: result
- name: redis
  endpoint:
    path: /dynamic-secret/create/redis
    method: POST
    data_selector: result
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create
    method: POST
    data_selector: response
    params: {}
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/get-value
    method: GET
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create/github
    method: POST
    data_selector: response
    params: {}
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create/gitlab
    method: POST
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create/gke
    method: POST
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret
    method: POST
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret
    method: POST
    data_selector: results
    params:
      name: <Dynamic Secret Name>
      target-name: <Target Name>
      rabbitmq-user-conf-permission: <User configuration permission>
      rabbitmq-user-write-permission: <User write permission>
      rabbitmq-user-read-permission: <User read permission>
      password-length: 16
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret
    method: GET
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create/snowflake
    method: POST
    data_selector: results
- name: sync_create
  endpoint:
    path: /sync/create
    method: POST
- name: sync_revoke
  endpoint:
    path: /sync/revoke
    method: POST
- name: sync_rotate
  endpoint:
    path: /sync/rotate
    method: POST
- name: Rotated Secret
  endpoint:
    path: /rotated-secret/create/aws
    method: POST
    data_selector: results
- name: rotated_secret
  endpoint:
    path: /api/v1/rotated_secret
    method: POST
    data_selector: data
- name: rotated_secret
  endpoint:
    path: /rotated-secret/create
    method: POST
    data_selector: result
    params: {}
- name: Rotated Secret
  endpoint:
    path: /create-an-ssh-rotated-secret
    method: POST
- name: rotated_secret
  endpoint:
    path: /rotated-secret/create/windows
    method: POST
    data_selector: response
    params:
      name: <Rotated Secretsecret name>
      target-name: <Windows target name to associate>
      password-length: 16
      rotator-type: password
      rotated-username: <username>
      rotated-password: <password>
      user-dn: <Base DN to perform user search>
      auto-rotate: <true|false>
      rotation-interval: <1-365>
      rotation-hour: <hour in UTC>
- name: validate_producer_credentials
  endpoint:
    path: /validate-producer-credentials
    method: POST
    data_selector: creds
    params: {}
- name: Rotated Secret
  endpoint:
    path: /rotated-secret/create/custom
    method: POST
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: artifactory_target
  endpoint:
    path: /api/targets
    method: POST
    data_selector: target
    params: {}
- name: aws_target
  endpoint:
    path: /aws/target
    method: POST
    data_selector: target
    params: {}
- name: azure_ad_target
  endpoint:
    path: /target/create/azure
    method: POST
    params: {}
- name: Chef Infra Target
  endpoint:
    path: /targets/infra/chef
    method: POST
    data_selector: target
    params: {}
- name: snowflake_target
  endpoint:
    params: {}
- name: database_targets
  endpoint:
    path: /api/database/targets
    method: GET
- name: dockerhub_target
  endpoint:
    path: /dockerhub/target
    method: POST
- name: github_target
  endpoint:
    path: /targets/github
    method: POST
- name: gitlab_target
  endpoint:
    path: /target/create
    method: POST
    data_selector: target
    params: {}
- name: globalsign_target
  endpoint:
    path: /api-gw
    method: POST
    data_selector: target
    params: {}
- name: globalsign-atlas
  endpoint:
    path: /create/globalsign-atlas
    method: POST
    data_selector: response
    params: {}
- name: GoDaddyTarget
  endpoint:
    path: /api/v1/godaddy/target
    method: POST
- name: generic_k8s_target
  endpoint:
    path: /k8s
    method: POST
    data_selector: target
    params:
      k8s-cluster-endpoint: <K8S Cluster endpoint>
      k8s-cluster-ca-cert: <K8S Cluster certificate>
      k8s-cluster-token: <K8S Cluster authentication token>
- name: Bearer Token
  endpoint:
    params:
      Bearer Token: Provide a JWT authentication token authorized to manage ServiceAccount
        tokens, Roles, and Role Binding, depending on the working mode.
      Cluster CA Certificate: Provide the K8s cluster CA certificate (PEM format)
      Cluster Endpoint URL: Specify the URL of the cluster.
      Cluster Name: Optional. Set the K8s cluster name.
- name: Client Certificate
  endpoint:
    params:
      Client Certificate: Provide the K8s client certificate (PEM format).
      Client Private Key: Provide the K8s client private key (PEM format).
      Cluster CA Certificate: Provide the K8s cluster CA certificate (PEM format).
      Cluster Endpoint URL: Specify the URL of the cluster.
      Cluster Name: Optional. Set the K8s cluster name.
- name: GW Service Account
  endpoint:
    params:
      Cluster Name: Optional. Set the K8s cluster name.
      Cluster Endpoint URL: Specify the URL of the cluster.
- name: ldap_target
  endpoint:
    path: /target/create/ldap
    method: POST
    data_selector: results
- name: Linked Target
  endpoint:
    path: /targets/new/infra/linked
    method: POST
- name: ping_target
  endpoint:
    path: /target/create/ping
    method: POST
    data_selector: results
    params: {}
- name: rabbitmq_target
  endpoint:
    path: /targets/rabbitmq
    method: POST
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: sectigo_target
  endpoint:
    path: /api/gw
    method: POST
    data_selector: target
    params: {}
- name: ssh_target
  endpoint:
    path: /target/create/ssh
    method: POST
    params: {}
- name: Web Target
  endpoint:
    path: /api/web/target
    method: POST
- name: Venafi Cloud
  endpoint:
    path: /cloud
    method: GET
- name: Trust Protection Platform
  endpoint:
    path: /tpp
    method: GET
- name: zerossl_target
  endpoint:
    path: /target/create/zerossl
    method: POST
    data_selector: result
    params: {}
- name: admin_role
  endpoint:
    path: /admin/roles
    method: GET
    data_selector: roles
    params: {}
- name: audit_logs
  endpoint:
    path: /audit/logs
    method: GET
    data_selector: logs
    params: {}
- name: analytics
  endpoint:
    path: /analytics/reports
    method: GET
    data_selector: reports
    params: {}
- name: azure-ad-auth-method
  endpoint:
    path: /auth-method/create/azure-ad
    method: POST
- name: k8s_auth_method
  endpoint:
    path: /auth-method/create/k8s
    method: POST
    data_selector: access_id
    params: {}
- name: k8s_auth_config
  endpoint:
    path: /gateway-create-k8s-auth-config
    method: POST
    data_selector: authentication
    params: {}
- name: gateway-token-reviewer
  endpoint:
    path: /secrets/gateway-token-reviewer
    method: GET
    data_selector: data.token
    params: {}
- name: gateway-token-reviewer-token
  endpoint:
    path: /secrets/gateway-token-reviewer-token
    method: GET
    data_selector: data.token
    params: {}
- name: k8s-ca-cert
  endpoint:
    path: /config/view
    method: GET
    data_selector: clusters[].cluster.certificate-authority-data
    params: {}
- name: k8s-auth-config
  endpoint:
    path: /gateway-create-k8s-auth-config
    method: POST
    data_selector: response
    params: {}
- name: LDAP Authentication Method
  endpoint:
    path: /users/auth-methods/ldap
    method: POST
    data_selector: authenticationMethod
    params: {}
- name: auth_method
  endpoint:
    path: /auth-methods
    method: POST
- name: OIDC Authentication Method
  endpoint:
    path: /auth-method/create
    method: POST
    data_selector: result
- name: saml-auth-method
  endpoint:
    path: /auth-method/create/saml
    method: POST
- name: saml_auth_method
  endpoint:
    path: /auth-method/create
    method: POST
    data_selector: result
    params:
      name: my Okta app
      idp_metadata_url: <your-idp-metadata-url>
      unique_identifier: email
- name: Ping Identity Application
  endpoint:
    path: /saml/metadata
    method: GET
- name: saml_authentication
  endpoint:
    path: /auth-method/create/saml
    method: POST
    data_selector: result
    params: {}
- name: auth-method
  endpoint:
    path: /auth-method/create
    method: POST
    data_selector: result
    params:
      name: <Auth Method Name>
      ttl: 60
- name: Access Permissions
  endpoint:
    path: /docs/log-forwarding
    method: GET
- name: Cluster Name & URL
  endpoint:
    path: /docs/cluster-name-url
    method: GET
- name: Encryption Key
  endpoint:
    path: /docs/encryption-key
    method: GET
- name: Customer Fragment
  endpoint:
    path: /docs/customer-fragment
    method: GET
- name: Version Selection
  endpoint:
    path: /docs/version-selection
    method: GET
- name: TLS Configuration
  endpoint:
    path: /docs/tls-configuration
    method: GET
- name: Cache Configuration
  endpoint:
    path: /docs/cache-configuration
    method: GET
- name: Restrict Gateway Access
  endpoint:
    path: /docs/restrict-gateway-access
    method: GET
- name: Default Secret Encryption
  endpoint:
    path: /docs/default-secret-encryption
    method: GET
- name: Default Secret Location
  endpoint:
    path: /docs/default-secret-location
    method: GET
- name: Setting a Default Login
  endpoint:
    path: /docs/setting-a-default-login
    method: GET
- name: Fixed Artifact Repository
  endpoint:
    path: /docs/fixed-artifact-repository
    method: GET
- name: Rate Limit
  endpoint:
    path: /docs/rate-limit
    method: GET
- name: RHEL Image
  endpoint:
    path: /docs/rhel-image
    method: GET
- name: log_forwarding
  endpoint:
    path: /log/forwarding
    method: POST
    data_selector: logs
    params:
      target_log_type: google_chronicle
      target_google_chronicle_customer_id: <Unique identifier for the Chronicle instance>
      target_google_chronicle_region: <Region where the customer account is provisioned>
      target_google_chronicle_log_type: <Log type>
- name: access-key
  endpoint:
    path: /api/v1
    method: POST
- name: customCA
  endpoint:
    path: customCA
    method: undefined
    data_selector: undefined
    params: {}
- name: metrics
  endpoint:
    path: /metrics
    method: GET
    data_selector: exporters
    params: {}
- name: logs
  endpoint:
    path: /logs
    method: GET
    data_selector: receivers
    params: {}
- name: syslog
  endpoint:
    path: /gateway/update/log-forwarding/syslog
    method: POST
    data_selector: output
    params: {}
- name: splunk
  endpoint:
    path: /gateway/update/log-forwarding/splunk
    method: POST
    data_selector: output
    params: {}
- name: logstash
  endpoint:
    path: /gateway/update/log-forwarding/logstash
    method: POST
    data_selector: output
    params: {}
- name: elasticsearch
  endpoint:
    path: /gateway/update/log-forwarding/elasticsearch
    method: POST
    data_selector: output
    params: {}
- name: logz-io
  endpoint:
    path: /gateway/update/log-forwarding/logz-io
    method: POST
    data_selector: output
    params: {}
- name: aws-s3
  endpoint:
    path: /gateway/update/log-forwarding/aws-s3
    method: POST
    data_selector: output
    params: {}
- name: azure-analytics
  endpoint:
    path: /gateway/update/log-forwarding/azure-analytics
    method: POST
    data_selector: output
    params: {}
- name: stdout
  endpoint:
    path: /gateway/update/log-forwarding/stdout
    method: POST
    data_selector: output
    params: {}
- name: datadog
  endpoint:
    path: /gateway/update/log-forwarding/datadog
    method: POST
    data_selector: output
    params: {}
- name: sumologic
  endpoint:
    path: /gateway/update/log-forwarding/sumologic
    method: POST
    data_selector: output
    params: {}
- name: hsm
  endpoint:
    path: /hsm/configuration
    method: POST
    data_selector: hsm
    params:
      accessMode: ReadWriteMany
      size: 100Mi
- name: customer_fragments
  endpoint:
    path: /api/v1/customer_fragments
    method: POST
    data_selector: customer_fragments
- name: container_app
  endpoint:
    path: /containerapp/create
    method: POST
    data_selector: response
    params:
      name: akeyless-gw-app
      resource-group: akeyless-gw-rg
      environment: akeyless-gw-env
      image: akeylessgwacr.azurecr.io/gateway:latest-container-app
      registry-server: akeylessgwacr.azurecr.io
      cpu: 4.0
      memory: 8.0Gi
      ingress: external
      target-port: 8000
      env-vars:
        GATEWAY_ACCESS_ID: <AccessID>
        GATEWAY_ACCESS_TYPE: azure
        ALLOWED_ACCESS_PERMISSIONS: '[{"access_id":"<AccessID>","name":"Administrators"}]'
        AKEYLESS_URL: https://vault.akeyless.io
        CLUSTER_NAME: Akeyless-GW-Container-APP
        CUSTOMER_FRAGMENTS: '{"customer_fragments":[{"id":"CF-ID","value":"CF-Value","name":"CF-Name","fragment_type":"CF-Type"}]}'
- name: gateway_configuration
  endpoint:
    path: /api/gateway/configuration
    method: GET
    data_selector: data
    params: {}
- name: audit_log
  endpoint:
    path: /log/audit
    method: POST
    data_selector: log_entries
- name: certificate_store
  endpoint:
    path: /gateway/certificate-store
    method: GET
    data_selector: certificates
    params: {}
- name: Console
  endpoint:
    path: /console
    method: GET
- name: Vault
  endpoint:
    path: /vault
    method: GET
- name: Auth
  endpoint:
    path: /auth
    method: GET
- name: Audit
  endpoint:
    path: /audit
    method: GET
- name: BIS
  endpoint:
    path: /bis
    method: GET
- name: Gator
  endpoint:
    path: /gator
    method: GET
- name: MQ
  endpoint:
    path: /mq
    method: GET
- name: KFM
  endpoint:
    path: /kfm
    method: GET
- name: Public Gateway
  endpoint:
    path: /public-gateway
    method: GET
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
- name: classic_key
  endpoint:
    path: /create-classic-key
    method: POST
    data_selector: key_info
    params: {}
- name: target
  endpoint:
    path: /create-target
    method: POST
    data_selector: target_info
    params: {}
- name: AWS KMS
  endpoint:
    path: /docs/aws-kms
    method: GET
- name: Azure Key Vault
  endpoint:
    path: /docs/azure-kms
    method: GET
- name: Google Cloud EKM
  endpoint:
    path: /docs/gcp-kms
    method: GET
- name: Salesforce Shield
  endpoint:
    path: /docs/salesforce-shield
    method: GET
- name: classic_key
  endpoint:
    path: /docs/classic-keys
    method: POST
    data_selector: key
    params: {}
- name: azure_target
  endpoint:
    path: /docs/azure-targets
    method: POST
    data_selector: target
    params: {}
- name: GCP Target
  endpoint:
    path: /docs/gcp-targets
    method: POST
    data_selector: target
- name: Classic Key
  endpoint:
    path: /docs/classic-keys
    method: POST
    data_selector: key
- name: kmip_server
  endpoint:
    path: /kmip/default
    method: POST
    data_selector: objects
- name: kmip_client
  endpoint:
    path: /kmip/client
    method: POST
    data_selector: clients
- name: tokenizer
  endpoint:
    path: /api/tokenizer
    method: POST
    data_selector: tokenizers
    params: {}
- name: pkcs11_configuration
  endpoint:
    path: /var/akeyless/conf/pkcs11.conf
    method: CREATE
    data_selector: config
- name: Classic Key
  endpoint:
    path: /services/data/vXX.X/sobjects/ClassicKey
    method: POST
- name: create-classic-key
  endpoint:
    path: /create-classic-key
    method: POST
    data_selector: key_creation
    params:
      name: <key name>
      alg: gpg
      gpg-alg: <algorithm type>
      gateway-url: https://<Your_Akeyless_GW_URL:8000>
- name: encrypt-gpg
  endpoint:
    path: /encrypt-gpg
    method: POST
    data_selector: encryption
    params:
      key_name: <Key name>
      display-id: <Display id of the key to use in the encryption process>
      item-id: <Item id of the key to use in the encryption process>
      in: <Path to the file to be encrypted in base64 format>
- name: decrypt-gpg
  endpoint:
    path: /decrypt-gpg
    method: POST
    data_selector: decryption
    params:
      key-name: <Key Name>
      ciphertext: <Ciphertext to be decrypt in base64 encoded format>
      display-id: <Display id of the key to use in the encryption process>
      item-id: <Item id of the key to use in the encryption process>
- name: sign-gpg
  endpoint:
    path: /sign-gpg
    method: POST
    data_selector: signing
    params:
      key-name: <RSA signing key name>
      message: <Message to sign>
      display-id: <Display id of the key to use in the decryption process>
      item-id: <Item id of the key to use in the encryption process>
- name: verify-gpg
  endpoint:
    path: /verify-gpg
    method: POST
    data_selector: verification
    params:
      key-name: <RSA Key>
      message: <message to verify>
      signature: <message signature>
      display-id: <Display id of the key to use in the decryption process>
      item-id: <Item id of the key to use in the encryption process>
- name: PKI Cert Issuer
  endpoint:
    path: /items/new/pki-cert-issuer
    method: POST
- name: Certificate Signing Request
  endpoint:
    path: /generate-csr
    method: POST
- name: revoke_certificate
  endpoint:
    path: /revoke-certificate
    method: POST
    data_selector: certificate
    params: {}
- name: issue_certificate
  endpoint:
    path: /issue-certificate
    method: POST
    data_selector: certificate
    params: {}
- name: Chain of Trust
  endpoint:
    path: /generate-ca
    method: POST
    data_selector: certificate_chain
    params:
      pki-chain-name: My-First-Chain
      allowed-domains: example.com
      extended-key-usage: clientauth
      ttl: 10d
- name: generate_csr
  endpoint:
    path: /docs/cli-reference-certificates#p-stylecolorbluegenerate-csrp
    method: POST
    data_selector: csr
    params:
      name: <key name>
      common-name: example.com
- name: get_pki_certificate
  endpoint:
    path: /docs/cli-reference-certificates#get-pki-certificate
    method: POST
    data_selector: certificate
    params:
      cert-issuer-name: /My-First-Chain/pki/issuers/intermediate/issuer
      csr-file-path: example.csr
- name: PKI Cert Issuer
  endpoint:
    path: /create-pki-cert-issuer
    method: POST
    data_selector: certificate_issuer
    params:
      name: <PKI Issuer name>
      ca-target: <Path/To/Target>
      ttl: '7776000'
      allowed-domains: <domain1.com,domain2.com>
      destination-path: </Certificate/Storage/Folder>
      expiration-event-in: '5'
- name: Certificate Signing Request
  endpoint:
    path: /generate-csr
    method: POST
    data_selector: csr
    params:
      name: <Name/of/New/Classic-Key>
      alg: <RSA1024>
      common-name: <common name to be included in the CSR certificate>
      gateway-url: <https://Akeyless-Gateway-URL:8000>
- name: PKI Certificate
  endpoint:
    path: /get-pki-certificate
    method: POST
    data_selector: certificate
    params:
      cert-issuer-name: <PKI Issuer name>
      csr-file-path: MyCSR.csr
- name: Certificate Value
  endpoint:
    path: /get-certificate-value
    method: POST
    data_selector: certificate_value
    params:
      cert-issuer-name: <Issuer Name>
      display-id: <Certificate display ID>
- name: certificate
  endpoint:
    path: /create-certificate
    method: POST
- name: deactivate_external_account
  endpoint:
    path: /deactivate-acme-account
    method: POST
    data_selector: ''
    params:
      cert-issuer-name: /ACME/Server/ACMEIssuer
      acme-account-id: <account-id>
      delete-account: 'true'
- name: pki_cert_issuer
  endpoint:
    path: /acme/issuer
    method: POST
    data_selector: issuer_info
- name: external_accounts
  endpoint:
    path: /acme/accounts
    method: GET
    data_selector: accounts
- name: kubectl_access
  endpoint:
    path: /api/v1/kubectl
    method: GET
    data_selector: records
- name: trustpolicy
  endpoint:
    path: /trustpolicy.json
    method: POST
    data_selector: trustPolicies
    params: {}
- name: Gateway Configuration Manager
  endpoint:
    path: /gateway-configuration-manager
    method: GET
- name: SSH Access
  endpoint:
    path: /ssh-access
    method: GET
- name: authorizedAccessIDs
  endpoint:
    path: /
    method: POST
    data_selector: authorizedAccessIDs
    params: {}
- name: sra
  endpoint:
    path: /
    method: POST
    data_selector: sra
    params: {}
- name: webConfig
  endpoint:
    path: /
    method: POST
    data_selector: webConfig
    params: {}
- name: sshConfig
  endpoint:
    path: /
    method: POST
    data_selector: sshConfig
    params: {}
- name: persistence
  endpoint:
    path: /
    method: POST
    data_selector: persistence
    params: {}
- name: RDP/SSH User Access
  endpoint:
    path: /remote-access/rdp-ssh-user-access
    method: UPDATE
    data_selector: null
    params:
      rdp-target-configuration: <your-sub-claim>
      ssh-target-configuration: <your-sub-claim>
- name: dispatcher
  endpoint:
    path: /services/data/vXX.X/sobjects/Dispatcher
    method: GET
    data_selector: records
- name: RDP Session Recordings
  endpoint:
    path: /services/data/vXX.X/sobjects/RDPRecordings
    method: POST
    data_selector: records
    params: {}
- name: Akeyless Connect
  endpoint:
    path: /connect
    method: POST
- name: aws-s3
  endpoint:
    path: /remote-access-session-forwarding/aws-s3
    method: POST
    params:
      enable: true
- name: azure-analytics
  endpoint:
    path: /remote-access-session-forwarding/azure-analytics
    method: POST
    params:
      enable: true
- name: datadog
  endpoint:
    path: /remote-access-session-forwarding/datadog
    method: POST
    params:
      enable: true
- name: elasticsearch
  endpoint:
    path: /remote-access-session-forwarding/elasticsearch
    method: POST
    params:
      enable: true
- name: google-chronicle
  endpoint:
    path: /remote-access-session-forwarding/google-chronicle
    method: POST
    params:
      enable: true
- name: logstash
  endpoint:
    path: /remote-access-session-forwarding/logstash
    method: POST
    params:
      enable: true
- name: logz-io
  endpoint:
    path: /remote-access-session-forwarding/logz-io
    method: POST
    params:
      enable: true
- name: splunk
  endpoint:
    path: /remote-access-session-forwarding/splunk
    method: POST
    params:
      enable: true
- name: stdout
  endpoint:
    path: /remote-access-session-forwarding/stdout
    method: POST
    params:
      enable: true
- name: sumologic
  endpoint:
    path: /remote-access-session-forwarding/sumologic
    method: POST
    params:
      enable: true
- name: syslog
  endpoint:
    path: /remote-access-session-forwarding/syslog
    method: POST
    params:
      enable: true
- name: SSH Certificate
  endpoint:
    path: /items/new/ssh-cert-issuer
    method: POST
    data_selector: cert_issuer
    params: {}
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/update/rdp
    method: POST
    data_selector: response
    params:
      name: <dynamic secret name>
      secure-access-enable: 'true'
      secure-access-host: <hostname or IP>
      secure-access-rdp-domain: <domain name>
- name: rotated_secret
  endpoint:
    path: /rotated-secret/update/windows
    method: POST
    data_selector: response
    params:
      name: <rotated secret name>
      secure-access-enable: 'true'
      secure-access-host: <hostname or IP>
      secure-access-rdp-domain: <domain name>
      rotate-after-disconnect: <true|false>
- name: file_download
  endpoint:
    path: /Download
    method: POST
- name: file_upload
  endpoint:
    path: /Upload
    method: POST
- name: AWS Console
  endpoint:
    path: /aws/console
    method: GET
- name: AWS Console Access
  endpoint:
    path: /v1/aws-console-access
    method: POST
    data_selector: data
    params: {}
- name: Dynamic Secret
  endpoint:
    path: /dynamic-secret/update/azure
    method: POST
    data_selector: response
    params:
      secure-access-enable: 'true'
      secure-access-web-browsing: <true/false>
- name: Rotated Secret
  endpoint:
    path: /rotated-secret/update/azure
    method: POST
    data_selector: response
    params:
      secure-access-enable: 'true'
      secure-access-web-browsing: <true/false>
      secure-access-url: <URL to inject secrets>
      rotate-after-disconnect: <true|false>
- name: SSH Cert Issuer
  endpoint:
    path: /update-ssh-cert-issuer
    method: POST
    data_selector: response
    params:
      secure-access-enable: 'true'
      secure-access-api: <ssh-sra service control API endpoint URL>
      secure-access-ssh: <ssh-sra service server IP and Port>
      secure-access-ssh-creds-user: <SSH username>
      host-provider: explicit
      secure-access-host: <remote host>
- name: K8s Cluster
  endpoint:
    path: /k8s/cluster
    method: POST
    data_selector: details
    params:
      endpoint_url: Cluster Endpoint URL
      certificate_issuer: certificate-issuer
      allow_port_forwarding: Allow Port Forwarding
- name: Web Access
  endpoint:
    path: /k8s/web
    method: POST
    data_selector: details
    params:
      dashboard_url: Dashboard URL
      secure_web_browsing: Secure Web Browsing
- name: CLI Access
  endpoint:
    path: /k8s/cli
    method: POST
    data_selector: details
    params:
      certificate_issuer: certificate-issuer
      allow_port_forwarding: Allow Port Forwarding
- name: Universal Certificates
  endpoint:
    path: /services/azure/universal_certificates
    method: GET
    data_selector: certificates
    params: {}
- name: usc
  endpoint:
    path: /usc
    method: POST
    data_selector: secrets_list
- name: usc
  endpoint:
    path: /usc
    method: GET
    data_selector: secrets_list
- name: usage_report
  endpoint:
    path: /password-manager/usage-report
    method: GET
- name: password_list
  endpoint:
    path: /passwords
    method: GET
    data_selector: passwords
    params: {}
- name: autofill_service
  endpoint:
    path: /autofill/service
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: secrets
  endpoint:
    path: /api/v1/secrets
    method: GET
    data_selector: data
    params: {}
- name: secret
  endpoint:
    path: /api/v1/secrets
    method: GET
    data_selector: records
    params: {}
- name: manual_otp
  endpoint:
    path: /manual/otp
    method: POST
    data_selector: otp_auth_secrets
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: ldap_gateway
  endpoint:
    path: /configure-ldap-gateway-url
    method: GET
- name: passkey_details
  endpoint:
    path: /passkey/details
    method: GET
    data_selector: fields_displayed
    params: {}
- name: login_using_passkey
  endpoint:
    path: /passkey/login
    method: POST
    data_selector: steps
    params: {}
- name: create_new_passkey
  endpoint:
    path: /passkey/create
    method: POST
    data_selector: creation_steps
    params: {}
- name: delete-items
  endpoint:
    path: /delete-items
    method: POST
    data_selector: items
    params:
      path: <Path\do\delete\items>
- name: list-items
  endpoint:
    path: /list-items
    method: GET
    data_selector: items
    params:
      type: '[key, static-secret, dynamic-secret, rotated-secret, ssh-cert-issuer,
        pki-cert-issuer, classic-key]'
      pagination-token: --pagination-token
      auto-pagination: --auto-pagination[=enabled]
- name: list-sra-bastions
  endpoint:
    path: /list-sra-bastions
    method: GET
    data_selector: bastions
    params:
      only-allowed-urls: --only-allowed-urls[=false]
- name: move-objects
  endpoint:
    path: /move-objects
    method: POST
    data_selector: moved_objects
    params:
      source: <Source path to move the objects from>
      target: <Target path to move the objects to>
      objects-type: <The objects type to move (item/auth_method/role)>
- name: configure
  endpoint:
    path: /configure
    method: POST
    data_selector: configured_profile
    params:
      profile: --profile[=default]
      access-id: --access-id
      access-key: --access-key
      access-type: --access-type[=access_key]
      admin-password: --admin-password
      admin-email: --admin-email
      oidc-sp: --oidc-sp
      azure_ad_object_id: --azure_ad_object_id
      gcp-audience: --gcp-audience
      gateway-url: --gateway-url
      k8s-auth-config-name: --k8s-auth-config-name
      k8s-token-path: --k8s-token-path[=/var/run/secrets/kubernetes.io/serviceaccount/token]
      cert-file-name: --cert-file-name
      cert-data: --cert-data
      key-file-name: --key-file-name
      key-data: --key-data
- name: unconfigure
  endpoint:
    path: /unconfigure
    method: POST
    data_selector: unconfigured_profile
    params:
      profile: <Profile name>
- name: create_auth_method
  endpoint:
    path: /auth-method/create/k8s
    method: POST
- name: gateway_create_k8s_auth_config
  endpoint:
    path: /gateway-create-k8s-auth-config
    method: POST
- name: update_auth_method
  endpoint:
    path: /update-auth-method-k8s
    method: PUT
- name: get_k8s_auth_config
  endpoint:
    path: /gateway-get-k8s-auth-config
    method: GET
- name: delete_k8s_auth_config
  endpoint:
    path: /gateway-delete-k8s-auth-config
    method: DELETE
- name: create_auth_method
  endpoint:
    path: /auth-method/create/ldap
    method: POST
    data_selector: result
- name: update_auth_method
  endpoint:
    path: /auth-method/update/ldap
    method: POST
    data_selector: result
- name: gateway_update_ldap_auth_config
  endpoint:
    path: /gateway/update/ldap-auth-config
    method: POST
    data_selector: result
- name: get_ldap_auth_config
  endpoint:
    path: /gateway/get/ldap-auth-config
    method: GET
    data_selector: result
- name: create_auth_method
  endpoint:
    path: /auth-method/create/universal-identity
    method: POST
    data_selector: null
    params:
      name: <Auth method name>
      ttl: <Token TTL>
- name: uid_create_child_token
  endpoint:
    path: /uid/create/child-token
    method: POST
    data_selector: null
    params:
      child-deny-rotate: null
      child-deny-inheritance: null
- name: uid_generate_token
  endpoint:
    path: /uid/generate/token
    method: POST
    data_selector: null
    params:
      auth-method-name: <Auth method name>
- name: uid_list_children
  endpoint:
    path: /uid/list/children
    method: GET
    data_selector: null
    params:
      auth-method-name: <UID Auth Method Name>
- name: uid_revoke_token
  endpoint:
    path: /uid/revoke/token
    method: POST
    data_selector: null
    params:
      revoke-type: <revokeSelf/revokeAll>
      revoke-token: <UID Token ID>
      auth-method-name: <Auth method name>
- name: uid_rotate_token
  endpoint:
    path: /uid/rotate/token
    method: POST
    data_selector: null
    params:
      token: <Universal identity token>
      fork: null
      send-manual-ack-token: null
      with-manual-ack: null
      output-file: null
      input-file: null
- name: update_auth_method
  endpoint:
    path: /auth-method/update/universal-identity
    method: POST
    data_selector: null
    params:
      new-name: <Auth method new name>
      name: <Auth method name>
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: create_auth_method
  endpoint:
    path: /auth-method/create
    method: POST
    data_selector: method
    params:
      name: <Auth method name>
      krb5conf-file-path: path/to/krb5.conf
      keytab-file-path: path/to/keytab
      ldap-url: ldap://ldap.domain.com:389
- name: update_auth_method
  endpoint:
    path: /auth-method/update
    method: POST
    data_selector: method
    params:
      name: <Auth method name>
      new-name: <Auth Method new name>
      krb5conf-file-path: path/to/krb5.conf
      keytab-file-path: path/to/keytab
      ldap-url: ldap://ldap.domain.com:389
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: assoc-role-am
  endpoint:
    path: /assoc-role-am
    method: POST
- name: create-role
  endpoint:
    path: /create-role
    method: POST
- name: delete-assoc
  endpoint:
    path: /delete-assoc
    method: DELETE
- name: delete-role
  endpoint:
    path: /delete-role
    method: DELETE
- name: delete-role-rule
  endpoint:
    path: /delete-role-rule
    method: DELETE
- name: delete-roles
  endpoint:
    path: /delete-roles
    method: DELETE
- name: describe-permissions
  endpoint:
    path: /describe-permissions
    method: GET
- name: get-role
  endpoint:
    path: /get-role
    method: GET
- name: list-roles
  endpoint:
    path: /list-roles
    method: GET
- name: request-access
  endpoint:
    path: /request-access
    method: POST
- name: reverse-rbac
  endpoint:
    path: /reverse-rbac
    method: GET
- name: set-role-rule
  endpoint:
    path: /set-role-rule
    method: POST
- name: update-assoc
  endpoint:
    path: /update-assoc
    method: PUT
- name: update-role
  endpoint:
    path: /update-role
    method: PUT
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: client-delete-rule
  endpoint:
    path: /kmip-client-delete-rule
    method: DELETE
- name: client-set-rule
  endpoint:
    path: /kmip-client-set-rule
    method: POST
- name: create-client
  endpoint:
    path: /kmip-create-client
    method: POST
- name: delete-client
  endpoint:
    path: /delete-client
    method: DELETE
- name: describe-client
  endpoint:
    path: /describe-client
    method: GET
- name: describe-server
  endpoint:
    path: /describe-server
    method: GET
- name: list-clients
  endpoint:
    path: /list-clients
    method: GET
- name: renew-client-certificate
  endpoint:
    path: /renew-client-certificate
    method: POST
- name: renew-server-certificate
  endpoint:
    path: /renew-server-certificate
    method: POST
- name: server-delete
  endpoint:
    path: /server-delete
    method: DELETE
- name: server-setup
  endpoint:
    path: /kmip-server-setup
    method: POST
- name: server-move
  endpoint:
    path: /server-move
    method: POST
- name: set-server-state
  endpoint:
    path: /set-server-state
    method: POST
- name: update
  endpoint:
    path: /usc/update
    method: POST
    params:
      usc_name: usc name
      secret_id: Secret name or id
      value: secret value
- name: create-usc
  endpoint:
    path: /create-usc
    method: POST
    data_selector: result
    params:
      name: <USC name>
      target_to_associate: <target to associate>
- name: usc-create
  endpoint:
    path: /usc/create
    method: POST
    data_selector: result
    params:
      usc_name: <usc name>
      secret_name: <Secret name>
      value: <secret value>
- name: usc-delete
  endpoint:
    path: /usc/delete
    method: DELETE
    data_selector: result
    params:
      usc_name: <usc name>
      secret_id: <Secret name or id>
- name: usc-get
  endpoint:
    path: /usc/get
    method: GET
    data_selector: result
    params:
      usc_name: <usc name>
      secret_id: <Secret name or id>
- name: usc-list
  endpoint:
    path: /usc/list
    method: GET
    data_selector: result
    params:
      usc_name: <USC name>
- name: event_forwarder
  endpoint:
    path: /event-forwarder/get
    method: GET
- name: email_event_forwarder
  endpoint:
    path: /event-forwarder/create/email
    method: POST
    data_selector: result
    params: {}
- name: servicenow_event_forwarder
  endpoint:
    path: /event-forwarder/create/servicenow
    method: POST
    data_selector: result
    params: {}
- name: slack_event_forwarder
  endpoint:
    path: /event-forwarder/create/slack
    method: POST
    data_selector: result
    params: {}
- name: webhook_event_forwarder
  endpoint:
    path: /event-forwarder/create/webhook
    method: POST
    data_selector: result
    params: {}
- name: customer_fragments
  endpoint:
    path: /gateway/list/customer-fragments
    method: GET
- name: update
  endpoint:
    path: /gateway/update
    method: POST
- name: defaults
  endpoint:
    path: /gateway/update/defaults
    method: POST
- name: allowed_access
  endpoint:
    path: /gateway-create-allowed-access
    method: POST
    data_selector: result
    params: {}
- name: update_allowed_access
  endpoint:
    path: /gateway-update-allowed-access
    method: POST
    data_selector: result
    params: {}
- name: delete_gateway_cluster
  endpoint:
    path: /delete-gateway-cluster
    method: DELETE
    data_selector: result
    params: {}
- name: get_config
  endpoint:
    path: /gateway-get-config
    method: GET
    data_selector: result
    params: {}
- name: update_tls_cert
  endpoint:
    path: /gateway-update-tls-cert
    method: POST
    data_selector: result
    params: {}
- name: update_cache
  endpoint:
    path: /update-cache
    method: POST
    data_selector: result
    params: {}
- name: log_forwarding_sumologic
  endpoint:
    path: /log-forwarding/sumologic
    method: UPDATE
    data_selector: configuration
    params:
      enable: 'true'
      output-format: json
      pull-interval: '10'
      endpoint: <endpoint URL>
      sumologic-tags: <Sumologic tags>
      host: <SumoLoginc host>
- name: log_forwarding_syslog
  endpoint:
    path: /log-forwarding/syslog
    method: UPDATE
    data_selector: configuration
    params:
      enable: 'true'
      output-format: json
      pull-interval: '10'
      network: tcp
      host: <host>
      target-tag: <Syslog target tag>
      formatter: text
      enable-tls: <enable tls>
      certificate-file: <path/to/certificate>
      tls-certificate: <Elasticsearch tls certificate>
- name: create_migration
  endpoint:
    path: /gateway-create-migration
    method: POST
    data_selector: null
    params:
      name: <Migration name>
      type: <Migration type>
      target-location: <Target location>
      gateway-url: <API Gateway URL:8000>
- name: delete_migration
  endpoint:
    path: /gateway-delete-migration
    method: DELETE
    data_selector: null
    params:
      id: <Migration ID>
      gateway-url: <API Gateway URL:8000>
- name: get_migration
  endpoint:
    path: /gateway-get-migration
    method: GET
    data_selector: null
    params:
      name: <Migration Name>
      gateway-url: <API Gateway URL:8000>
- name: list_migrations
  endpoint:
    path: /gateway-list-migrations
    method: GET
    data_selector: null
    params:
      gateway-url: <API Gateway URL:8000>
- name: migrate_personal_items
  endpoint:
    path: /gateway-migrate-personal-items
    method: POST
    data_selector: null
    params:
      gateway-url: https://<Your-Akeyless-GW-URL:8000>
      type: <1password>
      protection-key: <Key Name>
      target-location: <Path/To/Target>
      1password-url: <Account Address>
      1password-email: <User Email>
      1password-password: <Users Password>
      1password-secret-key: <Secret Key>
- name: migration_status
  endpoint:
    path: /gateway-migration-status
    method: GET
    data_selector: null
    params:
      name: <Migration Name>
      id: <Migration ID>
      gateway-url: https://<Your-Akeyless-GW-URL:8000>
- name: sync_migration
  endpoint:
    path: /gateway-sync-migration
    method: POST
    data_selector: null
    params:
      name: <Migration Name>
      gateway-url: <API Gateway URL:8000>
      sync: <true/false>
- name: Akeyless K8s Secrets Injector
  endpoint:
    path: /docs/how-to-provision-secret-to-your-k8s
    method: GET
- name: K8s External Secret Operator
  endpoint:
    path: /docs/external-secret-operator
    method: GET
- name: K8s Secrets Store CSI
  endpoint:
    path: /docs/kubernetes-secrets-store-csi-provider
    method: GET
- name: K8s Cert Manager
  endpoint:
    path: /docs/kubernetes-cert-manager
    method: GET
- name: injector
  endpoint:
    path: /services/data/vXX.X/sobjects/Injector
    method: GET
    data_selector: records
- name: namespace1
  endpoint:
    path: /K8s/NameSpaces/Folder/Secrets/namespace1
    method: POST
    data_selector: secret
    params: {}
- name: SecretStore
  endpoint:
    path: /v1/SecretStore
    method: GET
    data_selector: items
    params: {}
- name: ClusterSecretStore
  endpoint:
    path: /v1/ClusterSecretStore
    method: GET
    data_selector: items
    params: {}
- name: ExternalSecret
  endpoint:
    path: /v1/ExternalSecret
    method: GET
    data_selector: items
    params: {}
- name: push-secret
  endpoint:
    path: /pushsecret
    method: POST
    data_selector: spec
    params:
      refreshInterval: 5s
      updatePolicy: Replace
      deletionPolicy: Delete
      secretStoreRefs:
      - name: akeyless-secret-store
        kind: SecretStore
      selector:
        secret:
          name: k8s-created-secret
      data:
      - match:
          remoteRef:
            remoteKey: eso-created/my-secret
- name: secrets-store
  endpoint:
    path: /secrets-store
    method: GET
- name: secret
  endpoint:
    path: /path/to/secret/foo
    method: GET
- name: issuer
  endpoint:
    path: /pki/sign/dev/Pki_Cert_Issuer
    method: POST
    data_selector: issuer
    params: {}
- name: certificate
  endpoint:
    path: /certificates/demo-certificate
    method: POST
    data_selector: certificate
    params: {}
- name: certificate_request
  endpoint:
    path: /certificate.yaml
    method: apply
    data_selector: Normal
    params: {}
- name: certificate_status
  endpoint:
    path: /certificate -n akeyless-cert-manager
    method: describe
    data_selector: Normal
    params: {}
- name: Akeyless Injector
  endpoint:
    path: /docs/how-to-provision-secret-to-your-k8s
    method: GET
    data_selector: secrets
    params: {}
- name: External Secrets Operator
  endpoint:
    path: /external-secrets
    method: GET
    data_selector: secrets
    params: {}
- name: auth-method-api-key
  endpoint:
    path: /terraform-tests/auth-method-api-key-demo
    method: POST
    data_selector: api_key
    params: {}
- name: static-secret
  endpoint:
    path: /terraform-tests/secret
    method: POST
    data_selector: secret
    params: {}
- name: static_secret
  endpoint:
    path: /static_secret
    method: POST
    data_selector: secret
    params: {}
- name: Get certificate value
  endpoint:
    path: /pki/certificate
    method: GET
    data_selector: result.data.data
    params:
      cert_issuer_name: /Ansible/pki_issuer_name
      csr_data_base64: <csr_data_base64>
- name: dynamic_secret
  endpoint:
    path: <Dynamic Secret type>/creds/<Full Secret Name>
    method: GET
    data_selector: password, username
- name: static_secret
  endpoint:
    path: secret/data/DevOps/Ansible
    method: GET
    data_selector: data
    params: {}
- name: json_secret
  endpoint:
    path: secret/DevOps/AnsibleJson
    method: GET
    data_selector: username, password
    params: {}
- name: GitLabAuth
  endpoint:
    path: /Dev/GitLabAuth
    method: POST
- name: GitLabRole
  endpoint:
    path: /Dev/GitLabRole
    method: POST
- name: retrieve_static_secret
  endpoint:
    path: /secrets/static
    method: GET
- name: retrieve_rotated_secret
  endpoint:
    path: /secrets/rotated
    method: GET
- name: issue_certificate
  endpoint:
    path: /certificates/issue
    method: POST
- name: VaultReadKV
  endpoint:
    path: /vault/read
    method: POST
    data_selector: data
    params: {}
- name: Slash Command
  endpoint:
    path: /interactivity/slash-commands
    method: POST
    data_selector: payload
- name: akeyless_auth_method
- name: akeyless_gateway
- name: akeyless_item
- name: akeyless_role
- name: akeyless_target
- name: certificates
  endpoint:
    path: /api/certificates
    method: POST
    data_selector: result
    params: {}
- name: dynamic_secret
  endpoint:
    path: /dynamic-secret/create/venafi
    method: POST
    data_selector: dynamic_secret
    params:
      name: my-venafi-dynamic-secret
      gateway-url: https://<Your-Akeyless-GW-URL:8000>
      venafi-api-key: <YOUR VENAFI API KEY>
      venafi-zone: <YOUR VENAFI ZONE>
      allowed-domains: '[*]'
      allow-subdomains: true
      sign-using-akeyless-pki: true
      signer-key-name: venafi-cloud
      user-ttl: 2160h
- name: Issuer
  endpoint:
    path: /pki/sign/my-cert-automation-dynamic-secret
    method: POST
    data_selector: ''
    params: {}
- name: Certificate
  endpoint:
    path: /cert-manager/certificate
    method: POST
    data_selector: ''
    params: {}
- name: SPIRE Key Manager
  endpoint:
    path: /docs/spire-keymanager
    method: GET
- name: SPIRE Secret Manager
  endpoint:
    path: /docs/spire-secret-manager
    method: GET
- name: SPIRE Upstream Authority
  endpoint:
    path: /docs/spire-upstream-authority
    method: GET
- name: SPIRE Upstream Authority SM
  endpoint:
    path: /docs/spire-upstream-authority-sm
    method: GET
- name: registration_policy
  endpoint:
    path: /entry/create
    method: POST
    data_selector: ''
    params: {}
- name: SVIDStore
  endpoint:
    path: /SPIRE/SVID/
    method: POST
    data_selector: SVID
    params: {}
- name: certificate_item
  endpoint:
    path: /SPIRE/SVID/certificate_name
    method: POST
    data_selector: certificate
    params: {}
notes:
- Uses OAuth2 with refresh token — requires setup of connected app in api
- By configuring these settings, you establish a standardized default for password
  generation in your organization's account. Users can still modify parameters during
  password creation, but the defaults will adhere to the rules you've set.
- Requires setup of connected app in Akeyless
- Akeyless Platform uses various authentication methods with Role-based Access Control.
- The URL for this request expired after 30 days.
- Protect your static secrets, such as connection strings, passwords, tokens, and
  encryption keys, in our encrypted Key/Value store, generate dynamic secrets on-demand
  to support just-in-time access, or automatically rotate privilege credentials.
- 'Akeyless serves two main types of identities: human and machine identities.'
- Our patented technology, Distributed Fragments Cryptography™ (DFC), enables us to
  perform cryptographic operations using fragments of an encryption key, without EVER
  combining the key fragments.
- The key is never constructed, not even during the encryption/decryption process,
  meaning, the key never exists as a whole.
- Uses OAuth2 with refresh token â€” requires setup of connected app in api
- Some objects like Contact may return nulls in deeply nested fields
- Some objects may return nulls in deeply nested fields
- You can also retrieve secret values directly from within a context you choose, such
  as from Kubernetes, Jenkins, Azure, or another of our integrations, or with the
  help of any of our SDKs.
- Changing the metadata of a secret does not change its version. To change the version
  and store the previous version, you must explicitly run --keep-prev-version=true.
- Check out our tutorial video on Sharing a Static Secret.
- When sharing via emails, only the users you've specified their email will be able
  to access the item using this link
- Dynamic secrets are secrets that are generated every time they are accessed, using
  permissions you've defined in advance.
- The configuration required to produce dynamic secrets is part of your private network,
  and are stored on the Akeyless Gateway.
- You can create an Artifactory dynamic secret to allow users to dynamically receive
  short-lived access tokens to interact with a JFrog Artifactory server (v5.0.0 or
  later) via its API.
- Using a target allows you to rotate credentials without breaking the credential
  chain for the objects connected to the server used.
- Temporary IAM users can only be created with access to a single AWS account.
- Assume role is more convenient for immediate actions, as the STS credentials are
  available immediately.
- 'You can define an Azure AD dynamic secret to dynamically generate access credentials
  in one of two modes: Programmatic or Portal.'
- We recommend using dynamic secrets with Targets. It both saves time for multiple
  secret-level configurations and is important for security streamlining.
- Select this checkbox to disable SSL connections.
- We recommend using dynamic secrets with Targets. While it saves time for multiple
  secret-level configurations by not requiring you to provide an inline connection
  string each time, it is also important for security streamlining.
- We recommend using dynamic secrets with Targets. While it saves time for multiple
  secret level configurations by not requiring you to provide an inline connection
  string each time, it is also important for security streamlining.
- Currently Docker Hub dynamic secrets are not supported when two-factor authentication
  (2FA) is enabled on the associated account.
- The IAM principal must be part of the aws-auth ConfigMap that is used for authorization
  to the K8s cluster.
- The K8s role to which the IAM principal in the aws-auth ConfigMap is bound to will
  be the same K8s role that tokens generated by the Dynamic EKS secret will get.
- The IAM principal must have at least the specified role binding in the underlying
  Kubernetes RBAC.
- TTL in GCP is 1 hour by default, but this may be configured for up to 12 hours
- You can define a GitHub Dynamic Secret to generate just-in-time installation access
  tokens for your GitHub repository.
- Tokens are generated based on the GitHub App information.
- Access Token that will be used for authentication with GitLab
- We recommend using dynamic secrets with Targets for better security and management.
- You can create a dynamic Google Kubernetes Engine (GKE) secret to allow users receive
  dynamically access tokens to a GKE cluster.
- The service account itself will serve as the user for each individual connection,
  with access tokens that will last for 60 minutes.
- Fetch a Dynamic Google Workspace Secret value from the Akeyless Console
- Recommends using dynamic secrets with Targets for security streamlining.
- Use of inline connection string may require changing credentials in each individual
  item.
- 'To authorize the producer in your gateway, add the following environment parameter
  as described in Advanced Gateway Configuration: -e PING_FEDERATE_CERTIFICATE= <Your
  Ping Federate server Certificate encoded in base64>'
- You can define a dynamic RabbitMQ secret to generate user credentials dynamically
  based on configured permissions.
- When a client requests a dynamic secret value, the Akeyless Platform connects to
  the target RabbitMQ server through the Gateway and creates a new user.
- We recommend using dynamic secrets with Targets for security streamlining.
- To create a Snowflake dynamic secret, ensure that you have a Snowflake account and
  credentials for the admin user (with the USERADMIN role or higher).
- We recommend using dynamic secrets with Targets.
- Payload rotation is performed on a best-effort basis.
- The Akeyless Platform generates a new password, resets it on the target machine,
  and stores the updated secret value so that it can be retrieved when required.
- You can define a rotated secret to automatically update the password at defined
  intervals, or manually trigger a password update from the CLI or from the Akeyless
  Console.
- Select use-target-creds if the Rotated Secret user is not authorized to change their
  own Access Key.
- Select Target credentials if the Rotated Secret user is not authorized to change
  their own Access Key.
- 'Delete Protection: When enabled, protects the Rotated Secret from accidental deletion.'
- 'Graceful Rotation: When enabled, a graceful mode of rotation will be conducted.'
- Before you get started, ensure creating a Database Target that includes the hostname,
  connection settings, and credentials for a privileged user authorized to rotate
  credentials.
- Check out our tutorial video on Creating and Using MySQL Rotated Secrets
- The password length is optional and defaults to 16.
- Define a Name of the Rotated Secret, and specify the Location as a path to the virtual
  folder where you want to create the new Rotated Secret, using slash `/` separators.
- When enabled, it protects the Rotated Secret from accidental deletion.
- For LDAP targets, this is the only available option.
- Defines the LDAP username which password should be rotated.
- Defines the password to rotate.
- Defines LDAP Base DN settings.
- Defines the LDAP user attribute. The default value is `cn`.
- To enable zero-Knowledge, select a key with a Customer Fragment.
- Determines if automatic rotation is enabled.
- Only Windows/SSH Target are currently supported for Rotated Secrets with Linked
  Target.
- If a host is accessible over a different port, specify the port as part of the host.
- Rotation across multiple hosts will work on a best-effort approach to rotate at
  least one host from the given hosts' list.
- Upon a failure in one or more hosts, the rotation status will be `RotationPartialSucceeded`.
- In case of failure on all hosts, the rotation status will be `RotationFailed`.
- The Rotated Secret item will keep the old password on the hosts which ended with
  an error.
- The Akeyless best practice flow is to generate different passwords for each **Local**
  user.
- You can set an identical password for **all** users by using the flag `same-password
  true`.
- Some distributions like RedHat require a customization of the default rotation statement.
- Select 'use-target-creds' if the Rotated Secret user is not authorized to change
  their own password.
- Select Target credentials if the Rotated Secret user is not authorized to change
  their own password, and a privileged user, like the Windows Target user is required
  to change the password on behalf of the Rotated Secret user.
- Custom Rotated Secret implementations should only handle requests from a known Akeyless
  Gateway instance.
- The best practice for using IAM roles in AWS is to leverage them for granting temporary,
  least-privilege access to resources, rather than relying on long-term access keys
  for users.
- Database targets can include MySQL, PostgreSQL, MSSQL, Redshift, Oracle, MongoDB,
  MongoDB Atlas, Snowflake, Cassandra, SAP HanaDB, and Redis.
- Having a GCP target will allow you to conserve the credentials chain between all
  of your dynamic secrets.
- Akeyless cannot access the private key that signs the certificates.
- Uses OAuth2 authentication
- Requires setup of connected app in api
- Akeyless PKI Issuer does not support approval workflow, make sure your sectigo certificate
  profile is not require 2nd approval.
- For an authentication method to have the necessary permissions to perform actions,
  you will need to attach it to a matching role.
- It is considered a best practice not to use an API key as the authentication method
  associated with your Admin role.
- Logical Operators Syntax support requires Gateway 4.19 version or higher.
- OAuth 2.0/JWT authentication method available.
- Each role can be granted 'Audit Logs' and 'Analytics' permissions.
- AWS IAM authentication doesn't require any privileged permissions. Ensure you have
  an IAM role without any privileged permissions and attach it to the resource you
  want to authenticate (e.g., EC2 instance).
- Make sure to associate your new Authentication Method with an Access Role to grant
  the relevant permissions within Akeyless
- Certificate-based authentication is usually a machine-to-machine authentication
  flow.
- A unique identifier acts as a sub-claim helping to uniquely identify the authenticating
  Identity.
- This authentication method will allow you to invite your teammates to join your
  account and utilize the items and resources in it using their email addresses and
  setting up their own passwords.
- 'GKE Workloads Authentication: When authenticating from a pod inside a Google Kubernetes
  Engine (GKE) cluster using GKE Workload Identity enabled, any bounded rules other
  than `Bound Service Accounts` will not apply.'
- Define a Name for the authentication method
- Expiration Date is optional
- Allowed Client IPs is optional
- Allowed Trusted Gateway IPs is optional
- Audit Log Sub Claims is optional
- GCP Type can be either IAM or GCE
- Bound Projects is optional
- Audience defaults to akeyless.io
- Service Account Credentials are required if no project is provided
- Bound Service Accounts is optional for IAM methods
- Bound Zones is optional for GCE methods
- Bound Regions is optional for GCE methods
- Bound Labels is optional for GCE methods
- Unique Identifier is optional
- The Kubernetes (K8s) Auth Method uses K8s JWTs in order to authenticate the K8s
  application (e.g. a pod).
- To set K8s Authentication method, make sure you have Access Permissions on your
  Gateway to manage the K8s Auth.
- K8s v1.21 or later required.
- Required Gateway Access Permissions
- Save returned private key & AccessID for next steps inside an environment variables
  $PRV_KEY and $ACCESS_ID
- Delete the private key and Access ID which you stored as environment variables $PRV_KEY
  and $ACCESS_ID
- 'To enable and use token request projection on a self-managed cluster, you must
  specify each of the following command line arguments to kube-apiserver: `--service-account-issuer`,
  `--service-account-key-file`, `--service-account-signing-key-file`, `--api-audiences`.'
- K8s won’t generate Secrets automatically for ServiceAccounts in v1.24 or higher.
- Use the Akeyless CLI to create the K8s auth method.
- K8s Client certificate authentication is not supported by EKS.
- This example uses `api` as the ServiceAccount issuer name, for your ServiceAccounts
  API audience.
- Create a Dynamic Group for authenticating resources
- Create a Group to authenticate users
- Configure LDAP gateway url
- Unique Identifier should be a key name, i.e. not the value itself.
- Set the OIDC Auth Method 'Required Scopes' to 'groups' to be included it in the
  sub claims.
- Ensure your OAuth consent configuration includes only authorized domains of your
  organization, and that the User type is set to Internal only.
- Redirect URI set to https://auth.akeyless.io/oidc/callback
- Scopes include 'openid', 'profile', and 'email'
- The Azure AD limit for groups per user is set by default to 150. Users with more
  groups cannot use SAML with Azure.
- The TTL is renewed with every rotation.
- Once authenticated, exchange the UID token for a t-token for better performance.
- If the gwURL parameter is not set to https://<Your-Akeyless-GW-URL:8000/api/v1>,
  it will default to https://rest.akeyless.io
- The script also auto-creates the task-scheduler job, which will rotate your u-token
  every 10 minutes
- Confirm the newly created $HOME\.vault-token file should start refreshing with a
  new u-token every 10 minutes
- Kerberos authentication requires a valid krb5.conf and keytab file.
- Uses OAuth2 for authentication
- This example is only supported on Windows
- Akeyless offers a unique Gateway, which adds an extra level of protection between
  your private network and the cloud.
- Network port `8000` on the cluster must be open only for internal network access.
- Make sure that this server is not globally opened to the public network.
- Using your default account credentials is not recommended for production environments
  and can not work with MFA.
- Akeyless is an official Datadog Partner and our dashboard can be found inside the
  Datadog app.
- This example uses local Loki on Docker.
- Logs will be uploaded to your S3 bucket based on 10 minutes intervals. Keep in mind
  that in case your pod will scale down or restart, logs that were not uploaded to
  your bucket will be lost.
- target_google_chronicle_service_account_key and target_google_chronicle_service_account_key_file
  are mutually exclusive.
- HSM configured to work with PKCS#11
- An AES encryption key that supports the hmac 256 mechanism is relevant for Customer
  Fragment
- API Key Authentication Method requires a dedicated K8s Secret to store the corresponding
  Access Key.
- When enabling TLS, a TLS certificate and corresponding TLS Private Key must be provided.
- Use K8s Secrets for sensitive settings in the Gateway deployment.
- The Gateway application supports uploading Self-Signed and Private Certificates
  to establish trust between Akeyless and the relevant endpoint.
- For some cases, a custom Certificate Authority for closed environments might be
  required to ensure the related service is trusted before the Gateway application
  starts.
- 'Application Logs from all instances of this gateway will be forwarded in the format:
  <date> <time> <gw-clustername-instance-id> <log>'
- To add the Gateway Cluster unique identifier to your logs set the FORWARD_GW_APP_LOG="true"
  environment variable.
- Default format of logs is text.
- Pull interval is set to 10 seconds.
- The HSM must support the C_GenerateRandom operation.
- The K8s secret key name must be set to 'pin'.
- Make sure that this server is not globally opened to the public network. Akeyless
  Gateway requires only connections to Akeyless SaaS Core Services.
- The Gateway URL will be available in the Container App resource in the Overview
  tab, and in the output of the az containerapp create command in the fqdn parameter.
- The use of HTTP protocol is considered insecure and discouraged; thus, remote Gateway
  configuration is not supported over HTTP.
- Gateway Users Authentication does not mean those users will be able to log in and
  manage your Gateway deployment.
- Gateway Admin users can access and manage the Access Permissions settings.
- Logs will be uploaded to your S3 bucket based on 10 minutes intervals.
- Keep in mind that in case your pod will scale down or restart, logs that were not
  uploaded to your bucket will be lost.
- Service Account Key - A JSON file holding service account credentials.
- Customer ID - Unique identifier for the Chronicle instance.
- Region - The region where your customer account is provisioned.
- Log Type - A log type to identify the log entries.
- Some services may require a restart or reconnection to fully recognize and utilize
  the new certificate authority.
- Usually, after the Stale Timeout period expires for a secret, the secret is deleted
  from the Gateway Cache.
- In case there is no internet connection, the Gateway Cache won’t delete old items
  until the internet connection is restored.
- When working with Customer Fragments, it is your responsibility to back them up
  securely and in a safe place.
- To create a DFC encryption key with Customer Fragment, the Auth Method that's being
  used needs to be on the list of allowed access IDs for the gateway.
- Encryption keys created with the Customer Fragment cannot be reconstructed without
  it.
- Only Symmetric encryption keys of AESGCM algorithm can be used as Default Encryption
  Keys.
- If MQ is blocked, you can still retrieve those secrets directly from their own Gateway.
- Without the MQ service, you will need to ensure you are working directly with the
  correct Gateway for each relevant item.
- The MQ service allows for centralized management, enabling you to perform all operations
  from the SaaS console.
- A basic Gateway deployment requires a server with a Docker engine installed.
- Accounts that were created on specific environments should modify the services endpoints
  according to the relevant environments.
- This documentation outlines the requirements and process for enhancing the Encryption/Decryption
  service to support batch processing for large datasets.
- 'Volume: Approximately 400,000 credit card numbers per batch.'
- 'Time Frame: Decryption should be completed within 5-10 minutes.'
- 'Batch Size: Credit card numbers will be processed in batches ranging from 1,000
  to 10,000.'
- 'Algorithm: AES256 with CBC mode.'
- 'Data Length: 16-digit credit card numbers.'
- 'Key Management: Up to 5 active keys are maintained per year. Keys are stored for
  a duration of 5 years, potentially involving up to 25 different keys per batch.'
- Classic Keys are protected by an Akeyless DFC™ key.
- If you are going to share the Classic Key with a cloud KMS, you need to create a
  target for the key to later be associated with.
- Only classic keys can be distributed to cloud KMS providers.
- AWS targets only support AES256GCM type keys.
- When you associate a key with AWS, make sure to reference the alias when using the
  key in AWS. Otherwise, the association will break when you rotate the key.
- Remember to give the Azure Target the Key Vault Administrator permissions to manage
  the Azure Key Vault.
- Any classic key will be protected using the Akeyless DFC key.
- Remember to give the GCP Target the cloud KMS admin permissions to manage the keyring.
- Any classic key will be protected using the Akeyless DFC key (you can select a DFC
  key with Zero-Knowledge Encryption).
- Salesforce supports only AES256GCM keys.
- In Salesforce Data and Analytics keys can be rotated only once in 24 hours, and
  SearchIndex keys can be rotated once in 7 days.
- In Salesforce you're not allowed to disable the active key. You'll need to wait
  for this key to rotate.
- In Salesforce you're not allowed to delete the active key.
- Only users from your Gateway admins list can configure the KMIP server.
- Akeyless Platform provides Tokenization as a service.
- Vaultless tokenization means that a tokenized secret is not stored in the Akeyless
  Platform.
- Uses OAuth2 with refresh token — requires setup of connected app in Akeyless
- The tokenization service is being enhanced to support batch processing for large
  datasets, significantly improving its efficiency, especially for handling high volumes
  of data.
- A caching mechanism is being implemented to further improve the performance of the
  tokenization service, especially for handling the expected 1.5+ trillion operations
  per month.
- Transparent Data Encryption (TDE) is a security feature that provides encryption
  of sensitive data stored in database tables and tablespaces.
- This ensures that the data at rest, i.e., the data stored on disk, is protected
  from unauthorized access.
- Uses Akeyless Platform for key management
- The TDE for MSSQL workflow documented above has been tested only with full SQL Server
  installations on Windows (on-prem or in an Azure 'SQL Virtual Machine').
- 'Not supported: MSSQL in Docker containers (Microsoft does not support TDE in containers).'
- Azure SQL Managed DB / Managed Instance (they only expose Azure Key Vault for external
  keys).
- When working with cluster, the above command should be executed only on the Primary
  server.
- 'To migrate a database with an existing file-based wallet, follow these steps:'
- Ensure to replace with the appropriate password.
- Ensure that Oracle Database is installed and running on your system.
- This guide is written for Oracle 19c RU or later, including all 23ai/23c builds.
- FIPS Certification
- Akeyless integrates natively into diverse environments without requiring external
  secrets.
- The example above demonstrates a very basic usage of Signer key, to support all
  PKI settings you can work with Classic Keys as well to generate a signing key with
  a self-signed certificate.
- To support all PKI settings, you can work with Classic Keys as well to generate
  a signing key with a self-signed certificate.
- In order to view the Certificate Revocation List, the PKI Cert Issuer's signing
  key must include the cRLSign extention.
- Automatic creation of a Chain of Trust is not supported if the Item Naming Convention
  configured in Global Settings contains a literal space character.
- External Account Binding improves security of certificate issuance.
- Multiple external accounts can be created under the same PKI Cert Issuer.
- Short-lived certificate for accessing a Kubernetes cluster via kubectl
- Akeyless Supports both EC and RSA algorithms
- This is a very permissive trust policy.
- Akeyless supports a variety of protocols, including SSH, RDP, SQL, kubectl, and
  more.
- Please note that this guide was tested with AWS EKS and not secured with TLS.
- Akeyless does not require extensive storage for basic operation.
- If session recording is enabled, additional storage will be necessary.
- Unified version allows for dynamic updates from Console UI without redeploying the
  chart.
- Remote Access provides secure remote access to resources using just-in-time credentials
  (dynamic secrets, rotated secrets, and SSH certificates).
- Remote Access is enabled through the Akeyless Gateway Helm chart deployment.
- 'Enable secure-remote-access. Valid values: true/false.'
- This will take effect on all SSH-based sessions, both for RDP and Linux-based systems.
- default is en-us-qwerty
- The HTTP-type proxy will only work with Chrome browsers currently.
- Uses API key authentication â€” requires setup of connected app in akeyless
- When set to true, this option disables the default fullscreen mode for Web Access
  sessions and also shows the internal browser address bar.
- To enable Secure Remote Access features, you will have to get an access key to Akeyless's
  private repository. Please contact your Account Manager for more details.
- Every session update is captured in the Audit Log.
- Any user who initiates a session is permitted to view their own session details.
- If a user has permissions to access one or more SRA application servers, they can
  view all sessions managed by those servers.
- Administrators have full visibility of all sessions within the selected timeframe.
- The Sessions Overview provides administrators and authorized users with the ability
  to view and track the status of SRA sessions.
- Users can choose between using Gateway Identity or providing explicit credentials
  for Azure authentication.
- User provides explicit credentials for Azure authentication
- Starting from Windows 10, Microsoft supports the native feature 'Windows Subsystem
  for Linux.' This feature enables users to utilize their Windows OS environment as
  a UNIX-like system.
- Remote Access supports the forwarding of SSH, Database, and Kubernetes session logs.
- Akeyless SCP currently supports only UNIX-like OS.
- The `--name` should point to a static secret in Akeyless holding the SSH private
  key.
- Users should have only list permission on this item, while the Bastion should have
  read permission.
- SSH Certificates provide ephemeral access without needing public SSH keys on the
  server side.
- The feature can be used for basic SSH logins without public SSH key.
- Use the `akeyless connect` command from Akeyless CLI to access databases from any
  UNIX terminal to work with your database native CLI.
- Make sure your Access ID is specified in the Allowed Access IDs field of your SRA
  settings, to get access. Access IDs that are not listed, will not be authorized
  to get access.
- Users can access the Windows machine from the Secure Remote Access Portal over the
  web.
- Upload stores files temporarily on the secure remote access server.
- Files will be cleared after the user disconnects.
- Use Akeyless Connect command to access the AWS Console from any UNIX terminal.
- Akeyless connect command enables application native CLI access.
- Default access to the Azure portal will use direct network access mode.
- The Secret value is a concatenation of your GCP Username and your GCP Password with
  double dots as a delimiter.
- In case there is a size limit issue on the SRA SSH server, a file will be created
  in the akl-downloads folder saying NOT_ENOUGH_FREE_SPACE and the user won't be able
  to download it.
- Remote server must support SFTP for file upload/download.
- Enables secure remote access to an LDAP server with a Dynamic Secret that generates
  ephemeral credentials for the server or a Rotated Secret.
- Requires setup of Secure Remote Access and RabbitMQ Dynamic Secrets
- Your web application must run over HTTPS
- 'In case you are using an Alias or multiple fields as part of your login credentials,
  please make sure your secret value follows this format: username..alias..password'
- The Desktop Application is under Beta. For additional information please contact
  our support team
- The Desktop Application is currently in its Beta phase
- The installation folder contains a configuration file and logs
- currently in its Beta phase
- File transfers for certificate-based targets have a known limitation and currently
  is not supported
- Akeyless currently supports creating Universal Secrets Connectors for AWS, GCP,
  Azure, Kubernetes, and Hashicorp Vault.
- Uses AWS Secrets Manager for managing secrets without storing a copy of the AWS
  secrets.
- An Akeyless Gateway with Read permission on the target associated with the USC is
  required.
- Azure Registered Application with Key Vault Secrets Officer role assigned is necessary.
- Allows management of Universal Certificates
- Can import certificates in pem and pfx formats
- GCP Service Account with Secret Manager Admin role assigned is necessary.
- Requires an Akeyless Gateway with Read permission on the target associated with
  the USC.
- Management of USCs is done through a set of sub-commands prefixed with 'usc'.
- KV Secrets Engine v1 is not supported. Please use KV Secrets Engine v2 when working
  with the Vault Universal Secrets Connector.
- This solution makes managing secrets in remote endpoints more efficient and consistent,
  enabling a secure, centralized approach to secret lifecycle management.
- 'K8s & Hashicorp target enforces that secrets will be in a JSON format, meaning
  that a valid JQ filter would be for example: {"password": .password}'
- Password Manager Overview available in documentation.
- 'Centralized user management: Create, manage, and delete user accounts, assign roles
  and permissions, and enforce security policies.'
- 'Audit and monitoring: Track user activity, identify anomalies, and generate reports
  for compliance purposes.'
- 'Third-party integrations: Seamlessly integrate with CI/CD pipelines and ITSM platforms
  to automate password management workflows.'
- 'Role-based access control (RBAC): Define granular permissions and assign roles
  to users based on their specific needs.'
- 'Security policies: Implement and enforce security policies, such as password rotation
  and multi-factor authentication (MFA).'
- Akeyless is designed to scale alongside your business.
- Empower your team to manage passwords securely and efficiently.
- Only users with admin privileges can manage the visibility of the personal folder
  across the organization.
- The personal folder toggle will be enabled by default for existing users and disabled
  for new users.
- Users will need to have a VPN on their phone installed in order to use zero-knowledge
  keyless functionality.
- Documentation for setting password policy on password level
- 'During Password Creation or Editing: Character Length and character inclusion options
  are available.'
- When creating a new password, find these options under the password field.
- If you need to update the password policy for an existing password, navigate to
  the password editing screen.
- Akeyless supports various authentication methods including OAuth 2.0.
- Akeyless supports both folder and flat views for secrets and keys.
- Google Chrome may have inconsistencies in autofill performance.
- Enabling Autofill in iOS Settings
- Copy/Paste functionality for passwords
- Ensure that the URL is entered correctly to guarantee the integration's success.
- For added security, especially against accidental deletions, toggle the 'Delete
  Protection' option.
- Utilizes OAuth2 for authentication.
- Uses OAuth2 with refresh token
- The Akeyless browser extension ensures you're never without your crucial password
  information.
- Maintaining secure connections is paramount in today's interconnected world.
- The 'Value' field can store information not just in plain text but also in JSON
  format.
- By configuring these settings, you establish a standardized default for secret generation
  in your organization's account. Users can still modify parameters during secret
  creation, but the defaults will adhere to the rules you've set.
- Once a password or secret is deleted, it cannot be recovered.
- Requires setup of connected app in API
- Documentation includes various authentication methods.
- Password AutoFill is a feature of many web browsers that allows you to automatically
  fill in your login credentials for websites.
- No updates made with `update-item` can be saved as part of new versions, which means
  that these changes override existing data.
- Requires setup of profiles located at $HOME/.akeyless/profiles
- Use a specific profile (located at $HOME/.akeyless/profiles) or a temp access token
- Required only for universal_identity authentication
- Use a specific profile located at $HOME/.akeyless/profiles or a temp access token
- Universal identity token is required only for universal_identity authentication
- Some commands may require specific permissions or roles to execute.
- The External Secrets Manager has been renamed Universal Secrets Connector.
- Universal identity token is required for universal_identity authentication.
- This section outlines the CLI commands relevant to the Gateway Migrations.
- The documentation, configuration and examples for Akeyless K8s plugins are also
  applicable to Red Hat OpenShift environment.
- 'Enable the K8s plugin by adding ''akeyless/enabled: "true"'' in the annotations
  section.'
- 'When working with Red Hat OpenShift, enable the OpenShift flag in the values.yaml
  chart file: openshiftEnabled: true'
- Injecting secrets into the namespace where the k8s injector plugin is installed
  is unsupported.
- 'While working with Customer Fragment for Zero-Knowledge set: AKEYLESS_API_GW_URL:
  "https://<Your-Akeyless-GW-URL:8000/api/v1>"'
- Uses GCP authentication
- Use K8s authentication method for namespace segregation
- Organize authentication methods and access roles in separate folders
- Highly recommended to avoid using API Keys in production.
- The provider secret will be deleted if the PushSecret is deleted
- K8s Secrets Store CSI Provider supports Static Secrets, Rotated Secrets and Certificates
- Using Access Key within YAML files is not secure. You can provide the AKEYLESS_ACCESS_KEY
  as an environment variable instead.
- Cert-Manager generates certificate requests from the Kubernetes (K8s) cluster to
  Akeyless.
- The certificate will be created under the directory that was defined in the Storage
  Folder Location field of the PKI Issuer
- A solution that injects secrets into pods at runtime without storing them in Kubernetes
  secrets.
- Uses API key for authentication
- For JWT authentication, it is required to add appropriate Sub-Claims based on the
  claims available in the JWT.
- Akeyless developed API compatibility with Hashicorp Vault OSS.
- GitLab v16 and higher - CI_JOB_JWT_V2 is replaced by ID tokens which are the JSON
  Web Tokens (JWTs) that can be added to a GitLab CI/CD job.
- Sub Claims - It is mandatory to add an appropriate Sub Claim based on the claims
  available in the GitLab documentation to prevent access of unauthorized users.
- Akeyless developed API compatibility with Hashicorp Vault OSS, enabling the use
  of Vault OSS community plugins for both Static & Dynamic Secrets.
- It is best practice to use environment variables instead of writing the actual variable
  values inside the pipeline.
- Specify your parameter name (without any prefixes)
- Select the Environment variable (env.) parameter type
- Provide the full path to your secret in Akeyless
- Chef InSpec is an open-source framework for testing and auditing your applications
  and infrastructure.
- Chef InSpec detects violations and displays findings in the form of a report, but
  puts you in control of remediation.
- Command - the name of the command, set to `/akeyless`
- Short Description - exactly what it sounds like, a short description of what your
  command does. e.g. `AKEYLESS Secrets Management`
- When working with ephemeral containers, deployments folder should be mounted using
  persistent volumes.
- Tokens used by Akeyless Authenticator must include user’s email address.
- Initiate SAML authentication using your Keycloak deployment.
- A query will output only the information your Authentication Method has access to
  based on its Access Role.
- Akeyless official Kubernetes Plugins fully supports Red Had OpenShift and can be
  deployed on OpenShift platform.
- A certificate can be requested based on a Common Name (CN) or via a Certificate
  Signing Request (CSR).
- The certificate attached to the private key must have at least a Common Name (CN)
  with it.
- The API Key token should be a concatenation of your access_id and your access_key
  with double dots as a delimiter.
- Make sure the Authentication method is set with the appropriate RBAC in Akeyless
  to grant access to your dynamic secret.
- Uses OAuth2 authentication method
- 'Default Key Type is: ec-p256'
- Set read, create, list permissions for Secret & Keys for the Access Role
- Ensure to validate the SHA256 CHECKSUM for the plugin
- In this guide, we will use an API Key Authentication Method for simplicity and we
  are only using Linux machines.
- In this guide, we will use an API Key Authentication Method for simplicity
- trust bundle path is a path on your machine where a certificate.pem file will exist
- Uses API Key Authentication Method for simplicity
- gRPC is not enabled by default on Gateway, make sure to enable this as part of your
  Gateway deployment.
errors:
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- 'Invalid input: Ensure all required parameters are provided.'
- 'Unauthorized: Check permissions and access modes.'
- Working with --rotator-type target supports only Rotated Secret for the Parent Target.
- 'Unauthorized: User does not have permission to access the requested resource.'
- '401 Unauthorized: Check API Key or access permissions.'
- 'Cannot Parse Attribute: Unique Identifier: Not implemented.'
- 'OPEN_NO_MASTER_KEY: The keystore is open, but the master encryption key has not
  yet been created.'
- 'INVALID_ACCOUNT: The requested account is not valid.'
- 'ACCOUNT_NOT_FOUND: The specified account does not exist.'
- 'Compatibility Issue with Legacy SSH Versions (7.4 & 7.6): Customers who have upgraded
  their Secure Remote Access (SRA) to the latest may experience SSH connection failures.'
- '401 Unauthorized: Check token validity.'
- 'Error Message: Shown when the passkey creation or update process fails.'
- 'Success Message: Displayed when the passkey is successfully created or updated.'
- '403 Forbidden: Check role permissions and access configurations'
- '400 Bad Request: Check your request parameters.'
- '401 Unauthorized: Verify your authentication credentials.'
- '404 Not Found: Ensure the resource exists.'
- '401 Unauthorized: Recheck API key or token expiration'
- '401 Unauthorized: Check your access ID and access key'
auth_info:
  mentioned_objects:
  - OauthToken
  - AuthProvider
  - NamedCredential
  - OIDC Authentication Method
  - OIDC
  - Client ID
  - Client secret
  - AkeylessKerberos
  - Configuration
  - V2Api
  - Auth
  - AuthOutput
  - ListItems
  - ListItemsInPathOutput
  - PKICertIssuer
  - CA key
  - CA certificate
  - API Key
  - AWS IAM
  - Azure Active Directory
  - Access-ID
  - Access-Key
  - SAML
  - LDAP
  - Account Alias
  - Universal Identity
  - Access Id
  - GCP Audience
  - K8s_Auth
  - namespace1auth
  - Azure AD
  - GCP
  - Email
  - Kubernetes
  - OCI IAM
  - JWT
  - CI_JOB_JWT_V2
  - ID_TOKEN
  - Certificate
  - Google Cloud Platform (GCP)
  - OAuth2.0/JWT
  - Access Role
  - KeyManager
  - Azure
  - K8S
client:
  base_url: https://www.akeyless.io
source_metadata: null
