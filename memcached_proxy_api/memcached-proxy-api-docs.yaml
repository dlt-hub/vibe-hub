resources:
- name: stats_settings
  endpoint:
    path: /stats/settings
    method: GET
    data_selector: settings
- name: quickstart_data
  endpoint:
    path: /quickstart/data
    method: SET
    data_selector: STORED
    params: {}
- name: quickstart_data_fetch
  endpoint:
    path: /quickstart/data
    method: GET
    data_selector: Hello!
    params: {}
- name: stats
  endpoint:
    path: /stats
    method: GET
    data_selector: settings
- name: proxy_configuration
  endpoint:
    path: /features/proxy/configure/
    method: GET
    data_selector: configuration
    params: {}
- name: proxy_configuration
  endpoint:
    path: /features/proxy/configure/
    method: GET
    data_selector: pools
    params: {}
- name: proxy
  endpoint:
    path: /features/proxy/
    method: GET
    data_selector: proxy
- name: main_pool
  endpoint:
    path: /main_pool
    method: GET
    data_selector: records
    params: {}
- name: customer_pool
  endpoint:
    path: /customer_pool
    method: GET
    data_selector: records
    params: {}
- name: middleware_machine
  endpoint:
    path: /features/proxy/middleware_machine
    method: GET
- name: application_sidecar
  endpoint:
    path: /features/proxy/application_sidecar
    method: GET
- name: cache_layering_proxy
  endpoint:
    path: /features/proxy/cache_layering_proxy
    method: GET
- name: proxy
  endpoint:
    path: /features/proxy/
    method: GET
- name: route_direct
  endpoint:
    path: /route_direct
    method: GET
    data_selector: result
    params: {}
- name: route_null
  endpoint:
    path: /route_null
    method: GET
    data_selector: result
    params: {}
- name: route_allsync
  endpoint:
    path: /route_allsync
    method: GET
    data_selector: result
    params: {}
- name: route_allfastest
  endpoint:
    path: /route_allfastest
    method: GET
    data_selector: result
    params: {}
- name: route_split
  endpoint:
    path: /route_split
    method: GET
    data_selector: result
    params: {}
- name: route_ttl
  endpoint:
    path: /route_ttl
    method: GET
    data_selector: result
    params: {}
- name: route_failover
  endpoint:
    path: /route_failover
    method: GET
    data_selector: result
    params: {}
- name: route_ratelim
  endpoint:
    path: /route_ratelim
    method: GET
    data_selector: result
    params: {}
- name: route_random
  endpoint:
    path: /route_random
    method: GET
    data_selector: result
    params: {}
- name: route_zfailover
  endpoint:
    path: /route_zfailover
    method: GET
    data_selector: result
    params: {}
- name: proxy_settings
  endpoint:
    path: /features/proxy/settings-reference
    method: GET
    data_selector: settings
    params: {}
- name: route_direct
  endpoint:
    path: /route_direct
    method: GET
    data_selector: result
    params: {}
- name: route_null
  endpoint:
    path: /route_null
    method: GET
    data_selector: result
    params: {}
- name: route_allsync
  endpoint:
    path: /route_allsync
    method: GET
    data_selector: result
    params: {}
- name: route_allfastest
  endpoint:
    path: /route_allfastest
    method: GET
    data_selector: result
    params: {}
- name: route_split
  endpoint:
    path: /route_split
    method: GET
    data_selector: result
    params: {}
- name: route_ttl
  endpoint:
    path: /route_ttl
    method: GET
    data_selector: result
    params: {}
- name: route_failover
  endpoint:
    path: /route_failover
    method: GET
    data_selector: result
    params: {}
- name: route_ratelim
  endpoint:
    path: /route_ratelim
    method: GET
    data_selector: result
    params: {}
- name: route_random
  endpoint:
    path: /route_random
    method: GET
    data_selector: result
    params: {}
- name: route_zfailover
  endpoint:
    path: /route_zfailover
    method: GET
    data_selector: result
    params: {}
- name: user
  endpoint:
    path: /user
    method: GET
    data_selector: records
    params:
      sql: SELECT * FROM user WHERE user_id = ?
- name: user_preferences
  endpoint:
    path: /user_preferences
    method: GET
    data_selector: records
    params:
      sql: SELECT * FROM user_preferences WHERE user_id = ?
- name: flash_storage
  endpoint:
    path: /features/flashstorage/
    method: GET
    data_selector: data
    params: {}
- name: storage_commands
  endpoint:
    path: /commands/storage
    method: GET
    data_selector: commands
    params: {}
- name: retrieval_commands
  endpoint:
    path: /commands/retrieval
    method: GET
    data_selector: commands
    params: {}
- name: statistics
  endpoint:
    path: /commands/statistics
    method: GET
    data_selector: commands
    params: {}
- name: flush_all
  endpoint:
    path: /commands/flush_all
    method: POST
    data_selector: commands
    params: {}
- name: get
  endpoint:
    path: /get
    method: GET
- name: set
  endpoint:
    path: /set
    method: SET
- name: set
  endpoint:
    path: /set
    method: POST
    data_selector: data
    params: {}
- name: get
  endpoint:
    path: /get
    method: GET
    data_selector: data
    params: {}
- name: delete
  endpoint:
    path: /delete
    method: DELETE
    data_selector: data
    params: {}
- name: stats
  endpoint:
    path: /stats
    method: GET
    data_selector: data
    params: {}
- name: Delete
  endpoint:
    path: /delete
    method: MUST NOT have extras
    data_selector: MUST NOT have key
    params: {}
- name: Increment
  endpoint:
    path: /increment
    method: MUST have extras
    data_selector: MUST NOT have key
    params: {}
- name: Decrement
  endpoint:
    path: /decrement
    method: MUST have extras
    data_selector: MUST NOT have key
    params: {}
- name: Quit
  endpoint:
    path: /quit
    method: MUST NOT have extras
    data_selector: MUST NOT have key
    params: {}
- name: Flush
  endpoint:
    path: /flush
    method: MAY have extras
    data_selector: MUST NOT have key
    params: {}
- name: Noop
  endpoint:
    path: /noop
    method: MUST NOT have extras
    data_selector: MUST NOT have key
    params: {}
- name: Get
  endpoint:
    path: /protocols/binary/get
    method: GET
- name: Set
  endpoint:
    path: /protocols/binary/set
    method: SET
- name: Add
  endpoint:
    path: /protocols/binary/add
    method: ADD
- name: Replace
  endpoint:
    path: /protocols/binary/replace
    method: REPLACE
- name: Delete
  endpoint:
    path: /protocols/binary/delete
    method: DELETE
- name: Increment
  endpoint:
    path: /protocols/binary/increment
    method: INCREMENT
- name: Decrement
  endpoint:
    path: /protocols/binary/decrement
    method: DECREMENT
- name: Quit
  endpoint:
    path: /protocols/binary/quit
    method: QUIT
- name: Flush
  endpoint:
    path: /protocols/binary/flush
    method: FLUSH
- name: Stat
  endpoint:
    path: /protocols/binary/stat
    method: STAT
- name: configuration
  endpoint:
    path: /etc/memcached.conf
    method: UPDATE
    data_selector: configurations
    params: {}
- name: memcached_tuning
  endpoint:
    path: /memcached/tuning
    method: GET
    data_selector: tuning_options
    params: {}
- name: loki_configuration
  endpoint:
    path: /loki/configuration
    method: GET
    data_selector: configuration_options
    params: {}
- name: huge_data_for_front_page
  endpoint:
    path: /hugetable
    method: GET
    data_selector: results
    params:
      query: SELECT * FROM hugetable WHERE timestamp > lastweek ORDER BY timestamp
        ASC LIMIT 50000
notes:
- API functions are mostly stable, but are still subject to occasional change.
- Configuring the proxy happens in two distinct stages using independent Lua VM instances.
- Uses OAuth2 with refresh token — requires setup of connected app in api
- Some objects like Contact may return nulls in deeply nested fields
- 'Configuration happens in two distinct stages: configuration thread and worker threads.'
- Memcached works on most Linux and BSD like systems.
- There is no official support for windows builds.
- The version of memcached provided by your OS’s package manager may be out of date.
- Memcached defaults to listening only on TCP.
- The max number of concurrent connections is set to 1024.
- Memcached interacts hard with the network and with RAM.
- Most minor releases focus on fixing bugs and adding instrumentation.
- Memcached can handle 200,000+ requests per second.
- Expiration times should be accurate up to the nearest second.
- In versions prior to 1.5.0, expired items are not actively reclaimed.
- Uses a proxy configuration for Memcached with backend servers on ports 11212 and
  11213.
- Run with -d to daemonize.
- The Memcached built-in proxy is available only if you activate a specific configuration
  option while compiling Memcached.
- You can run the proxy only if you build Memcached from source.
- It’s common for people to monitor swap usage, which can cause severe performance
  degradation to memcached.
- Memcached operations are almost all O(1).
- On a good day memcached can serve requests in less than a millisecond.
- Requires Memcached with proxy features enabled.
- If you don’t start a set’s name with `set_`, then Memcached reads it as an ordinary
  pool definition, likely resulting in a syntax error.
- This quickstart guide helps in configuring a minimal proxy setup with Memcached.
- 'Memcached must be started with options like: -l 127.0.0.1:12051 -l tag_b_:127.0.0.1:12052
  -l tag_cccc_:127.0.0.1:12053'
- Memcached, with proxy features enabled, installed on your system.
- The proxy route library file downloaded to some path on your file system.
- A proxy configuration file that you created.
- Before you can run the proxy, you need to create a configuration that lists the
  pools of Memcached servers.
- The memcached proxy is a flexible and lightweight system with few dependencies.
- A layered cache is an architecture where a pre-existing pool of memcached servers
  is replaced by proxy nodes.
- Before running the proxy, ensure Memcached with proxy features is installed.
- The proxy can listen on multiple tagged TCP ports.
- If you already have memcached deployed but want to add redundancy, expansion, or
  so on.
- Keep your most commonly used cache data in the top layer for good performance.
- Memcached’s proxy is not intended to replace a mesh router; its scope is much smaller
  and more performance focused.
- The proxy returns a fast fail on any request if it is already actively processing
  more than the active_req_limit.
- If set to 0, then the proxy does not impose the active_req_limit.
- System clock must be set correctly and must not jump while memcached is down.
- Deletes, sets, adds, incr/decr/etc commands will be missed while instance restarts!
- The earliest version you can restart from is 1.5.18. Older versions cannot upgrade
  to 1.5.18 without losing the cache.
- Memcached 1.5.13+ supports authentication and encryption via TLS.
- See doc/tls.txt for design and some implementation details.
- Requires memcached 1.6.0 or newer.
- Storage is split internally into pages. By default pages have a size of 64 megabytes.
- ext_page_size defaults to 64M. This shouldn’t need to change unless you are storing
  very large values (multiple megabytes).
- ext_wbuf_size defaults to 8M. One write buffer is needed per bucket, By default
  32 megabytes of memory are reserved for write buffers. This cannot be larger than
  the page size.
- ext_threads defaults to 1. If you have a high read latency but the drive is idle,
  you can increase this number. Stick to low values; no more than 8 threads.
- ext_item_size defaults to 512 bytes. Items larger than this can be flushed.
- ext_low_ttl TTL’s lower than this value will be colocated on disk. Off by default.
- ext_max_frag A compaction tuning flag. If there are few free pages remaining, pages
  which are at least this empty will be rewritten to reclaim space.
- ext_drop_unread A compaction tuning flag. If enabled, and no pages match the ext_max_frag
  filter, a compaction will be done anyway.
- ext_compact_under A compaction tuning setting. If fewer than this amount of pages
  are free, check the ext_max_frag filter and start compacting.
- ext_drop_under A compaction tuning setting. If ext_drop_unread is enabled, and fewer
  than this many pages are free, compact and drop COLD data.
- ext_recache_rate If an item stored on flash has been accessed more than once in
  the last minute, it has a one in N chance of being recached into RAM and removed
  from flash. Defaults to 2000.
- This will not work with rotational media.
- Cache it for five minutes
- ext_wbuf_size defaults to 8M. One write buffer is needed per bucket, By default
  32 megabytes of memory are reserved for write buffers. This cannot be larger than
  the page size. Larger write buffers can help with write rate performance.
- ext_item_size defaults to 512 bytes. Items larger than this can be flushed. You
  can lower this value if you want to save a little extra RAM and your keys are short.
  You can also raise this value if you only wish to flush very large objects, which
  is a good place to start.
- ext_low_ttl TTL’s lower than this value will be colocated on disk. Off by default.
  Useful if you have a mix of high and low TTL’s being used.
- 'ext_max_frag A compaction tuning flag. If there are few free pages remaining, pages
  which are at least this empty will be rewritten to reclaim space. IE: ext_max_frag=0.5
  will rewrite pages which are at least half empty.'
- ext_compact_under A compaction tuning setting. If fewer than this amount of pages
  are free, check the ext_max_frag filter and start compacting. Defaults to 1/4th
  of the pages.
- ext_drop_under A compaction tuning setting. If ext_drop_unread is enabled, and fewer
  than this many pages are free, compact and drop COLD data. This defaults to the
  same value as ext_compact_under.
- 'Memcached is not an automatic application accelerator: it must be integrated into
  an application via code.'
- This feature is still in an experimental stage.
- Memcached does not natively support namespaces or tags.
- 1 megabyte limit on item size.
- Memcached must be integrated into an application via code.
- Limited password based authentication is available in the basic protocol.
- You can also enable TLS and authenticate by certificates verification.
- Expiration times are specified in unsigned integer seconds.
- The Meta protocol is more efficient than the older binary protocol, is cross compatible
  with the Text protocol. It is recommended for all new clients.
- The meta protocol is no longer considered experimental, please give it a shot!
- Binary protocol is deprecated.
- Limited password based authentication is available in the basic protocol
- You can also enable TLS and authenticate by certificates verification
- Uses a binary protocol for communication
- Responses can include error messages based on status codes
- Supports basic commands for storing and retrieving data.
- The 'noreply' version of most ASCII commands is not recommended.
- This system is not strict.
- It is difficult if not impossible to guarantee consistency across multiple pools.
- For truly hot keys, the simplest approach is to only cache them in a client for
  a couple seconds.
- Memcache has few authentication and no security layers whatsoever. It is RECOMMENDED
  that memcache be deployed strictly on closed, protected, back-end networks within
  a single data center, within a single cluster of servers, or even on a single host,
  providing shared caching for multiple applications. Memcache MUST NOT be made available
  on a public network.
- This does not provide encryption, but can provide authentication.
- Do not run this over the internet.
- Read more about memcached’s SASL auth protocol
- UDP is disabled by default on versions 1.5.6 and later.
- 'You can disable UDP by adding the following line to your /etc/memcached.conf: -U
  0'
- Please set -m and ext_path appropriately for your system.
- Loki’s default configuration is very aggressive, which is normally fine for memory
  backed memcached. However extstore needs a little more time to fetch or write to
  disk.
- The result of each operation is signaled through the status code.
- Check your firewalls
- Is the machine in swap?
- Is the machine overloaded?
- You’re probably dropping packets.
- TIME_WAIT buckets or local port exhaustion
- But your utility never fails!
- Does not provide encryption, but can provide authentication.
- SASL is not implemented as end-to-end encryption.
- Uses distributed caching, keys may not be available on all memcached instances
- Cache misses occur if a memcached instance is offline
- Uses SASL authentication
- You can disable UDP by adding '-U 0' to your start arguments.
- Assume your Loki chunk storage size is 1.5mb
- Set -m and ext_path appropriately for your system
- You may need to tune or disable firewalls that exist between the client and memcached.
- Is the machine in swap? You will see random lag bubbles if your OS is swapping memcached
  to disk periodically.
- 'If mc_conn_tester.pl is seeing connection timeouts (conn: is 0), you may be running
  out of local ports, firewall states, or TIME_WAIT buckets.'
- Uses a distributed cache architecture
- Cache misses may occur if a memcached server is offline
errors:
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- 'listen_disabled_num: Check for max connections reached.'
- 'Client Timeouts: Check network connectivity or server load.'
- 'listen_disabled_num: Check for extra connections.'
- 'Invalid backend configuration: Ensure backend settings are correctly defined.'
- evictions can mean you’re out of RAM or you’re writing too fast.
- too much writing can be alleviated by adding more RAM and tuning.
- Increment failed! Key must not exist.
- 'Client Timeouts: Ensure your connections are properly managed.'
- '0x0001: Key not found'
- '0x0002: Key exists'
- '0x0003: Value too large'
- '0x0004: Invalid arguments'
- '0x0005: Item not stored'
- '0x0008: Authentication error'
- 'NOT_FOUND: The requested key was not found'
- 'CLIENT_TIMEOUT: Possible timeout during requests.'
- 'ITEM_NOT_FOUND: Key does not exist in the cache.'
- '0x20: Authentication required / Not Successful'
- '0x21: Further authentication steps required.'
- 'Plain auth is not working: Check the password file is owned by and only readable
  by the user running memcached'
- Check that the username the client is using matches that used in the password file
- 'Fail: (timeout: 1) (elapsed: 1.00145602) (conn: 0.00000000) (set: 0.00000000) (get:
  0.00000000)'
- 'Fail: (timeout: 1) (elapsed: 1.00427794) (conn: 0.00000000) (set: 0.00000000) (get:
  0.00000000)'
- 'SASL authentication not working: Check SASL library installation and password file
  permissions'
auth_info:
  mentioned_objects: []
client:
  base_url: https://www.memcached.org/
  headers:
    Content-Type: application/json
source_metadata: null
