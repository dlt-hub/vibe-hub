resources:
- name: gets_a_provisioning_status
  endpoint:
    path: /v1/accounts/{accountName}/tunnels/{tunnelId}/provisioning-operations/{operationId}
    method: GET
- name: gets_a_service_configuration
  endpoint:
    path: /v1/accounts/{accountName}/tunnels/{tunnelId}/services-configuration
    method: GET
- name: configures_tunnel_services
  endpoint:
    path: /v1/accounts/{accountName}/tunnels/{tunnelId}/services-configuration
    method: PUT
- name: Example Endpoint
  endpoint:
    path: path-1
    method: GET
- name: MCP Server
  endpoint:
    path: /mcp
    method: POST
- name: GoogleCloudLoggingPlugin
  endpoint:
    path: /
    method: POST
    data_selector: logs
    params: {}
- name: AWSLoggingPlugin
  endpoint:
    path: /aws/zuplo/api
    method: POST
    data_selector: log
    params: {}
- name: DataDogLoggingPlugin
  endpoint:
    path: /api/v2/logs
    method: POST
    data_selector: logs
- name: NewRelicLoggingPlugin
  endpoint:
    path: /log/v1
    method: POST
    data_selector: logs
- name: custom_logging
  endpoint:
    path: /YOUR_MOCKIN_URL_HERE
    method: POST
- name: DataDog
  endpoint:
    path: /metrics/datadog
    method: POST
    data_selector: metrics
- name: Dynatrace
  endpoint:
    path: /metrics/dynatrace
    method: POST
    data_selector: metrics
- name: New Relic
  endpoint:
    path: /metrics/newrelic
    method: POST
    data_selector: metrics
- name: gcp-service-auth
  endpoint:
    options:
      audience: https://my-app-1235.a.run.app
- name: dev-portal-redirect
  endpoint:
    path: /docs(.*)
    method: GET
- name: posts
  endpoint:
    path: /api/v1/posts
    method: GET
    data_selector: posts
- name: users
  endpoint:
    path: /api/v1/users
    method: GET
    data_selector: users
- name: posts
  endpoint:
    path: /api/v1/posts
    method: GET
    data_selector: posts
- name: comments
  endpoint:
    path: /api/v1/posts/:post_id/comments
    method: GET
    data_selector: comments
- name: users
  endpoint:
    path: /api/v1/users
    method: GET
    data_selector: users
- name: posts
  endpoint:
    path: /api/v1/posts
    method: GET
- name: comments
  endpoint:
    path: /api/v1/posts/:post_id/comments
    method: GET
- name: users
  endpoint:
    path: /api/v1/users
    method: GET
- name: users
  endpoint:
    path: /api/v1/users/:id
    method: GET
    data_selector: user
    params: {}
- name: posts
  endpoint:
    path: /api/v1/posts
    method: GET
    data_selector: posts
- name: comments
  endpoint:
    path: /api/v1/posts/:post_id/comments
    method: GET
    data_selector: comments
- name: users
  endpoint:
    path: /api/v1/users
    method: GET
    data_selector: users
- name: length
  endpoint:
    path: /units/post-unit
    method: POST
    data_selector: LengthDto
- name: movies
  endpoint:
    path: /movies
    method: GET
    data_selector: data
- name: basic_xml
  endpoint:
    path: /basic-xml
    method: GET
    data_selector: content
- name: dynamic_xml
  endpoint:
    path: /dynamic-xml
    method: GET
    data_selector: content
- name: custom_xml
  endpoint:
    path: /custom-xml
    method: GET
    data_selector: content
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: content
- name: products
  endpoint:
    path: /products/{product_id}
    method: GET
    data_selector: content
- name: items
  endpoint:
    path: /items/{item_id}
    method: GET
    data_selector: content
- name: basic_xml
  endpoint:
    path: /basic-xml
    method: GET
    data_selector: content
- name: dynamic_xml
  endpoint:
    path: /dynamic-xml
    method: GET
    data_selector: content
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: content
- name: products
  endpoint:
    path: /products/{product_id}
    method: GET
    data_selector: content
- name: items
  endpoint:
    path: /items/{item_id}
    method: GET
    data_selector: content
- name: echo
  endpoint:
    path: /echo
    method: POST
    data_selector: content
- name: basic_xml
  endpoint:
    path: /basic-xml
    method: GET
    data_selector: content
    params: {}
- name: dynamic_xml
  endpoint:
    path: /dynamic-xml
    method: GET
    data_selector: content
    params: {}
- name: custom_xml
  endpoint:
    path: /custom-xml
    method: GET
    data_selector: content
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: content
    params: {}
- name: products
  endpoint:
    path: /products/{product_id}
    method: GET
    data_selector: content
    params: {}
- name: basic_xml
  endpoint:
    path: /basic-xml
    method: GET
    data_selector: null
    params: {}
- name: dynamic_xml
  endpoint:
    path: /dynamic-xml
    method: GET
    data_selector: null
    params: {}
- name: custom_xml
  endpoint:
    path: /custom-xml
    method: GET
    data_selector: null
    params: {}
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: null
    params: {}
- name: products
  endpoint:
    path: /products/{product_id}
    method: GET
    data_selector: null
    params: {}
- name: items
  endpoint:
    path: /items/{item_id}
    method: GET
    data_selector: null
    params: {}
- name: create_record
  endpoint:
    path: /create
    method: POST
    data_selector: record
    params: {}
- name: read_record
  endpoint:
    path: /read
    method: GET
    data_selector: record
    params: {}
- name: update_record
  endpoint:
    path: /update
    method: PUT
    data_selector: record
    params: {}
- name: delete_record
  endpoint:
    path: /delete
    method: DELETE
    data_selector: record
    params: {}
- name: users
  endpoint:
    path: /docs
    method: GET
    data_selector: users
    params:
      offset: query
      status: query
      X-front: header
- name: MCP Server
  endpoint:
    path: /sse
    method: GET
- name: OpenAPI Server
  endpoint:
    path: /
    method: GET
- name: MCP SSE
  endpoint:
    path: /sse
    method: GET
- name: REST API
  endpoint:
    path: /
    method: GET
- name: todos
  endpoint:
    path: /v1/todos
    method: GET
    data_selector: records
    params: {}
- name: moesif
  endpoint:
    path: /moesif
    method: GET
    data_selector: metrics
- name: postman
  endpoint:
    path: /postman
    method: GET
    data_selector: metrics
- name: runscope
  endpoint:
    path: /runscope
    method: GET
    data_selector: metrics
- name: sematext
  endpoint:
    path: /sematext
    method: GET
    data_selector: metrics
- name: datadog
  endpoint:
    path: /datadog
    method: GET
    data_selector: metrics
- name: smartbear
  endpoint:
    path: /smartbear
    method: GET
    data_selector: metrics
- name: ZuploRequest
  endpoint:
    path: /
    method: POST
    data_selector: params
    params: {}
- name: addPreRoutingHook
  endpoint:
    path: /hooks/pre-routing
    method: GET
- name: addRequestHook
  endpoint:
    path: /hooks/request
    method: GET
- name: addResponseSendingHook
  endpoint:
    path: /hooks/response-sending
    method: GET
- name: addResponseSendingFinalHook
  endpoint:
    path: /hooks/response-sending-final
    method: GET
- name: user
  endpoint:
    path: /users/{userId}
    method: GET
    data_selector: operationId
- name: user_posts
  endpoint:
    path: /users/{userId}/posts/{postId}
    method: GET
    data_selector: operationId
- name: wildcard_users
  endpoint:
    path: /users/(.*)
    method: GET
    data_selector: operationId
- name: my-acl-policy-inbound-policy
  endpoint:
    path: /policies/my-acl-policy-inbound-policy
    method: POST
    data_selector: options.users
    params: {}
- name: authzen-inbound-policy
  endpoint:
    path: /policies/authzen-inbound
    method: POST
    data_selector: options
    params: {}
- name: openfga-authz
  endpoint:
    path: /policies/openfga-authz-inbound
    method: GET
    data_selector: options
- name: my-axiomatics-authz-inbound-policy
  endpoint:
    path: /policies/axiomatics-authz-inbound
    method: POST
    data_selector: policy
    params: {}
- name: my-jwt-scopes-inbound-policy
  endpoint:
    path: ''
    method: ''
    data_selector: ''
    params: {}
- name: my-rbac-policy-inbound-policy
  endpoint:
    path: /policies.json
    method: GET
    data_selector: policies
    params: {}
- name: my-ip-restriction-inbound-policy
  endpoint:
    path: /policies.json
    method: POST
    data_selector: handler.options
    params: {}
- name: my-first-policy
  endpoint:
    path: /config/policies.json
    method: GET
    data_selector: policies
    params: {}
- name: rate_limit_policy
  endpoint:
    path: /policies/rate-limit-inbound
    method: GET
    data_selector: policy
    params: {}
- name: audit_logs
  endpoint:
    path: /deployments/:deploymentId/auditlogs
    method: GET
    data_selector: logs
    params:
      tenant: TENANT
- name: web-bot-auth-inbound-policy
  endpoint:
    path: /api/web-bot-auth-inbound
    method: POST
    data_selector: policy
    params: {}
- name: my-bot-detection-inbound-policy
  endpoint:
    path: /policies/my-bot-detection-inbound-policy
    method: GET
    data_selector: policy
    params: {}
- name: prompt-injection-outbound-policy
  endpoint:
    path: /mcp
    method: POST
    data_selector: outbound
    params: {}
- name: my-require-origin-inbound-policy
  endpoint:
    path: /policies/my-require-origin-inbound-policy
    method: POST
    data_selector: handler.options
    params: {}
- name: my-request-size-limit-inbound-policy
  endpoint:
    path: /policies/request-size-limit-inbound
    method: POST
    data_selector: options
    params:
      maxSizeInBytes: 10000
- name: secret-masking-policy
  endpoint:
    path: /docs/policies/secret-masking-outbound
    method: GET
    data_selector: policies
    params: {}
- name: my-stripe-webhook-verification-inbound-policy
  endpoint:
    path: stripe-webhook-verification-inbound
    method: POST
    data_selector: options
    params: {}
- name: consumers
  endpoint:
    path: /v1/accounts/$ACCOUNT_NAME/key-buckets/$BUCKET_NAME/consumers
    method: POST
    data_selector: data
    params:
      with-api-key: 'true'
- name: key_buckets
  endpoint:
    path: /v1/accounts/YOUR_ACCOUNT_NAME/key-buckets
    method: POST
    data_selector: buckets
    params: {}
- name: amberflo-metering
  endpoint:
    path: /api/products
    method: GET
    data_selector: records
    params: {}
- name: health_check
  endpoint:
    path: /health
    method: GET
    data_selector: ''
    params: {}
- name: user_auth
  endpoint:
    path: /api/v1/auth/login
    method: POST
    data_selector: ''
    params: {}
- name: checkout
  endpoint:
    path: /api/v1/payments/process
    method: POST
    data_selector: ''
    params: {}
- name: product_catalog
  endpoint:
    path: /api/v1/products
    method: GET
    data_selector: ''
    params: {}
- name: user_profile
  endpoint:
    path: /api/v1/users/{id}
    method: GET
    data_selector: ''
    params: {}
- name: business_search
  endpoint:
    path: /businesses/search
    method: GET
    data_selector: businesses
- name: business_search
  endpoint:
    path: /businesses/search
    method: GET
    data_selector: businesses
    params:
      term: coffee
      latitude: 37.786882
      longitude: -122.399972
      limit: 10
- name: business_details
  endpoint:
    path: /businesses/{id}
    method: GET
    data_selector: business
    params: {}
- name: business_reviews
  endpoint:
    path: /businesses/{id}/reviews
    method: GET
    data_selector: reviews
    params: {}
- name: autocomplete
  endpoint:
    path: /autocomplete
    method: GET
    data_selector: terms
    params: {}
- name: phone_search
  endpoint:
    path: /businesses/search/phone
    method: GET
    data_selector: businesses
    params: {}
- name: shipping_rates
  endpoint:
    path: /api/rating/v1/Rate
    method: POST
    data_selector: RateResponse
    params: {}
- name: track_package
  endpoint:
    path: /api/track/v1/details/{tracking_number}
    method: GET
    data_selector: trackResponse
    params: {}
- name: create_shipping_label
  endpoint:
    path: /api/shipments/v1/ship
    method: POST
    data_selector: ShipmentResponse
    params: {}
- name: records
  endpoint:
    path: /v0/YOUR_BASE_ID/YOUR_TABLE_NAME
    method: GET
    data_selector: records
    params: {}
- name: issue
  endpoint:
    path: /rest/api/3/issue
    method: POST
    data_selector: fields
- name: search
  endpoint:
    path: /rest/api/3/search
    method: GET
    data_selector: issues
- name: webhook
  endpoint:
    path: /rest/api/3/webhook
    method: POST
    data_selector: webhook
- name: users
  endpoint:
    path: /users
    method: GET
    data_selector: records
    params: {}
- name: conversations_list
  endpoint:
    path: /conversations.list
    method: GET
    data_selector: channels
- name: customer
  endpoint:
    path: /v3/company/{realmId}/customer/{customerId}
    method: GET
    data_selector: Customer
    params: {}
- name: invoice
  endpoint:
    path: /v3/company/{realmId}/invoice
    method: POST
    data_selector: Invoice
    params: {}
- name: sentiment_analysis
  endpoint:
    path: /models/distilbert-base-uncased-finetuned-sst-2-english
    method: POST
    data_selector: outputs
- name: text_generation
  endpoint:
    path: /models/gpt2
    method: POST
    data_selector: outputs
- name: image_classification
  endpoint:
    path: /models/google/vit-base-patch16-224
    method: POST
    data_selector: outputs
- name: sentiment_analysis
  endpoint:
    path: /models/distilbert-base-uncased-finetuned-sst-2-english
    method: POST
    data_selector: output
    params: {}
- name: text_generation
  endpoint:
    path: /models/gpt2
    method: POST
    data_selector: output
    params: {}
- name: image_classification
  endpoint:
    path: /models/google/vit-base-patch16-224
    method: POST
    data_selector: output
    params: {}
- name: text_summarization
  endpoint:
    path: /models/facebook/bart-large-cnn
    method: POST
    data_selector: output
    params: {}
- name: flight_prices
  endpoint:
    path: /v2/prices/latest
    method: GET
    data_selector: data
    params:
      currency: usd
      origin: NYC
      destination: LON
      beginning_of_period: '2023-10-01'
      period_type: month
      one_way: false
      page: 1
      limit: 30
- name: hotel_search
  endpoint:
    path: /v1/hotels/search
    method: GET
    data_selector: data
    params:
      query: New York
      check_in: '2023-12-01'
      check_out: '2023-12-05'
      adults: 2
      currency: usd
      limit: 10
notes:
- After receiving the initial error, you are forced to pay for the API after your
  first call.
- Affordable plans for every team
- Custom package with custom pricing tailored to meet your needs
- Uses API Key Authentication with Github secret scanning.
- Zuplo empowers developers with productivity not seen in other API management products.
- 'Flexible Accessibility: Choose who gets access to your Zuplo powered developer
  portal.'
- Uses OAuth2 with refresh token — requires setup of connected app in api
- API documentation is the first thing your customers see.
- API Authentication is the first thing your customers use.
- Zuplo supports API key auth, OAuth2, mTLS, IP allowlisting, and custom authentication
  logic
- All gateway configurations are defined as code
- 'Enhanced environment variable search: Improved search functionality for environment
  variables with better filtering and updated components for a smoother user experience.'
- 'Settings page redesign: Updated settings pages with consistent styling, improved
  billing page layout, and added billing addons support.'
- Customers with Zuplo's free subscription plan can seek support through the Zuplo
  Community.
- Free tier available with high availability built-in for all plans
- Zuplo is a fully managed platform for your entire lifecycle
- Every time you deploy a new API gateway, Zuplo automatically generates a Stripe-quality
  portal with beautiful references and schemas
- Zuplo is a single managed API platform for your entire lifecycle.
- Our Service does not address anyone under the age of 13.
- If You are a parent or guardian and You are aware that Your child has provided Us
  with Personal Data, please contact Us.
- Some objects may return nulls in deeply nested fields
- Zuplo is built with a security-first architecture and offers robust tools for securing
  APIs in production environments
- The working copy environment is not intended for production use and should not be
  used as such.
- Rate limiting is a popular policy to prevent API DoS.
- By default, the policy allows 2 requests every 1 minute.
- API Key authentication is considered one of the easiest to use by developers but
  hard for API developers to get right.
- Make sure you've granted access to the project with the Zuplo GitHub App, you can
  check that configuration here
- Protected by API key Authentication
- Dynamically Rate Limited
- Zuplo provides real-time logging out of the box.
- If you would like your logs to be sent to your own logging service, you can enable
  one of Zuplo's logging plugins.
- Create a GCP Service account and give it the Logs Writer (roles/logging.logWriter)
  permission.
- Service account key must be in JSON format and saved as a secret environment variable.
- Custom logging is available as an add-on as part of an enterprise plan.
- The API token requires the events.ingest scope
- Zuplo supports logging to DataDog, Dynatrace, and New Relic.
- The Zuplo OpenTelemetry plugin only supports sending data in JSON format.
- Reliability and performance of your gateway are paramount.
- 'Misconfigured environment variables: Simple errors like a misspelled URL or incorrect
  shared secret can take your gateway down.'
- 'Coding Errors: The flexibility of Zuplo allows for extensive customization and,
  like any software, has the potential to cause disruption if bad code is deployed.'
- Zuplo manages all the complexity of replication, caching, and verifying your API
  keys so you don't have to.
- The Zuplo CLI provides convenient tooling for common tasks that you might want to
  automate.
- Apply appropriate authentication policies to ensure only authorized AI systems can
  access your tools
- Use rate limiting to prevent abuse and control usage costs
- Implement audit logging to track tool usage and maintain compliance
- Scope permissions carefully - only expose routes and OpenAPI specs that should be
  accessible to AI systems
- Requests that are proxied from Zuplo to your GCP Load Balancer use the Upstream
  GCP Service Auth Policy to authenticate the request via a GCP Service Account.
- Customers on Zuplo's enterprise plans using our managed edge deployment can use
  Zuplo Managed WAF.
- Many common WAF functions can be implemented directly in Zuplo using policies, without
  the need for a separate WAF service.
- By default, Zuplo does not enable any Web Application Firewall rules.
- DDoS protection is available for every Zuplo API.
- By default, the rule sensitivity setting is set to Essentially Off.
- By default, this security setting is Off for all Zuplo APIs.
- All APIs deployed to Zuplo are configured on Cloudflare to respect existing cache
  headers.
- By default the Zuplo local server runs on port 9000 and route designer runs on port
  9100.
- API keys are a great approach if you want to maximize the developer experience of
  those using your API.
- Sunsetting an API means retiring it permanently, often because it’s outdated, replaced,
  or poses security risks.
- Uses HTTP 410 responses to signal permanent API removal.
- Effective management of API feature deprecation hinges on clear and timely communication
  with API consumers.
- Incorporate HTTP sunset headers as soon as deprecation begins.
- When the time comes for final removal, implement HTTP 410 status codes to signal
  the change.
- Provide clear migration guides that walk users through the necessary steps.
- Redirects from the legacy path to the new Dev Portal domain using a Zuplo route.
- Key best practices include consistent naming conventions, versioning your API, providing
  clear documentation, using secure authentication methods, and implementing rate
  limiting to avoid abuse.
- APIs are under constant attack. With over 83% of web traffic now API-driven, they’ve
  become a prime target for hackers.
- HTTP 405 errors disrupt workflows and increase troubleshooting time.
- Ensure server configurations support required methods.
- Uses JWT for authentication — requires setup of devise-jwt gem
- Implement disciplined secrets management using Rails credentials.
- Implement disciplined secrets management for sensitive data.
- This is a simple example of a Go API using the Gleece & unitsnet-go packages
- GraphQL enables frontend developers or consumers of APIs to request the exact data
  that they need, with no over-fetching or under-fetching.
- FastAPI defaults to JSON for responses but can handle XML using custom response
  classes.
- FastAPI defaults to JSON for responses, but can be configured to handle XML.
- FastAPI can serve both XML and JSON responses based on client preferences.
- Clear documentation of your XML endpoints is crucial for encouraging API adoption.
- Security is another critical aspect of implementing XML APIs.
- Turn off external entity processing in your XML parser.
- Validate and sanitize all incoming XML data.
- FastAPI supports XML responses using Response class and ElementTree.
- Always use HTTPS
- Implement strong authentication
- Validate and sanitize user inputs
- Handle errors carefully
- Validation ensures your API is safe, reliable, and user-friendly.
- Avoid exposing internal system details in your error messages.
- Standardized error messages are essential for a predictable API experience.
- Consider localization for US users, including date and measurement validation.
- Ensuring proper validation in Flask REST APIs is a critical step in creating secure
  and dependable applications.
- High-profile industry cases have shown the severe consequences of neglecting input
  validation, making it clear that strong validation practices are essential for safeguarding
  both users and businesses.
- Documentation is generated on-demand, not pre-built.
- OasRails generates an OAS v3.1 that can be deployed in any interface.
- Implementing rate limiting in Python requires careful consideration of various factors.
- Libraries like Flask-Limiter simplify the process.
- Rate limiting is a common solution for securing APIs.
- Creates APIs automatically using LLM based on table schema and sampled data
- Supports multiple structured databases
- Supports PostgreSQL, MySQL, ClickHouse, Snowflake, MSSQL, BigQuery, Oracle Database,
  SQLite, ElasticSearch, DuckDB
- Provides APIs as REST or MCP Server including stdio and SSE mode
- API keys can do everything
- Flexibility in API security management allows for revocation and rolling of keys.
- Authentication is required before implementing RBAC.
- Effective RBAC analytics relies on regular audits, smart management, and automation.
- Cognito has traditionally been the most affordable service for identity and access
  management.
- API security isn’t a one-and-done task - it requires ongoing updates and vigilance.
  Regularly reviewing security protocols and quickly applying updates or patches will
  help keep your digital assets secure and maintain user trust.
- APIs are the backbone of modern systems, but they’re also prime targets for cyberattacks.
- 'Use Multi-Factor Authentication (MFA): Combine something users know (passwords)
  with something they have (a device) or something they are (biometrics).'
- API gateways help enforce compliance by integrating features like logging, encryption,
  and security headers to meet regulatory requirements.
- Rate limiting can be used to help with quite a few different use cases.
- Implementing rate limits is important for API management.
- Leaving APIs without a rate limiting policy is insecure and can lead to abuse of
  endpoints.
- Rate limiting helps prevent server overload.
- Rate limiting acts as a first defense against denial of service attacks.
- Selecting the right API monitoring tool is essential for keeping your APIs secure,
  efficient, and performing at their best.
- Good monitoring tools provide actionable insights that help teams spot and fix issues
  before they affect users.
- Ensure APIs work seamlessly across entire workflows.
- Use separate test databases filled with realistic, sanitized data.
- API Security involves protecting APIs from threats like unauthorized access, data
  breaches, and DDoS attacks. It includes authentication, encryption, threat detection,
  and secure design practices.
- Only the standard logging methods listed above are supported
- Other console methods (like console.table(), console.time(), etc.) are no-ops and
  will not produce any output
- Hooks execute in the order they're added.
- Always clone requests and responses before reading their bodies.
- Logging has minimal performance impact
- Logs are processed asynchronously
- Uses JWT authentication policies to validate users.
- This policy requires an authentication policy to run before
- This policy is in beta. You can use it today, but it may change in non-backward
  compatible ways before the final release.
- This policy is in beta and may change in non-backward compatible ways before the
  final release.
- Validates that the JWT token includes specific scopes
- This policy requires an authentication policy to run before.
- This policy shouldn't be relied upon as the only security for protecting sensitive
  workloads.
- Rate limiting allows you to set a maximum rate of requests for your API gateway.
- The policy requires minimal configuration as it automatically uses your existing
  OpenAPI schemas.
- This policy is only available as part of our enterprise plans.
- By default, the OpenAI API is configured but any OpenAPI compatible API will work.
- Strict mode blocks content regardless of your configured OpenAI compatible API's
  availability.
- The require-origin-inbound policy enforces that the client sends an origin header
  that matches the allow-list.
- The signing secret for the webhook is required.
- The allowed clock skew in seconds between the time the webhook signature was created
  and the current time defaults to 300.
- Zuplo participates in GitHub's Secret Scanning program to detect if your or your
  customer's API Keys are checked into source control on GitHub.
- You can assign managers in the Zuplo Portal or via the API.
- With the API Key Authentication Policy configured on your API routes you can build
  additional policies that run after the API Key Authentication policy to perform
  additional checks or authorization on the consumer.
- Management of API Keys and consumers can be performed using the Zuplo Developer
  API.
- The API Key Manager component interacts with an API that allows authorized users
  to manage their own keys.
- API key authentication delivers the most unforgettably good value to your onboarding
  process.
- API keys let you provide a differentiated customer experience around security.
- Most startups go with API-key authentication because it’s secure and the easiest
  to use for developers.
- Lengthy review processes shouldn't be sitting in the way of innovation.
- Most developers want a quick feedback loop without manual intervention.
- 'Deploying your API gateway on ''region: Earth'' means you’re multi-cloud adaptable.'
- Regular API performance testing and monitoring should be part of your continuous
  integration and deployment processes.
- Ongoing monitoring helps you catch issues like slow response times or increased
  error rates early, allowing you to maintain a consistently high-performing API.
- Uses serverless functions for authentication to avoid bottlenecks.
- Caching can significantly boost performance by lowering backend workload.
- API reliance is increasing. With the advent of more generative AI, API use (and
  monetization) is only anticipated to grow.
- Prioritize security measures such as OAuth for authentication and authorization
- Store your Amberflo API key as an environment variable using $env(AMBERFLO_API_KEY)
- Use customerIdPropertyPath instead of hardcoding customer IDs
- Consider creating different meters for different types of API operations
- Add relevant dimensions to your metering data for better analytics
- Monitor your Amberflo dashboard to track API usage patterns
- High-quality API Documentation helps developers understand how to integrate and
  use your API.
- Industry leading API Key Authentication with Github secret scanning.
- Add robust security to your APIs without compromising development time or flexibility.
- Always use environment variables for API keys.
- OpenAI actively scans for leaked keys and may disable them automatically.
- Edge execution fundamentally changes how you monitor APIs.
- Monitoring configuration should be stored under version control.
- Yelp allows caching API responses for up to 24 hours
- The Fusion API enforces strict limits that quickly become problems as your application
  grows
- Uses Bearer token authentication — requires API key in Authorization header
- Rate limiting is used to control the number of requests that can be made to an API
  within a specified time frame.
- It is recommended to return a 429 status code for rate limiting.
- A Retry-After header can be included to inform users how long they should wait.
- 'Rate limits: 100 queries per minute (QPM) for the free tier OAuth clients, 10 QPM
  without OAuth'
- Mandatory OAuth 2.0 authentication for all requests
- Uses OAuth2 for authentication — requires setup on UPS Developer Portal
- API authentication is a cornerstone of modern API security.
- BFF Authentication simplifies auth code while enhancing security.
- Requires setup of session cookies for API authentication.
- All requests to the Airtable API require authentication using an API key.
- For Jira Cloud, prefer API tokens over passwords.
- The API respects all permission settings configured in the application.
- Uses a custom query language for filtering API requests.
- Implementing security checks for allowed fields in queries.
- Slack uses OAuth 2.0 for authentication.
- This article primarily focuses on the technical implementation of rate limiting.
- Caching not only enhances performance but, when combined with advanced API management
  tools, it can make rate-limiting strategies even more efficient.
- Uses OAuth authentication methods for secure access.
- Test your integration using QuickBooks' sandbox environment.
- Rate limits are based on account type (free, paid, or enterprise).
- Provides basic access with limited API calls per day.
- Higher rate limiting for free tier.
- Always use HTTPS to encrypt the transmission of credentials.
errors:
- The caller does not have permission to execute the specified operation
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'Emergency Phone Support: Customers with emergency phone support can call +1 833-681-6018
  to open an emergency support ticket.'
- '429 Too many requests: Indicates that the rate limit has been exceeded.'
- '401 Unauthorized: Recheck API key or authentication setup'
- '405 Method Not Allowed: Check your API definition for allowed methods.'
- '404: Resource not found'
- '422: Validation failed'
- 'REST_ERROR: Failed to fetch movie data'
- '400: Invalid XML format'
- '500: XML processing failed'
- '406 Not Acceptable: Requested media type not supported'
- 'Validation failed: Check your input for errors.'
- '429 Too Many Requests: User''s request count is above limit.'
- '429 Too Many Requests: Too many requests, please try again later.'
- '401 Unauthorized: Check if the API key is provided.'
- '403 Forbidden: User does not have the required role.'
- '429 Too Many Requests: Request limit exceeded'
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- '429 Too Many Requests: Client has reached rate limit.'
- '400: Bad Request: Requests that do not conform to your OpenAPI schema will be rejected.'
- '400: Returned for nefarious content attempting to inject or poison.'
- '400 Forbidden: The incoming origin is missing or not allowed.'
- '401 Unauthorized: Ensure your API Key is valid.'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- '401 Unauthorized: Recheck API key or permissions'
- Invalid order data
- '200: Healthy response'
- '500: Internal server error'
- '400 Bad Request: Occurs when you''ve provided invalid parameters or malformed requests'
- '401 Unauthorized: Indicates authentication failures, typically caused by invalid
  API keys'
- '429 Too Many Requests: You''ve hit Yelp''s rate limit, which restricts accounts
  to 500 requests per day'
- '500 Internal Server Error: Represents temporary server-side issues within Yelp''s
  infrastructure'
- '401 Unauthorized: Recheck API key or token expiration'
- '429: Too Many Requests'
- '401 Unauthorized: Recheck OAuth credentials or token expiration'
- '401 Unauthorized: Recheck API key'
- '400: Bad request'
- '401: Authentication failed. Check your credentials.'
- '403: You don''t have permission to access this resource.'
- '429: Rate limited. Waiting for retry.'
- 429 Too many requests
- 'error: ''not_authed'': No authentication token provided.'
- 'error: ''invalid_auth'': Invalid authentication token.'
- '401 Unauthorized: Authentication failure (invalid token)'
- '400 Bad Request: Malformed request (invalid JSON or missing required fields)'
- '429 Too Many Requests: Rate limit exceeded'
- '500 Internal Server Error: Server errors (temporary issues)'
- '429: Rate limit exceeded'
- '401: Unauthorized access'
- '429: Rate limit exceeded. Try again later.'
- '401: Authentication error. Check your API token.'
- '401 Unauthorized: Recheck credentials.'
auth_info:
  mentioned_objects:
  - devise
  - devise-jwt
  - AuthZenInboundPolicy
  - OpenFGAAuthZInboundPolicy
  - request.user
  - context.log
  - OauthToken
  - API Token
  - App
  - OAuth scopes
client:
  base_url: https://zuplo.com
  auth:
    type: oauth2
source_metadata: null
