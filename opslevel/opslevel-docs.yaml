resources:
- name: api_docs
  endpoint:
    path: /api/docs
    method: GET
    data_selector: docs
    params: {}
- name: assign
  endpoint:
    path: /assign
    method: POST
- name: completion
  endpoint:
    path: /completion
    method: POST
- name: create
  endpoint:
    path: /create
    method: POST
- name: delete
  endpoint:
    path: /delete
    method: DELETE
- name: example
  endpoint:
    path: /example
    method: GET
- name: export
  endpoint:
    path: /export
    method: GET
- name: get
  endpoint:
    path: /get
    method: GET
- name: graphql
  endpoint:
    path: /graphql
    method: POST
- name: help
  endpoint:
    path: /help
    method: GET
- name: import
  endpoint:
    path: /import
    method: POST
- name: list
  endpoint:
    path: /list
    method: GET
- name: run
  endpoint:
    path: /run
    method: POST
- name: unassign
  endpoint:
    path: /unassign
    method: POST
- name: update
  endpoint:
    path: /update
    method: PUT
- name: version
  endpoint:
    path: /version
    method: GET
- name: account
  endpoint:
    path: /graphql
    method: POST
    data_selector: data.account
- name: services
  endpoint:
    path: /services
    method: GET
    data_selector: nodes
- name: service_create
  endpoint:
    path: /serviceCreate
    method: POST
    data_selector: service
- name: service_update
  endpoint:
    path: /serviceUpdate
    method: POST
    data_selector: service
- name: service_delete
  endpoint:
    path: /serviceDelete
    method: POST
    data_selector: deletedServiceId
- name: tag_assign
  endpoint:
    path: /tagAssign
    method: POST
    data_selector: tags
- name: tag_delete
  endpoint:
    path: /tagDelete
    method: POST
    data_selector: errors
- name: services
  endpoint:
    path: /account/services
    method: POST
- name: service
  endpoint:
    path: /account/service
    method: POST
- name: tags
  endpoint:
    path: /account/tags
    method: POST
- name: team
  endpoint:
    path: /opslevel/team
    method: POST
    data_selector: team
- name: service
  endpoint:
    path: /opslevel/service
    method: POST
    data_selector: service
- name: check_repository_integrated
  endpoint:
    path: /opslevel/check/repository_integrated
    method: POST
    data_selector: check
- name: services
  endpoint:
    path: /v1/full/services/:date/:timestamp/
    method: GET
    data_selector: services
    params: {}
- name: check_results
  endpoint:
    path: /v1/full/check_results/:date/:timestamp/
    method: GET
    data_selector: check_results
    params: {}
- name: teams
  endpoint:
    path: /v1/full/teams/:date/:timestamp/
    method: GET
    data_selector: teams
    params: {}
- name: sbom_upload
  endpoint:
    path: /upload/documents/sbom/<resource_id>
    method: POST
    data_selector: status
- name: teams
  endpoint:
    path: /api/teams
    method: GET
    data_selector: teams
    params: {}
- name: users
  endpoint:
    path: /api/users
    method: GET
    data_selector: users
    params: {}
- name: components
  endpoint:
    path: /api/v1/components
    method: GET
    data_selector: data
    params: {}
- name: relationship_definitions
  endpoint:
    path: /api/relationship_definitions
    method: GET
    data_selector: data
    params: {}
- name: infrastructure_objects
  endpoint:
    path: /import/infrastructure-objects
    method: POST
    data_selector: data
    params: {}
- name: OpsLevelIntegrationPolicy
  endpoint:
    path: /services/iam/policies
    method: POST
    data_selector: policy
    params: {}
- name: OpsLevelIntegrationRole
  endpoint:
    path: /services/iam/roles
    method: POST
    data_selector: role
    params: {}
- name: aws_integration
  endpoint:
    path: /awsIntegrationCreate
    method: POST
    data_selector: integration
    params: {}
- name: ownershipTagOverrides
  endpoint:
    path: /update/integration
    method: POST
    data_selector: spec
    params:
      ownershipTagOverrides: true
      ownershipTagKeys:
      - owner
      - service
      - app
- name: infrastructure_objects
  endpoint:
    path: /services/data/vXX.X/infrastructure_objects
    method: GET
    data_selector: records
- name: infrastructureResourceCreate
  endpoint:
    path: /graphql
    method: POST
    data_selector: infrastructureResourceCreate
    params: {}
- name: infrastructureResourceSchemas
  endpoint:
    path: /graphql
    method: POST
    data_selector: infrastructureResourceSchemas
    params: {}
- name: create_system
  endpoint:
    path: /api/systems
    method: POST
    data_selector: system
    params:
      name: required
- name: Systems
  endpoint:
    path: /api/systems
    method: GET
    data_selector: systems
- name: Domain
  endpoint:
    path: /api/domains
    method: POST
    data_selector: domain
    params:
      name: required
      owner: ''
      description: ''
- name: create_domain
  endpoint:
    path: /domains
    method: POST
    data_selector: domain
    params: {}
- name: component_type
  endpoint:
    path: /graphql
    method: POST
    data_selector: data
    params: {}
- name: SAML Configuration
  endpoint:
    path: /sso/configuration
    method: POST
    data_selector: configuration
    params: {}
- name: SAML_Endpoint_URL
  endpoint:
    path: /users/auth/saml/callback
    method: GET
    data_selector: Provider Key
    params: {}
- name: SAML Application
  endpoint:
    path: /account
    method: GET
    data_selector: SAML Endpoint URL
    params: {}
- name: saml_metadata
  endpoint:
    path: /users/auth/saml/metadata
    method: GET
    data_selector: ''
    params:
      provider_key: '{provider_key}'
- name: saml_callback
  endpoint:
    path: /users/auth/saml/callback
    method: GET
    data_selector: ''
    params:
      provider_key: '{provider_key}'
- name: usersInvite
  endpoint:
    path: /graphql
    method: POST
    data_selector: data.usersInvite
    params: {}
- name: userInvite
  endpoint:
    path: /graphql
    method: POST
    data_selector: data.userInvite
    params: {}
- name: SCIM Integration
  endpoint:
    path: /scim/v1/Users
    method: POST
    data_selector: users
    params: {}
- name: Provisioning
  endpoint:
    path: /api/v1/provision
    method: POST
- name: teams
  endpoint:
    path: /orgs/{org}/teams
    method: GET
    data_selector: teams
    params: {}
- name: team_memberships
  endpoint:
    path: /teams/{team_id}/memberships/{username}
    method: GET
    data_selector: membership
    params: {}
- name: SCIM API
  endpoint:
    path: /scim/v2/Users
    method: POST
    data_selector: schemas
    params: {}
- name: Scorecard
  endpoint:
    path: /scorecards
    method: GET
    data_selector: scorecards
- name: service_level_badges
  endpoint:
    path: /service-level-badges
    method: GET
    data_selector: badges
    params: {}
- name: Maturity Report
  endpoint:
    path: /maturity-report
    method: GET
    data_selector: service_level_data
    params: {}
- name: service_template
  endpoint:
    path: /service-templates
    method: GET
    data_selector: templates
    params: {}
- name: service
  endpoint:
    path: /service
    method: POST
    data_selector: service_data
- name: service_repository
  endpoint:
    path: /service_repository
    method: POST
    data_selector: repository_data
- name: template_run
  endpoint:
    path: /template_run
    method: POST
    data_selector: template_run_data
- name: user
  endpoint:
    path: /user
    method: GET
    data_selector: user_data
- name: owner
  endpoint:
    path: /owner
    method: GET
    data_selector: owner_data
- name: contact
  endpoint:
    path: /contact
    method: GET
    data_selector: contact_data
- name: response
  endpoint:
    path: /response
    method: GET
    data_selector: response_data
- name: template_run
  endpoint:
    path: /template_run
    method: POST
    data_selector: inputs
    params: {}
- name: user
  endpoint:
    path: /user
    method: GET
    data_selector: user
    params: {}
- name: service
  endpoint:
    path: /service
    method: GET
    data_selector: service
    params: {}
- name: action_owner
  endpoint:
    path: /action_owner
    method: GET
    data_selector: action_owner
    params: {}
- name: campaign
  endpoint:
    path: /api/campaigns
    method: GET
    data_selector: campaigns
- name: campaign
  endpoint:
    path: /api/campaigns
    method: GET
    data_selector: data
    params: {}
- name: recurring_campaign_reminders
  endpoint:
    path: /campaigns/recurring_reminders
    method: POST
    data_selector: reminders
    params: {}
- name: ad_hoc_campaign_reminders
  endpoint:
    path: /campaigns/ad_hoc_reminders
    method: POST
    data_selector: reminders
    params: {}
- name: alert_source_usage_check
  endpoint:
    path: /alert-source-usage-checks
    method: GET
    data_selector: checks
- name: branch_protection
  endpoint:
    path: /branch/protection
    method: GET
    data_selector: protection_rules
- name: custom_event_check
  endpoint:
    path: /integrations/custom_event
    method: POST
    data_selector: messages
- name: Custom Event Check
  endpoint:
    path: /
    method: POST
    data_selector: messages
    params:
      alias:
      - service1
      - service2
- name: repo_file_check
  endpoint:
    path: /repo/file/checks
    method: GET
    data_selector: checks
    params: {}
- name: package_manager
  endpoint:
    path: /package-manager
    method: GET
    data_selector: packages
    params: {}
- name: package
  endpoint:
    path: /package
    method: GET
    data_selector: packages
    params: {}
- name: Check Overview
  endpoint:
    path: /api/checks/overview
    method: GET
    data_selector: checks
- name: Check Report Page
  endpoint:
    path: /api/checks/report
    method: GET
    data_selector: report
- name: Check Progress Trend
  endpoint:
    path: /api/checks/progress-trend
    method: GET
    data_selector: progress
- name: Report by Service
  endpoint:
    path: /api/checks/report/service
    method: GET
    data_selector: service_report
- name: Reports by Team
  endpoint:
    path: /api/checks/report/team
    method: GET
    data_selector: team_report
- name: deploy
  endpoint:
    path: /integrations/deploy
    method: POST
    data_selector: result
- name: Component Maturity Overview
  endpoint:
    path: /service-maturity-report
    method: GET
    data_selector: components
- name: Trigger Jenkins Pipeline
  endpoint:
    path: /remoteAccess/api
    method: POST
- name: manual_inputs
  endpoint:
    path: /docs/configuring-custom-actions-manual-inputs
    method: GET
    data_selector: inputs
    params: {}
- name: contacts
  endpoint:
    path: /contacts
    method: GET
    data_selector: contacts
- name: tags
  endpoint:
    path: /tags
    method: GET
    data_selector: tags
- name: custom_action
  endpoint:
    path: /actions
    method: POST
    data_selector: action_response
    params: {}
- name: custom_actions_trigger_definitions
  endpoint:
    path: /graphql
    method: POST
    data_selector: account.customActionsTriggerDefinitions.nodes
    params: {}
- name: invoke_custom_action
  endpoint:
    path: /graphql
    method: POST
    data_selector: customActionsTriggerInvoke.triggerEvent
    params: {}
- name: get_custom_action_trigger_event
  endpoint:
    path: /graphql
    method: POST
    data_selector: account.customActionsTriggerEvent
    params: {}
- name: teams
  endpoint:
    path: /api/teams
    method: GET
    data_selector: teams
    params: {}
- name: components
  endpoint:
    path: /api/components
    method: GET
    data_selector: components
    params: {}
- name: webhook
  endpoint:
    path: /integrations/github/webhook
    method: POST
    data_selector: payload
- name: finish_setup
  endpoint:
    path: /integrations/github/finish_setup
    method: GET
    data_selector: setup
- name: Slack Application Manifest
  endpoint:
    path: /integrations/slack/webhook
    method: POST
    data_selector: features.slash_commands
    params: {}
- name: custom_integration
  endpoint:
    path: /custom_integration
    method: POST
    data_selector: integration
    params: {}
- name: get_integrations
  endpoint:
    path: /get_integrations
    method: GET
    data_selector: nodes
    params: {}
- name: code_issue
  endpoint:
    path: /api/v1/code_issues
    method: POST
    data_selector: codeIssues
- name: create_code_issue_project
  endpoint:
    path: /api/code-issues
    method: POST
    data_selector: codeIssueProjectUpsert
    params: {}
- name: delete_code_issue
  endpoint:
    path: /api/code-issues
    method: DELETE
    data_selector: codeIssueDelete
    params: {}
- name: code_issue_project
  endpoint:
    path: /api/code_issue_project
    method: POST
    data_selector: codeIssueProject
    params: {}
- name: code_issue
  endpoint:
    path: /api/code_issue
    method: POST
    data_selector: codeIssue
    params: {}
- name: alert_sources
  endpoint:
    path: /api/alert_sources
    method: POST
- name: alert_source_delete
  endpoint:
    path: /alertSourceDelete
    method: POST
    data_selector: deletedId
    params:
      input: ExternalResourceIdentifierInput!
- name: alert_source
  endpoint:
    path: /alert-sources
    method: POST
    data_selector: alertSource
    params: {}
- name: alert_source
  endpoint:
    path: /alert/sources
    method: POST
    data_selector: alertSource
    params: {}
- name: alert_source
  endpoint:
    path: /alert-sources
    method: POST
    data_selector: alertSourceUpsert
    params: {}
- name: link_alert_source
  endpoint:
    path: /link-alert-source
    method: POST
    data_selector: alertSourceServiceCreate
    params: {}
- name: unlink_alert_source
  endpoint:
    path: /unlink-alert-source
    method: POST
    data_selector: alertSourceServiceDelete
    params: {}
- name: alert_source
  endpoint:
    path: /alert-sources
    method: POST
    data_selector: alertSource
    params: {}
- name: alert_source_service
  endpoint:
    path: /alert-source-services
    method: POST
    data_selector: alertSourceService
    params: {}
- name: alert_source_status
  endpoint:
    path: /alert-source-status
    method: POST
    data_selector: alertSource
    params: {}
- name: alert_source
  endpoint:
    path: /api/alert_sources
    method: POST
    data_selector: alertSource
    params: {}
- name: alert_source_service
  endpoint:
    path: /api/alert_source_service
    method: POST
    data_selector: alertSourceService
    params: {}
- name: alert_source
  endpoint:
    path: /manage-alert-sources-via-api
    method: POST
    data_selector: alertSource
    params: {}
- name: alert_source
  endpoint:
    path: /alert-sources
    method: POST
    data_selector: alertSource
    params: {}
- name: custom_integration
  endpoint:
    path: /integrations/custom/webhook
    method: POST
    data_selector: data
    params:
      external_kind: jira_epic_push_data
- name: transform_definition
  endpoint:
    path: /integrations/custom/webhook
    method: POST
    data_selector: transforms
    params:
      external_kind: jira_epic_push_data
- name: jira_issue
  endpoint:
    path: /rest/api/3/search
    method: GET
    params:
      jql: project=TECH AND labels=technical-debt
      startAt: '{{ cursor | default: ''0'' }}'
      maxResults: 50
- name: jira_issue
  endpoint:
    path: /rest/api/3/search
    method: GET
    data_selector: issues
    params:
      jql: project=TECH AND labels=technical-debt
- name: jira_issue
  endpoint:
    path: /rest/api/3/search
    method: GET
    params:
      jql: project=TECH AND labels=technical-debt
      startAt: '{{ cursor | default: ''0'' }}'
      maxResults: '50'
- name: jira_issue
  endpoint:
    path: ''
    method: GET
    data_selector: issues
    params:
      iterator: .issues
      exclude: .fields.status.name == "Done" or .fields.status.name == "Closed"
      expires_after_days: 30
- name: sentry_project
  endpoint:
    path: https://sentry.io/api/0/projects/
    method: GET
    data_selector: ''
    params:
      iterator: .
      external_id: .id
      exclude: .name | test("staging")
- name: jira_issue
  endpoint:
    path: /rest/api/3/search
    method: GET
    data_selector: issues
    params:
      jql: project=TECH AND labels=technical-debt
- name: sentry_project
  endpoint:
    method: GET
    http_polling:
      url: '{% if cursor %}{{cursor}}{% else %}https://sentry.io/api/0/projects/{%
        endif %}'
      headers:
      - name: Accept
        value: application/json
      - name: Authorization
        value: Bearer {{ 'sentry_api_token' | secret }}
- name: sentry_issue
  endpoint:
    method: GET
    http_polling:
      for_each: sentry_project
      url: '{% if cursor %}{{cursor}}{% else %}https://sentry.io/api/0/projects/your_org/{{
        sentry_project.id }}/issues/{% endif %}'
      headers:
      - name: Accept
        value: application/json
      - name: Authorization
        value: Bearer {{ 'sentry_api_token' | secret }}
- name: events
  endpoint:
    path: /issues/{{ sentry_issue.id }}/events/
    method: GET
- name: on_component_not_found
  endpoint:
    path: /docs/automating-component-creation-for-your-customizable-data-mapping
    method: GET
    data_selector: transforms
    params: {}
- name: opslevel-report-deploy
  endpoint:
    path: /argo-cd/resource-hooks
    method: POST
    data_selector: containers
    params: {}
- name: report_deploy
  endpoint:
    path: /opslevel/report_deploy
    method: POST
    data_selector: deploy
    params: {}
- name: Coveralls Check
  endpoint:
    path: /coveralls
    method: POST
- name: datadog_check
  endpoint:
    path: /datadog/checks
    method: POST
    data_selector: checks
    params: {}
- name: GitHub Integration
  endpoint:
    path: /api/github/integration
    method: POST
- name: GitLab Integration
  endpoint:
    path: /api/gitlab/integration
    method: POST
- name: Azure DevOps Git Integration
  endpoint:
    path: /api/azure-devops/integration
    method: POST
- name: Bitbucket Integration
  endpoint:
    path: /api/bitbucket/integration
    method: POST
- name: code_scanning_alerts
  endpoint:
    path: /code-scanning/alerts
    method: GET
- name: GitHub Actions Deploy Integration
  endpoint:
    path: /deploy-event-github-action
    method: POST
    data_selector: deploys
    params:
      OL_INTEGRATION_URL: Webhook URL
- name: OpsLevel
  endpoint:
    path: /alerting/contact-points
    method: POST
    data_selector: contact_point
    params: {}
- name: Notification Policy
  endpoint:
    path: /alerting/notification-policies
    method: POST
    data_selector: notification_policy
    params: {}
- name: vulnerabilities
  endpoint:
    path: /integrations/custom_event
    method: POST
    data_selector: vulnerabilities
- name: jenkins_integration
  endpoint:
    path: /integrations/deploy
    method: POST
    data_selector: webhookUrl
- name: service
  endpoint:
    path: /
    method: import
    data_selector: import
    params:
      selector:
        apiVersion: apps/v1
        kind: Deployment
        excludes:
        - .metadata.namespace == "kube-system"
        - .metadata.annotations."opslevel.com/ignore"
      opslevel:
        name: .metadata.name
        description: .metadata.annotations."opslevel.com/description"
        owner: .metadata.annotations."opslevel.com/owner"
        lifecycle: .metadata.annotations."opslevel.com/lifecycle"
        tier: .metadata.annotations."opslevel.com/tier"
        product: .metadata.annotations."opslevel.com/product"
        language: .metadata.annotations."opslevel.com/language"
        framework: .metadata.annotations."opslevel.com/framework"
        aliases:
        - '"k8s:\(.metadata.name)-\(.metadata.namespace)"'
        tags:
          assign:
          - '{"imported": "kubectl-opslevel"}'
          - '.metadata.annotations | to_entries |  map(select(.key | startswith("opslevel.com/tags")))
            | map({(.key | split(".")[2]): .value})'
          - .metadata.labels
          create:
          - '{"environment": .spec.template.metadata.labels.environment}'
        tools:
        - '{"category": "other", "displayName": "my-cool-tool", "url": .metadata.annotations."example.com/my-cool-tool"}
          | if .url then . else empty end'
        - '.metadata.annotations | to_entries |  map(select(.key | startswith("opslevel.com/tools")))
          | map({"category": .key | split(".")[2], "displayName": .key | split(".")[3],
          "url": .value})'
        repositories:
        - '{"name": "My Cool Repo", "directory": "/", "repo": .metadata.annotations.repo}
          | if .repo then . else empty end'
        - .metadata.annotations.repo
        - '.metadata.annotations | to_entries |  map(select(.key | startswith("opslevel.com/repos")))
          | map({"name": .key | split(".")[2], "directory": .key | split(".")[3:]
          | join("/"), "repo": .value})'
- name: vulnerabilities
  endpoint:
    path: /api/v2/Vulnerabilities/Containers/search
    method: POST
    data_selector: data
    params: {}
- name: alert_conditions
  endpoint:
    path: /v2/alerts_conditions
    method: GET
    data_selector: conditions
- name: OpsLevel Community Step
  endpoint:
    path: /octopus-deploy/community-step
    method: GET
    data_selector: steps
    params: {}
- name: Service
  endpoint:
    path: /v1/Service
    method: GET
    data_selector: resources
- name: Deployment
  endpoint:
    path: /apps/v1/Deployment
    method: GET
    data_selector: resources
- name: StatefulSet
  endpoint:
    path: /apps/v1/StatefulSet
    method: GET
    data_selector: resources
- name: DaemonSet
  endpoint:
    path: /apps/v1/DaemonSet
    method: GET
    data_selector: resources
- name: CronJob
  endpoint:
    path: /batch/v1/CronJob
    method: GET
    data_selector: resources
- name: Prometheus Alert Checks
  endpoint:
    path: /prometheus/alert/checks
    method: POST
    data_selector: results
    params: {}
- name: Sentry Issues
  endpoint:
    path: /api/0/projects/${ORGANIZATION_SLUG}/${PROJECT_SLUG}/issues/
    method: GET
- name: code_issues
  endpoint:
    path: /api/issues/search
    method: GET
    data_selector: issues
- name: projects
  endpoint:
    path: /api/projects/search
    method: GET
    data_selector: components
- name: Sumo Logic Check
  endpoint:
    path: /api/v1/checks/sumo-logic
    method: POST
    data_selector: checks
    params: {}
- name: payload_check
  endpoint:
    path: /integrations/payload/{checkIdentifier}
    method: POST
    data_selector: result
    params: {}
- name: payload_check
  endpoint:
    path: /integrations/payload/{checkIdentifier}
    method: POST
    data_selector: result
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: teams
  endpoint:
    path: /api/v1/teams
    method: GET
    data_selector: records
    params: {}
- name: components
  endpoint:
    path: /api/v1/components
    method: GET
    data_selector: records
    params: {}
- name: infrastructure_objects
  endpoint:
    path: /import/infrastructure/objects/aws
    method: POST
- name: teams
  endpoint:
    path: /api/v1/teams
    method: GET
    data_selector: data
    params: {}
- name: teams
  endpoint:
    path: /api/teams
    method: GET
    data_selector: teams
    params: {}
- name: components
  endpoint:
    path: /api/components
    method: GET
    data_selector: components
    params: {}
- name: custom_deploys
  endpoint:
    path: /deploys
    method: GET
    data_selector: deployments
- name: components
  endpoint:
    path: /api/components
    method: GET
    data_selector: records
    params: {}
- name: components
  endpoint:
    path: /api/components
    method: GET
    data_selector: data
- name: alert_sources
  endpoint:
    path: /api/alert_sources
    method: POST
- name: error_checks
  endpoint:
    path: /api/1/errors
    method: GET
    data_selector: records
- name: vulnerability_checks
  endpoint:
    path: /api/v1/vulnerability_checks
    method: GET
notes:
- Uses OAuth2 with refresh token — requires setup of connected app in OpsLevel
- Multiple repositories can be connected to a service.
- The CLI is currently in beta and does not yet support all resources and CRUD actions.
- OpsLevel limits query results for an object to a maximum of 100 results.
- Always include the *errors* field in your mutations.
- The OpsLevel API offers more queries which can be found in GraphiQL’s Docs tab.
- Always include the errors field in your mutations.
- GraphQL API allows for rich data queries with a single request.
- Objects can be paginated using cursor-based pagination.
- 'IP Address Request Limit: No more than 10,000 requests every 5 mins from a single
  IP Address'
- 'API Token Request Limit: No more than 400 API requests per minute per API token'
- Uses OAuth2 with shared secret for signing webhooks
- OpsLevel uses YAML 1.1, to ensure that values are treated as strings it is highly
  recommended to use quotes around values.
- API token is required for authentication
- Ensure team’s manager email is associated with a user in OpsLevel account
- Full pushes are done on a weekly basis and incremental pushes are done on a daily
  basis.
- For incremental style pushes, deleted records will be specified by sending a row
  with the id with the deleted_at column specifying the time the record was deleted
  at.
- Manually uploaded SBOM files are processed at most once per day.
- The API token is required for authentication.
- 'Currently the MCP server only uses read-only access to your OpsLevel account and
  can read data from the following resources: Actions, Checks, Components, Documentation
  (API & Tech Docs), Domains, Filters, Infrastructure, Repositories, Systems, Teams,
  Users.'
- Some objects may return nulls in deeply nested fields
- Allows for automatic connection of components, teams, and users based on specified
  properties.
- OpsLevel can track ownership of all your git repos, not just software components.
- Some repositories can be hidden to avoid cluttering your account with old, unused
  repositories.
- OpsLevel supports sophisticated relationships such as monorepos.
- Create IAM policy and role in your AWS account
- Ensure to use OpsLevel's account ID 746108190720 for the role's trust relationship
- OpsLevel uses AWS APIs to sync infrastructure objects, including Lambdas.
- OpsLevel requires a client secret during setup
- Google Cloud IAM Policy changes take 2-7 minutes to take effect.
- If integrating with multiple service accounts, ensure the project scopes are distinct
  to avoid issues with duplicated resources.
- We synchronize changes from Google Cloud every 12 hours.
- Use Systems to group together Components that combine to form a single unit.
- Uses OAuth2 with refresh token — requires setup of connected app in api
- Uses OAuth2
- Input is always validated against the property schema when modifying data in the
  UI.
- Components are currently released in Beta and the Service APIs along with the new
  type field are used to interact with Components.
- Configure Auth0 as a SAML identity provider.
- Use the value of the Auth0 certificate as the input for the X.509 certificate field
  under the Authentication Method portion of your OpsLevel account settings.
- You will need to be a Administrator on your Google account.
- You will need access to your SAML Endpoint URL located in the Authentication Method
  section of your Account Settings.
- OpsLevel looks for email, first_name, and last_name in SAML attributes.
- The Namespace field within each claim must be left blank.
- 'The following SAML attributes are supported: first_name: user.firstName, last_name:
  user.lastName, email: user.email.'
- Ensure 'Include in SAML assertion' is checked for every field.
- Ensure that you use SHA1 token encryption for SAML tokens.
- Different IdPs may have different names for the uid attribute.
- This mutation respects the enable_notifications feature, so it will not send an
  email invite if email_notifications is toggled off.
- Ensure that you keep the API token in a safe place as you will need it when configuring
  the integration within Okta.
- SCIM-based user provisioning is available to all customers of OpsLevel at this time.
- OpsLevel supports the SCIM v2 User provisioning operations.
- OpsLevel expects the userName to be in email format and we suggest using the userPrincipalName
  by default, but email is a good alternative depending on your organization.
- At this time, OpsLevel only supports synchronization of the primary email, however
  we plan to support additional emails in the future.
- Sync teams every 12 hours.
- Does not sync deleted teams/users from GitHub.
- Ensure that you keep the API token in a safe place as you will need it when configuring
  the integration within OneLogin.
- Users provisioned automatically through SCIM or SSO will receive the Team Member
  role by default.
- Scorecards are an Advanced feature, and can be enabled or disabled for your account
  using Feature Management.
- Services may be scored with a level of Beginner, but you will not see this special
  level show up on the rubric itself because it cannot contain any checks.
- Badges are dynamically updating and can be displayed in Git repositories.
- Users need to have the Admin role to be able to import templates.
- Service Creation can be used to define reusable templates.
- OpsLevel supports the use of Cookiecutter templates for service creation.
- Campaigns allow you to roll out changes in your engineering organization.
- Campaigns must have checks defined to evaluate completion.
- Reminders will only be sent out to component owners that have defined a Slack and/or
  email contact method in OpsLevel.
- Reminders will not be sent for campaigns that are in the Draft or Scheduled states.
- The protection rules that can be defined vary by Git provider.
- Payloads will have a size limit of 4MiB and payloads above this size will receive
  a HTTP 413 response.
- Repo File Checks can verify the existence or contents of a file in a service's repo.
- Updated over 1 year ago
- The Search check is much more computationally expensive to run and is throttled
  on the integration’s side, so should be used sparingly.
- It doesn’t work with forked repositories.
- It can’t limit the search to a specific file. If you need that, use a Repo File
  Check.
- It runs after a 2 minute delay for Github integrations due to limitations with their
  API.
- Tags can be used to enrich your services with arbitrary metadata.
- Ensure that services have a tag with key 'node-version' with a version that is at
  least '12.0.0'.
- Component Detection is enabled by default for Datadog and Git Integrations.
- 'OpsLevel recognizes files with the following extensions as Markdown files: .md,
  .mkd, .mdwn, .mdown, .mdtxt, .mdtext, and .markdown'
- CSV exports are limited to 25,000 records.
- Actions enable users to complete common, standardized tasks in an easy and consistent
  way
- Your Jenkins instance will need to be publicly accessible so that OpsLevel's request
  can reach it.
- The Jenkins jobs or pipelines you wish to run will need to be enabled for remote
  triggering.
- Filters are globally available in OpsLevel.
- You must have an Admin role to configure your account's Signing Secret
- Removing the original Signing Secret will break any existing signature verification
- Removing the original Signing Secret will break any existing signature verification
  that you may have in place.
- API tokens can run any custom action you have created because they are considered
  to be Administrators.
- You cannot use the user object in liquid templates that are part of an action you
  invoke via API.
- Only administrators can customize their account's layouts via the UI Customization
  page under Settings.
- 'Beta Limitations: No grouping of value ranges is currently available (each value
  is grouped by exact matches).'
- Admins are able to configure whether notifications are sent for their account.
- Ensure you have admin access to third-party software for integrations
- Default settings are provided for Kubernetes; customize for production use
- Once you have made this update to your helm chart for opslevel and successfully
  deployed the application you can follow the typical steps outlined in our AWS Integration
  guide.
- 'OpsLevel requires the following scopes: Identity (read), Code (read), Project and
  team (read)'
- Webhook should be Active for the application.
- SSL Verification should be enabled.
- /integrations/gitlab/finish_setup has been added to the redirect uri.
- The app should have Confidential enabled.
- 'The following scopes: api, read_repository, write_repository.'
- This integration requires that your Self-Hosted OpsLevel Instance is available to
  receive requests over the internet from Jira Cloud.
- This integration relies heavily on webhooks, so for the full experience your Self-Hosted
  OpsLevel instance must be accessible to Jira Cloud.
- This integration requires that your Self-Hosted OpsLevel Instance is available to
  receive requests over the internet from PagerDuty
- This integration relies heavily on webhooks, so for the full experience your Self-Hosted
  OpsLevel instance must be accessible to PagerDuty.
- This integration requires that your Self-Hosted OpsLevel Instance is available to
  receive requests over the internet from Slack.
- This integration relies heavily on webhooks.
- OpsLevel automatically creates Code Issues through native integrations with code
  quality tools.
- Each Code Issue represents one specific instance of an identified issue.
- OpsLevel automatically creates Code Issues through native integrations.
- Requires setup of connected app in OpsLevel
- All Alert Sources sent via API must be connected to a Custom Integration.
- All Alert Sources sent via API must be connected to a Custom Integration
- Webhook URL is used to push data to OpsLevel.
- Polling for integration data instead of waiting for it to be pushed
- Items that are excluded will be deleted from OpsLevel
- The exclude parameter will delete issues with status 'Done' or 'Closed'.
- Jira returns 400 for invalid JQL queries.
- Uses Bearer token for authorization
- Polling is set up to extract Jira issues based on specific criteria
- OpsLevel detects components by matching both the opslevel_kind and opslevel_identifier
  fields.
- Sending the image scan results to OpsLevel can be done with a webhook. You will
  need to have the webhook send the payload to the integration url you created.
- Integrate ArgoCD deployments with OpsLevel's deploy integration to notify teams
  when and how often ArgoCD managed services are successfully released.
- Integrate with CircleCI to track deploys
- Ensure your service's images are free of known vulnerabilities.
- In Codacy, you will need to configure a webhook notification per repository using
  the Integration details from Step 1.
- Ensure that the authentication keys' associated user has both the monitor_read and
  monitor_write permissions enabled.
- For any Datadog metric alert, you can create a Webhook using the URL from the integration.
- For any Dynatrace alerting profile, you can create a problem notification using
  the Webhook URL from the integration you created above.
- To set up a Git integration, go to our Integrations tab and hit 'New Integration'.
- We recommend using a new Incognito/Private browsing window to perform these steps.
  This is due to how Azure DevOps retains your login session.
- Integrating with OpsLevel's Bitbucket App does not require any direct setup within
  Bitbucket.
- It's advisable to setup a service account in Bitbucket to use as the OAuth user
  when integrating.
- OpsLevel recommends using GitHub App integration for its simplicity and built-in
  rotation of secrets.
- OpsLevel expects classic GitHub Personal Access Tokens, rather than Fine-grained
  tokens.
- OpsLevel supports repository integrations with GitLab versions 16.11+
- The GitHub Action only has 1 required parameter OL_INTEGRATION_URL, which we recommend
  filling with a secret from your repositories secret configuration.
- Do not use Classic Condition if you want to use $labels in the template, as this
  is not supported by Grafana
- Uses Grype CLI to send vulnerabilities for a service
- OpsLevel will now be notified after every successful build!
- Sending the scan results to OpsLevel can be done with a webhook.
- For the integration between Jira and OpsLevel to work properly you’ll need to manually
  setup webhooks on Jira’s side.
- You will have to do this for every site you’ve authorized with OpsLevel.
- 'This step does not validate any of the data with OpsLevel - fields that are references
  to other things (IE: Tier, Lifecycle, Owner, etc) are not validated at this point
  and might cause a warning message during import'
- The downloaded API key is just a JSON file containing a few secrets.
- You must add the bot to each channel to send OpsLevel notifications.
- OpsLevel will require your OpsGenie account be on a Standard or Enterprise plan,
  and that the provided API key has Read and Configuration Access rights.
- OpsLevel’s PagerDuty integration relies on receiving webhooks from PagerDuty, so
  in addition to having active accounts on OpsLevel and PagerDuty, a user must have
  at least the *Admin* role to successfully integrate OpsLevel with PagerDuty’s webhooks.
- Configuring the incident.io Integration in OpsLevel requires an incident.io API
  key.
- User setting up the integration will require sufficient permissions - usually the
  Admin role.
- Configuring the FireHydrant Integration in OpsLevel requires a FireHydrant API key.
- The user setting up the integration will require sufficient permissions - usually
  the Admin role - in FireHydrant to be able to set up webhooks to send real-time
  updates about incidents to OpsLevel.
- No HTTP auth headers are required. The webhook UUID is used to authenticate the
  payload.
- Add OpsLevel as a webhook receiver and set it as a route in your alertmanager.yml
- Requires a Project Access Token with read scope
- A two way integration–pull service info directly into Slack using a slash command
  and ensure OpsLevel has accurate team membership and Slack channel info
- A Service Account with Group Viewer permissions is required.
- An API token associated with that Service Account must be created by a Group Admin.
- While we officially support only the latest versions, we have successfully tested
  the integration with multiple releases of both v9.x and v10.x.
- A User Account with 'Administer System' permission is required.
- A User Token associated with that User Account is needed.
- The Organization Key of the SonarQube Cloud organization that you want to pair with
  is required.
- Each time that a StackHawk scan completes, the results will be forwarded to OpsLevel
- Add a webhook connection in Sumo Logic
- 'Specify the service in the connection url with: ?alias=<service_name>'
- Payload checks are deprecated and replaced by Custom Event Checks.
- Some objects like Contact may return nulls in deeply nested fields
- Boost developer productivity by centralizing API Docs for all your services within
  OpsLevel.
- Some API endpoints may require specific headers for access.
- Provision Users, Teams, and Team Hierarchy from GitHub into OpsLevel.
- Learn how checks can be used to evaluate and score your software components.
- Verify that your default branch has protection rules defined.
- Send arbitrary JSON payloads to OpsLevel to evaluate the maturity of your services.
- Automatically verify that relationship criteria are set for your components.
- Verify that the contents of a file in a service's repo satisfy some criteria, such
  as containing a certain string or JSON path.
- Ensure correct OAuth scopes are set
- Some endpoints may require additional permissions.
- Easily export OpsLevel tables to CSV.
- Jump start your action library using OpsLevel Action Templates
- Create a custom integration to write Code Issues or Alert Sources to using OpsLevel's
  API or UI.
- Our Kubernetes integration lets you import and automatically reconcile Kubernetes
  resources in your cluster to OpsLevel services.
- Integrate with Octopus Deploy to notify OpsLevel of any recent deploys for a service.
- Requires setup of Rollbar project and access token
errors:
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- Client errors will return a 200 status with error details in the `errors` field.
- Non-2xx errors only get returned for more serious issues like network failures.
- Non-2xx errors only returned for serious issues; client errors return in the errors
  field.
- '429 - Too Many Requests: Indicates that you are being rate limited'
- '202 Accepted: Successful upload.'
- Other status codes indicate an invalid request.
- 'Value doesn''t satisfy the schema: root value ''Other'' is not one of: Windows,
  macOS, iOS, Android'
- '401 Unauthorized: Recheck API Token or permissions'
- '400 Bad Request: Check your request parameters.'
- '404 Not Found: The requested campaign does not exist.'
- '500 Internal Server Error: An unexpected error occurred.'
- '400: Deployed at Error: param is missing or the value is empty: deployed_at'
- '400 Bad Request: Check request parameters.'
- '401 Unauthorized: Verify authentication credentials.'
- '404 Not Found: Resource does not exist.'
- '404 Not Found: Check the provided identifiers for correctness.'
- '400 Bad Request: Ensure all required fields are included in the request.'
- '400: Invalid JQL'
- '429: Rate limit'
- status_code: 400
  matches: .errorMessages[] | contains("Invalid JQL")
  handler: no_data
- status_code: 429
  handler: rate_limit
- '429: Rate limit exceeded'
- Installation will fail with error(s) if permissions are not granted.
- Occurs when the organization does not have Third-party application via OAuth enabled
  for the Organization access policies.
- Occurs when the Azure DevOps user installing the OpsLevel application does not have
  permissions to Edit or View subscriptions.
- Ensure the account you are signed into has the correct permissions.
- '401 Unauthorized: Recheck token permissions or expiration'
- '403 Forbidden: Check if the required permissions are granted'
- '401 Unauthorized: Check API key and permissions'
- '422: No service found with alias ''invalid_alias''.'
- '422: Check not found with id ''invalid_id''.'
- '422: Expected a top level field named ''data'' but none was found.'
- '400 Bad Request: Check the request parameters and format.'
- '404 Not Found: Ensure the endpoint exists.'
- '401 Unauthorized: Check the validity of the OAuth token'
- '401 Unauthorized: Check your credentials and OAuth scopes'
- '403 Forbidden: Insufficient permissions for this action'
- '404 Not Found: The requested resource does not exist'
- '401 Unauthorized: Check your API key and OAuth token.'
- '404 Not Found: Verify the endpoint path.'
- '401 Unauthorized: Check your access token or permissions'
auth_info:
  mentioned_objects:
  - OauthToken
  - AuthProvider
  - NamedCredential
  - OAuth 2.0 integration
  - Client ID
  - Client Secret
  - Signing Secret
  - Verification Token
  - jira_api_token
  - Application ID
  - Secret
client:
  base_url: https://www.opslevel.com
  auth:
    type: oauth2
    flow: refresh_token
    token_url: https://login.opslevel.com/services/oauth2/token
    client_id: '{{ dlt.secrets[''api_client_id''] }}'
    client_secret: '{{ dlt.secrets[''api_client_secret''] }}'
    refresh_token: '{{ dlt.secrets[''api_refresh_token''] }}'
    location: header
    header_name: Authorization
  headers:
    Accept: application/json
source_metadata: null
