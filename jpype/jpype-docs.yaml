resources:
- name: jvalue
  endpoint:
    path: /jvalue
    method: GET
- name: jclass
  endpoint:
    path: /jclass
    method: GET
- name: jarray
  endpoint:
    path: /jarray
    method: GET
- name: jstring
  endpoint:
    path: /jstring
    method: GET
- name: Type Factories
  endpoint:
    path: /jpype/type_factories
    method: GET
    data_selector: records
    params: {}
- name: Meta Classes
  endpoint:
    path: /jpype/meta_classes
    method: GET
    data_selector: records
    params: {}
- name: Base Classes
  endpoint:
    path: /jpype/base_classes
    method: GET
    data_selector: records
    params: {}
- name: Wrapper Classes
  endpoint:
    path: /jpype/wrapper_classes
    method: GET
    data_selector: records
    params: {}
- name: Object Instances
  endpoint:
    path: /jpype/object_instances
    method: GET
    data_selector: records
    params: {}
- name: Primitive Types
  endpoint:
    path: /jpype/primitive_types
    method: GET
    data_selector: records
    params: {}
- name: Decorators
  endpoint:
    path: /jpype/decorators
    method: GET
    data_selector: records
    params: {}
- name: Mapping Java Syntax to Python
  endpoint:
    path: /jpype/mapping_java_syntax
    method: GET
    data_selector: records
    params: {}
- name: JVM Control Functions
  endpoint:
    path: /jpype/jvm_control
    method: GET
    data_selector: records
    params: {}
- name: java_collection
  endpoint:
    path: /userguide/collections
    method: GET
    data_selector: records
- name: serialization
  endpoint:
    path: /userguide/serialization
    method: GET
    data_selector: records
- name: TestObject
  endpoint:
    path: /MySerializableClass/TestObject
    method: GET
    data_selector: elements
    params: {}
- name: java_serialization
  endpoint:
    path: /serialization
    method: POST
    data_selector: serialized_data
    params: {}
- name: numpy_integration
  endpoint:
    path: /numpy/integration
    method: POST
    data_selector: numpy_data
    params: {}
- name: classpath_configuration
  endpoint:
    path: /userguide/classpath-configuration
    method: GET
    data_selector: content
    params: {}
- name: handling_jar_files
  endpoint:
    path: /userguide/handling-jar-files-compiled-for-newer-java-versions
    method: GET
    data_selector: content
    params: {}
- name: automatic_jvm_path_detection
  endpoint:
    path: /userguide/automatic-jvm-path-detection
    method: GET
    data_selector: content
    params: {}
- name: string_conversions
  endpoint:
    path: /userguide/string-conversions
    method: GET
    data_selector: content
    params: {}
- name: common_issues_and_troubleshooting
  endpoint:
    path: /userguide/common-issues-and-troubleshooting
    method: GET
    data_selector: content
    params: {}
- name: best_practices_for_jvm_starting
  endpoint:
    path: /userguide/best-practices-for-jvm-starting
    method: GET
    data_selector: content
    params: {}
- name: best_practices_for_jvm_shutdown
  endpoint:
    path: /userguide/best-practices-for-jvm-shutdown
    method: GET
    data_selector: content
    params: {}
- name: customization
  endpoint:
    path: /userguide/customization
    method: GET
    data_selector: content
    params: {}
- name: JPype
  endpoint:
    path: /jpype
    method: GET
    data_selector: records
    params: {}
- name: classpath_configuration
  endpoint:
    path: /userguide/classpath-configuration
    method: GET
    data_selector: classpath
- name: handling_jar_files
  endpoint:
    path: /userguide/handling-jar-files-compiled-for-newer-java-versions
    method: GET
    data_selector: jar_files_handling
- name: jvm_path_detection
  endpoint:
    path: /userguide/automatic-jvm-path-detection
    method: GET
    data_selector: jvm_path_detection
- name: shutting_down_jvm
  endpoint:
    path: /userguide/shutting-down-the-jvm
    method: GET
    data_selector: shutting_down
- name: customization
  endpoint:
    path: /userguide/customization
    method: GET
    data_selector: customization
- name: dbapi2
  endpoint:
    path: /latest/userguide.html#database-access-with-jpype-dbapi2
    method: GET
    data_selector: records
    params: {}
- name: database_access
  endpoint:
    path: /userguide#database-access-with-jpype-dbapi2
    method: GET
    data_selector: results
    params: {}
- name: Java Primitives
  endpoint:
    path: /userguide/java-primitives
    method: GET
    data_selector: records
- name: Java Objects and Classes
  endpoint:
    path: /userguide/java-objects-classes
    method: GET
    data_selector: records
- name: Java Array Classes
  endpoint:
    path: /userguide/array-classes
    method: GET
    data_selector: records
- name: array_type
  endpoint:
    path: /userguide/array_type
    method: GET
    data_selector: records
- name: multidimensional_arrays
  endpoint:
    path: /userguide/multidimensional_arrays
    method: GET
    data_selector: records
- name: jagged_arrays
  endpoint:
    path: /userguide/jagged_arrays
    method: GET
    data_selector: records
- name: buffer_classes
  endpoint:
    path: /userguide/buffer_classes
    method: GET
    data_selector: records
- name: boxed_classes
  endpoint:
    path: /userguide/boxed_classes
    method: GET
    data_selector: records
- name: number_class
  endpoint:
    path: /userguide/number_class
    method: GET
    data_selector: records
- name: object_class
  endpoint:
    path: /userguide/object_class
    method: GET
    data_selector: records
- name: string_class
  endpoint:
    path: /userguide/string_class
    method: GET
    data_selector: records
- name: exception_classes
  endpoint:
    path: /userguide/exception_classes
    method: GET
    data_selector: records
- name: anonymous_classes
  endpoint:
    path: /userguide/anonymous_classes
    method: GET
    data_selector: records
- name: lambdas
  endpoint:
    path: /userguide/lambdas
    method: GET
    data_selector: records
- name: inner_classes
  endpoint:
    path: /userguide/inner_classes
    method: GET
    data_selector: records
- name: buffer_transfers
  endpoint:
    path: /userguide/buffer_transfers
    method: GET
    data_selector: records
- name: importing_java_classes
  endpoint:
    path: /userguide/importing_java_classes
    method: GET
    data_selector: records
- name: setupGuiEnvironment
  endpoint:
    path: /setupGuiEnvironment
    method: CALL
    data_selector: None
    params: {}
- name: java_util_Map
  endpoint:
    path: /java/util/Map
    method: GET
    data_selector: records
- name: java_util_List
  endpoint:
    path: /java/util/List
    method: GET
    data_selector: records
- name: java_util_Set
  endpoint:
    path: /java/util/Set
    method: GET
    data_selector: records
- name: java_util_Collection
  endpoint:
    path: /java/util/Collection
    method: GET
    data_selector: records
- name: java_access
  endpoint:
    path: /userguide.html#jpype-the-python-to-java-bridge
    method: GET
    data_selector: content
- name: classpath_configuration
  endpoint:
    path: /userguide/classpath-configuration
    method: GET
    data_selector: classpath
- name: handling_jar_files
  endpoint:
    path: /userguide/handling-jar-files-compiled-for-newer-java-versions
    method: GET
    data_selector: jar_files
- name: automatic_jvm_path_detection
  endpoint:
    path: /userguide/automatic-jvm-path-detection
    method: GET
    data_selector: jvm_path_detection
- name: shutting_down_jvm
  endpoint:
    path: /userguide/shutting-down-the-jvm
    method: GET
    data_selector: shutdown_jvm
notes:
- Java classes outside of a package (in the <default>) cannot be imported.
- Because of lack of JVM support, you cannot shutdown the JVM and then restart it.
- Structural issues prevent managing objects from more than one JVM at a time.
- Some methods rely on the 'current' class/caller. Since calls coming directly from
  python code do not have a current class, these methods do not work.
- JPype caches many resources to the JVM.
- It is not possible to start the JVM after it has been shutdown with the current
  implementation.
- Operating more than one JVM does not appear to be possible under the current implementation.
- Wildcard imports are unreliable and should be avoided.
- Corrected segfault when converting null elements while accessing a slice from a
  Java object array.
- Doc strings are generated for classes and methods.
- Complete rewrite of the core module code to deal unattached threads, improved hardening,
  and member management. Massive number of internal bugs were identified during the
  rewrite and corrected.
- The majority of the front end logic for the toolkit is in Python jpype module.
- The native module is supported by a CPython module called _jpype.
- Series 0.7 is the first version after rewrite for simplification and hardening.
  I consider 0.7 to be at the level of production quality code suitable for most usage
  though still missing some needed features.
- Only one copy of each Java object will appear in the pickle file even it is appears
  multiple times in the data structure.
- JPype requires Python 3.8 or later.
- JPype requires a Java Runtime Environment (JRE) or Java Development Kit (JDK) version
  11 or later.
- JPype is primarily designed to bridge Python with Java.
- JPype can interact with JVM-based languages.
- JPype bridges Python and Java, enabling seamless integration between the two languages.
- 'No JNI Knowledge Required: JPype abstracts away the complexities of the Java Native
  Interface (JNI).'
- 'Python 3 Compatibility: JPype supports only Python 3.'
- JPype provides a bridge to use Java within Python.
- Python and Java share many common concepts, but there are significant differences.
- JPype is a Python module that provides seamless access to Java libraries from Python.
- Uses JPype to integrate Python and Java.
- Java’s nio buffers provide a mechanism for shared memory between Python and Java.
- Consider caching Java objects if used repeatedly in Python.
- Ensure that arrays or collections being transferred are rectangular and compatible
  with expected Java types.
- Starting the JVM correctly is critical for ensuring the smooth operation of JPype-based
  applications.
- Java’s *nio* buffers provide a mechanism for shared memory between Python and Java.
- Ensure that arrays or collections being transferred are rectangular and compatible
  with the expected Java types.
- Java strings are automatically converted to Python strings if convertStrings is
  true.
- JPype supports only Python 3.
- Java's nio buffers provide a mechanism for shared memory between Python and Java.
- Always ensure the JVM version matches the requirements of the JAR files being loaded.
- If possible, use JAR files compiled for long-term support (LTS) versions of Java,
  such as Java 11 or Java 17, to maximize compatibility.
- 'Avoid Manual Shutdown: Whenever possible, allow the JVM to shut down automatically
  when the Python process exits.'
- 'Terminate Threads Properly: Ensure all non-daemon Java threads are terminated or
  marked as daemon before shutting down the JVM.'
- JPype enables integration of Java with Python through JNI.
- Uses OAuth2 with refresh token — requires setup of connected app in api
- Some objects like Contact may return nulls in deeply nested fields
- Java installation is required, supports versions 11 and later.
- Ensure architecture match between Python interpreter and installed JVM.
- Uses customizers to control method and field visibility in Java classes.
- Java objects must implement java.io.Serializable to be serialized.
- Only primitive types are supported for direct transfer between Java and NumPy.
- Designed to provide seamless integration between Python and Java.
- Users do not need to understand JNI concepts or its naming conventions to use JPype
  effectively.
- JPype requires Java version 11 or later.
- Avoid using non-ASCII characters in the JVM path when running JPype on Windows to
  prevent unnecessary file duplication.
- The jpype.beans module is an optional feature that converts Java Bean-style getter
  and setter methods into Python properties.
- JPype enables Python developers to work with Java collections using both Pythonic
  constructs and Java methods.
- JPype abstracts away the complexities of the Java Native Interface (JNI)
- 'Python 3 Compatibility: JPype supports only Python 3'
- By adhering to these best practices, you can maximize the performance, reliability,
  and maintainability of your JPype-based applications.
- JPype requires Java version 11 and later to function properly.
- JPype supports two methods for specifying the classpath.
- Classpath errors can occur if all required JAR files and directories are not included
  in the classpath.
- Ensure the JVM version matches the requirements of the JAR files being loaded.
- JPype allows users to define custom conversion methods that are called whenever
  a specified Python type is passed to a particular Java type.
- JPype allows developers to mix Pythonic constructs and Java methods for maximum
  flexibility.
- JPype supports passing Python functions to Java Functional Interfaces.
- JPype is designed to provide seamless integration between Python and Java, allowing
  developers to use Java libraries and features as naturally as possible within Python.
- JPype can interact with multiple JVM-based languages.
- No JNI knowledge required to use JPype.
- JPype requires the Java Virtual Machine (JVM) to be started before interacting with
  Java.
- 'Java Installation: A Java Runtime Environment (JRE) or Java Development Kit (JDK)
  must be installed. JPype supports Java versions 11 and later.'
- Once enabled, the customization applies globally to all Java classes that have already
  been loaded, as well as any classes loaded afterward.
- Uses Java streams for performance-critical or enterprise applications.
- Ensure objects are serializable when using JPickler.
- Both NumPy and Java arrays must be rectangular for direct transfer.
- Performance may not be as performant as implementing a full Java proxy for high-frequency
  calls
- If an exception occurs within the Python callable, it will be wrapped in a RuntimeException
  when passed back to Java
- Ensure that the Python callable returns a type compatible with the expected Java
  return type
- Proxies can implement multiple interfaces as long as none of those interfaces have
  conflicting methods.
- Sometimes it is useful to implement proxies before the JVM is started.
- JPype requires Python 3.8 or later and a Java Runtime Environment (JRE) or Java
  Development Kit (JDK) version 11 or later.
- Uses Java's nio buffers for shared memory between Python and Java.
- JPype requires Java versions 11 and later.
- The architecture of the Python interpreter must match the architecture of the installed
  JVM.
- JPype allows for customization of Java classes to behave like Python.
- It is important to define customizers early before instances are created.
- Using Python callables may not be as performant as implementing a full Java proxy
  for high-frequency calls.
- JPype allows Java modules to be imported directly into Python.
- The JVM cannot be restarted once it has been shut down.
- Ensure the architecture of Python matches the JVM.
- Classpath must be configured with paths to JAR files or Java classes.
- 'JPype supports two methods for specifying the classpath: classpath argument and
  addClassPath function.'
- The *jpype.beans* module is an optional feature that converts Java Bean-style getter
  and setter methods into Python properties.
- Performance may not be as high as implementing a full Java proxy for high-frequency
  calls.
- If an exception occurs within the Python callable, it will be wrapped in a RuntimeException
  when passed back to Java.
- Methods in the dictionary take precedence over methods in the instance.
- If a method is not found in the dictionary, JPype will attempt to resolve it in
  the instance.
- JPype interacts with JVM-based languages and provides a bridge to use Java within
  Python.
- 'Leverage Java Buffers: Java’s *nio* buffers provide a mechanism for shared memory
  between Python and Java.'
- 'Cache Java Objects: If a Java object is used repeatedly in Python, consider caching
  it to reduce the frequency of cross-language calls.'
- 'Validate Data Structures: Ensure that arrays or collections being transferred are
  rectangular and compatible with the expected Java types.'
- 'Handle Exceptions Properly: Always catch Java exceptions using `jpype.JException`
  or specific Java exception classes.'
- 'Document Your Setup: Document the JVM startup process and configuration settings
  clearly within your codebase.'
- JPype requires Java Runtime Environment (JRE) or Java Development Kit (JDK) installed.
- Supports Java versions 11 and later.
- If non-ASCII characters are unavoidable, ensure sufficient disk space is available
  for temporary files.
- Uses Java's Serializable interface for serialization of Java objects
- Performance may not be as performant as implementing a full Java proxy for high-frequency
  calls.
- Ensure that the Python callable returns a type compatible with the expected Java
  return type.
- JPype is designed to provide seamless integration between Python and Java.
- Ensure the Python interpreter and JVM have matching architectures.
- Uses JNI for integration between Python and Java.
- Python 3 compatibility only.
- Java Runtime Environment (JRE) or Java Development Kit (JDK) must be installed.
  JPype supports Java versions 11 and later.
- Specify the paths to Java classes or JAR files required by your application.
- Ensure that all non-daemon Java threads are terminated or marked as daemon before
  shutting down the JVM.
- JPype beans module is an optional feature that converts Java Bean-style getter and
  setter methods into Python properties.
- Uses Java Streams for filtering and mapping
- JPype enables Python developers to work with Java collections
- JPype provides the jpype.dbapi2 module for database access.
- JPype is intended for Python developers who need to leverage Java libraries or Java
  developers who want to use Python for scripting, debugging, or visualization.
- Always catch Java exceptions using `jpype.JException` or specific Java exception
  classes to ensure robust error handling.
- JPype supports Java versions 11 and later.
- Uses Java proxies to integrate with Python functions
- Performance may be affected when using Python callables instead of Java proxies
- JPype provides the jpype.dbapi2 module for database interaction using JDBC.
- Catch Java exceptions using `jpype.JException` or specific Java exception classes
  to ensure robust error handling.
- Java exceptions occurring within Java code raise a jpype.JException
- JPype optimizes method resolution by caching the results of previous matches
- Once enabled, the customization applies to all Java classes globally. It cannot
  be undone.
- Buffer-backed NumPy arrays provide a powerful mechanism for high-speed data exchange
  between Python and Java.
- JPype's ability to interact with JVM-based languages opens up exciting possibilities
  for Python developers.
- Uses Java’s nio buffers for shared memory between Python and Java.
- Uses Java Streams for complex operations and Pythonic constructs for post-processing
- 'Detach Threads When They End: For thread-heavy applications, ensure that Python
  threads detach themselves from the JVM before they terminate. This prevents resource
  leaks and ensures efficient memory usage.'
- 'Avoid Excessive Attachments: While JPype automatically attaches threads, excessive
  thread creation without proper detachment can lead to resource exhaustion in the
  JVM.'
- 'Detach Early: Detaching threads early, after completing all Java operations, is
  safe and does not interfere with reattachment later. This is especially important
  for applications that spawn many short-lived threads.'
- 'Monitor Resource Usage: Regularly monitor JVM memory usage in thread-heavy applications
  to identify potential leaks caused by lingering thread attachments.'
- setupGuiEnvironment ensures that GUI applications can run correctly across all platforms.
- It is specifically designed to address macOS’s requirement for the main thread to
  run the event loop.
- JPype makes it easy to integrate Python and Java, enabling developers to access
  Java libraries directly from Python code.
- JPype abstracts away the complexities of the Java Native Interface (JNI).
- Leverage Java Buffers for shared memory between Python and Java.
- Ensure arrays or collections being transferred are rectangular and compatible with
  expected Java types.
- JPype automatically detects the path to the JVM shared library using the JAVA_HOME
  environment variable.
- If the automatic detection fails, specify the JVM path manually as the first argument
  to startJVM().
- Set convertStrings=False unless your application explicitly requires automatic conversion.
- Start the JVM at the beginning of your program to avoid issues with imports and
  initialization.
- Use the classpath argument to ensure all required JAR files and directories are
  loaded.
- JPype does not support restarting the JVM after it has been shut down.
- setupGuiEnvironment ensures GUI applications can run correctly across all platforms.
- It supports only Python 3.
- Java Version 11 and later is required.
- Architecture of Python interpreter must match the installed JVM.
- JPype automatically shuts down the JVM when the Python process terminates, ensuring
  a clean exit without manual intervention.
- 'Performance: While using Python callables is convenient, it may not be as performant
  as implementing a full Java proxy for high-frequency calls. Use proxies for performance-critical
  applications.'
- 'Error Handling: If an exception occurs within the Python callable, it will be wrapped
  in a RuntimeException when passed back to Java.'
- 'Type Matching: Ensure that the Python callable returns a type compatible with the
  expected Java return type. Implicit conversions will be applied where possible.'
- JPype allows interaction with JVM-based languages
- Supports Python 3 only
- Uses Java's type system and Python's dynamic typing for interoperability.
- Uses JPype beans for Java Bean-style customization.
- Uses Java proxies to integrate Python with Java.
- Automatic thread attachment to JVM may lead to resource leaks if not properly managed.
- Use `setupGuiEnvironment` for all platforms to ensure consistent behavior.
- Always schedule GUI updates using JavaFX’s `Platform.runLater` or Swing’s `SwingUtilities.invokeLater`.
- JPype provides the jpype.dbapi2 module for database interaction
- Ensure Python version is 3.8 or later and Java version is 11 or later.
- Uses Python to interact with Java APIs
- Automatic thread attachment to JVM
- Ensure the JVM is started with the appropriate classpath for the JDBC driver.
- Requires a running JVM, which may introduce overhead compared to native Python database
  drivers.
- JPype now requires the use of the module API, which was introduced in Java 9.
- The earliest version of Java supported by JPype is Java 11, which is part of the
  Long-Term Support (LTS) release.
- If you need to use Java 8, you must use JPype version 1.5.2 or earlier.
errors:
- 'Caught multiple exceptions : <exception>'
- 'Caught runtime exception : <exception>'
- 'Caught python exception : <exception>'
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- 'java.io.NotSerializableException: if a class is not serializable or one of its
  members'
- 'java.io.InvalidClassException: an error occurs in constructing a serialization.'
- 'java.lang.ClassNotFoundException: if a serialized class is not found by the current
  classloader.'
- 'java.io.StreamCorruptedException: if the pickle file has been altered or corrupted.'
- 'Performance: The remote communication introduces a transfer penalty when moving
  data between Python and Java.'
- 'ImportError: Check if the class or dependency is available.'
- 'AttributeError: Check if the requested attribute exists.'
- 'TypeError: Ensure the method arguments match the expected types.'
- 'java.lang.RuntimeException: Caught the runtime exception'
- 'java.lang.ClassCastException: Caught multiple exceptions'
- 'UnsupportedClassVersionError: Check if JAR file is compiled for a newer version
  of Java than the JVM being used.'
- 'Class file version mismatch: Ensure JVM version matches or exceeds the version
  used to compile the JAR file.'
- 'TypeError: Raised when Java to Python conversion fails.'
- 'MemoryError: Raised when there are issues with memory allocation.'
- JVM cannot be restarted once it has been shut down.
- 'TypeError: No method found matching the provided arguments.'
- 'TypeError: If no method is found that matches the provided arguments.'
- 'UnsupportedClassVersionError: JVM cannot interpret class files compiled for a newer
  version.'
- 'JVM cannot be restarted: Attempting to restart the JVM will result in errors due
  to lingering references and resource conflicts.'
- JVM cannot be restarted after shutdown.
- 'TypeError: No method found that matches the provided arguments.'
- 'UnsupportedClassVersionError: Check that the JAR file is compiled for the same
  or older Java version than the JVM.'
- 'ClassNotFoundException: Ensure that all required JAR files and directories are
  included in the classpath.'
- 'TypeError: Raised when no method matches the provided arguments.'
- 'IndexErrorValueError: Corresponds to java.lang.IndexOutOfBoundsException.'
- 'java.lang.UnsupportedClassVersionError: <class_name> has been compiled by a more
  recent version of the Java Runtime (class file version X)'
- Ensure that all required JAR files and directories are included in the classpath.
- Ensure sufficient memory is allocated to the JVM using the -Xmx option.
auth_info:
  mentioned_objects: []
client:
  base_url: https://jpype.readthedocs.io
  headers:
    Accept: application/json
source_metadata: null
