resources:
- name: usb_boot
  endpoint:
    path: /api/bmc?opt=set&type=usb_boot&node=0
    method: GET
- name: clear_usb_boot
  endpoint:
    path: /api/bmc?opt=set&type=clear_usb_boot&node=0
    method: GET
- name: network
  endpoint:
    path: /api/bmc?opt=set&type=network
    method: GET
- name: node_to_msd
  endpoint:
    path: /api/bmc?opt=set&type=node_to_msd&node=0
    method: GET
- name: power
  endpoint:
    path: /api/bmc?opt=get&type=power
    method: GET
- name: reboot
  endpoint:
    path: /api/bmc?opt=set&type=reboot
    method: GET
- name: reset
  endpoint:
    path: /api/bmc?opt=set&type=reset
    method: GET
- name: sdcard
  endpoint:
    path: /api/bmc?opt=get&type=sdcard
    method: GET
- name: uart
  endpoint:
    path: /api/bmc?opt=get&type=uart
    method: GET
- name: usb
  endpoint:
    path: /api/bmc?opt=get&type=usb
    method: GET
- name: info
  endpoint:
    path: /api/bmc?opt=get&type=info
    method: GET
- name: usb_boot
  endpoint:
    path: /api/bmc?opt=set&type=usb_boot&node=0
    method: GET
- name: clear_usb_boot
  endpoint:
    path: /api/bmc?opt=set&type=clear_usb_boot&node=0
    method: GET
- name: network
  endpoint:
    path: /api/bmc?opt=set&type=network
    method: GET
- name: node_to_msd
  endpoint:
    path: /api/bmc?opt=set&type=node_to_msd&node=0
    method: GET
- name: other
  endpoint:
    path: /api/bmc?opt=get&type=other
    method: GET
- name: power
  endpoint:
    path: /api/bmc?opt=get&type=power
    method: GET
- name: reboot
  endpoint:
    path: /api/bmc?opt=set&type=reboot
    method: GET
- name: reload
  endpoint:
    path: /api/bmc?opt=set&type=reload
    method: GET
- name: reset
  endpoint:
    path: /api/bmc?opt=set&type=reset
    method: GET
- name: sdcard
  endpoint:
    path: /api/bmc?opt=get&type=sdcard
    method: GET
- name: uart
  endpoint:
    path: /api/bmc?opt=get&type=uart
    method: GET
- name: usb
  endpoint:
    path: /api/bmc?opt=get&type=usb
    method: GET
- name: info
  endpoint:
    path: /api/bmc?opt=get&type=info
    method: GET
- name: about
  endpoint:
    path: /api/bmc?opt=get&type=about
    method: GET
    data_selector: ''
    params: {}
- name: flash
  endpoint:
    path: /api/bmc/flash
    method: POST
    data_selector: ''
    params:
      length: ''
      local: ''
- name: about
  endpoint:
    path: /api/bmc?opt=get&type=about
    method: GET
    data_selector: api
    params: {}
- name: flash
  endpoint:
    path: /api/bmc/flash
    method: POST
    data_selector: handle
    params: {}
- name: compute_modules
  endpoint:
    path: /docs/turing-pi2-supported-compute-modules
    method: GET
    data_selector: modules
- name: compute_modules
  endpoint:
    path: /docs/turing-pi2-supported-compute-modules
    method: GET
    data_selector: modules
    params: {}
- name: user_storage
  endpoint:
    path: /user/storage
    method: GET
    data_selector: storage
- name: network_interfaces
  endpoint:
    path: /network/interfaces
    method: GET
    data_selector: interfaces
- name: power_control
  endpoint:
    path: /power/control
    method: POST
    data_selector: power_status
- name: usb_switch
  endpoint:
    path: /usb/switch
    method: POST
    data_selector: usb_status
- name: firmware_upgrade
  endpoint:
    path: /firmware/upgrade
    method: POST
    data_selector: upgrade_status
- name: flash_node
  endpoint:
    path: /flash/node
    method: POST
    data_selector: flash_status
- name: user_storage
  endpoint:
    path: /user/storage
    method: GET
    data_selector: storage
    params: {}
- name: network_interfaces
  endpoint:
    path: /network/interfaces
    method: GET
    data_selector: interfaces
    params: {}
- name: power_control
  endpoint:
    path: /power/control
    method: POST
    data_selector: power
    params: {}
- name: usb_switch
  endpoint:
    path: /usb/switch
    method: POST
    data_selector: usb
    params: {}
- name: firmware_upgrade
  endpoint:
    path: /firmware/upgrade
    method: POST
    data_selector: upgrade
    params: {}
- name: flash_node
  endpoint:
    path: /flash/node
    method: POST
    data_selector: flash
    params: {}
- name: firmware_upgrade
  endpoint:
    path: /docs/turing-pi2-bmc-firmware-upgrade
    method: GET
    data_selector: firmware_upgrade_links
    params: {}
- name: v1_to_v2_upgrade
  endpoint:
    path: /docs/turing-pi2-bmc-v1x-to-v2x
    method: GET
    data_selector: upgrade_instructions
    params: {}
- name: Upgrade v2.x firmware to v2.x firmware
  endpoint:
    path: /docs/turing-pi2-bmc-v2x-to-v2x
    method: GET
- name: Upgrade v1.x firmware to v2.x firmware
  endpoint:
    path: /docs/turing-pi2-bmc-v1x-to-v2x
    method: GET
- name: Upgrade v1.x firmware to v2.x firmware without physical access to the SD card
  endpoint:
    path: /docs/turing-pi2-bmc-v1x-to-v2x#upgrading-the-firmware-without-sd-card-access
    method: GET
- name: Run firmware from the SD card (without flashing the BMC)
  endpoint:
    path: /docs/turing-pi2-bmc-run-from-sd
    method: GET
- name: Upgrade firmware that runs from the SD card
  endpoint:
    path: /docs/turing-pi2-bmc-run-from-sd#ota-update
    method: GET
- name: SD Card
  endpoint:
    path: /docs/turing-pi2-bmc-run-from-sd
    method: GET
    data_selector: instructions
    params: {}
- name: sd_card
  endpoint:
    path: /mnt/sdcard
    method: GET
- name: serial_console
  endpoint:
    path: /serial_console
    method: GET
    data_selector: console_output
- name: ssh_access
  endpoint:
    path: /ssh_access
    method: GET
    data_selector: ssh_info
- name: sd_card_compatibility
  endpoint:
    path: /mnt/sdcard
    method: GET
    data_selector: file_systems
    params: {}
- name: msd_access
  endpoint:
    path: /advanced/msd
    method: POST
    data_selector: null
    params:
      node: 1
- name: heatsink_kit
  endpoint:
    path: /mounting-heatsink
    method: GET
    data_selector: instructions
    params: {}
- name: flashing_os
  endpoint:
    path: /docs/turing-rk1-flashing-os
    method: GET
    data_selector: content
    params: {}
- name: ISO Image
  endpoint:
    path: /releases.ubuntu.com/focal/ubuntu-20.04.6-desktop-amd64.iso
    method: GET
- name: installation_iso
  endpoint:
    path: /releases.ubuntu.com/focal/ubuntu-20.04.6-desktop-amd64.iso
    method: GET
    data_selector: ISO Image
    params: {}
- name: bare_metal_installation
  endpoint:
    path: /docs/turing-pi2-hardware-installation
    method: GET
    data_selector: Bare-metal installation
    params: {}
- name: vmware_player_installation
  endpoint:
    path: /docs/nvidia-jetson-orin-nx-vmware-player-installation-and-preparation
    method: GET
    data_selector: Virtual Machine using VMWare Player
    params: {}
- name: Official heatsink
  endpoint:
    path: /docs/nvidia-jteson-orin-nxnano-cooling
    method: GET
    data_selector: records
- name: Xavier NX heatsink
  endpoint:
    path: /docs/nvidia-jteson-orin-nxnano-cooling
    method: GET
    data_selector: records
- name: Flashing Instructions
  endpoint:
    path: /docs/orin-nxnano-flashing-os
    method: GET
    data_selector: content
- name: USB_Controller
  endpoint:
    path: /docs/nvidia-jetson-orin-nxnano-peripherals
    method: GET
    data_selector: controller_details
    params: {}
- name: official_heatsink
  endpoint:
    path: /docs/nvidia-jteson-orin-nxnano-cooling
    method: GET
    data_selector: heatsink_info
    params: {}
- name: xavier_nx_heatsink
  endpoint:
    path: /docs/nvidia-jteson-orin-nxnano-cooling
    method: GET
    data_selector: xavier_nx_heatsink_info
    params: {}
- name: specifications
  endpoint:
    path: /docs/raspberry-pi-cm4-intro-specs
    method: GET
    data_selector: specifications
    params: {}
- name: CM4 Adapter
  endpoint:
    path: /product/cm4-adapter/
    method: GET
- name: CM4 Adapter
  endpoint:
    path: /product/cm4-adapter/
    method: GET
    data_selector: module_details
    params: {}
- name: dietpi_config
  endpoint:
    path: /config/dietpi.txt
    method: GET
    data_selector: records
    params: {}
- name: cmdline_config
  endpoint:
    path: /config/cmdline.txt
    method: GET
    data_selector: records
    params: {}
- name: dietpi_configuration
  endpoint:
    path: /dietpi/config
    method: POST
    data_selector: configuration
    params: {}
- name: master_node_initialization
  endpoint:
    path: /
    method: GET
    data_selector: ''
    params:
      write-kubeconfig-mode: '644'
      disable:
      - servicelb
      - cloud-controller
      - local-storage
      token: myrandompassword
      node-ip: 10.0.0.60
- name: worker_nodes_addition
  endpoint:
    path: /
    method: GET
    data_selector: ''
    params:
      K3S_URL: https://10.0.0.60:6443
      K3S_TOKEN: myrandompassword
- name: node_labeling
  endpoint:
    path: /
    method: GET
    data_selector: ''
    params:
      label: kubernetes.io/role=worker
- name: nodes
  endpoint:
    path: /kubectl/get/nodes
    method: GET
    data_selector: nodes
    params: {}
- name: MetalLB
  endpoint:
    path: /metallb
    method: POST
    data_selector: ipAddressPool
    params: {}
- name: Traefik
  endpoint:
    path: /traefik
    method: GET
    data_selector: routes
    params: {}
- name: MetalLB
  endpoint:
    path: /metallb
    method: GET
    data_selector: ipAddressPools
    params: {}
- name: Traefik
  endpoint:
    path: /traefik
    method: GET
    data_selector: routes
    params: {}
- name: NFS_setup
  endpoint:
    path: /data
    method: POST
    data_selector: export
    params: {}
- name: nfs-client
  endpoint:
    path: /storageclass
    method: GET
    data_selector: storageClasses
    params: {}
- name: nfs_setup
  endpoint:
    path: /docs/turing-pi2-kubernetes-cluster-storage
    method: GET
    data_selector: storage_setup
    params: {}
- name: nfs_storage
  endpoint:
    path: /nfs/storage
    method: POST
    data_selector: storageDetails
    params: {}
- name: longhorn_storage
  endpoint:
    path: /longhorn/storage
    method: POST
    data_selector: storageDetails
    params: {}
- name: nfs-client
  endpoint:
    path: /deploy/test-claim.yaml
    method: CREATE
    data_selector: spec
    params: {}
- name: test-pod
  endpoint:
    path: /deploy/test-pod.yaml
    method: CREATE
    data_selector: spec
    params: {}
- name: error-pages
  endpoint:
    path: /api/applications/error-pages
    method: POST
    data_selector: application
    params: {}
- name: nfs_provider
  endpoint:
    path: /services/data/vXX.X/nfs_provider
    method: POST
    data_selector: status
    params: {}
- name: longhorn
  endpoint:
    path: /services/data/vXX.X/longhorn
    method: POST
    data_selector: status
    params: {}
- name: redis_pvc
  endpoint:
    path: /pvc
    method: POST
    data_selector: metadata.name
    params: {}
- name: redis_server
  endpoint:
    path: /deployment
    method: POST
    data_selector: metadata.name
    params: {}
- name: redis_service
  endpoint:
    path: /service
    method: POST
    data_selector: metadata.name
    params: {}
- name: error-pages
  endpoint:
    path: /gitlab.com/vstrycek/turingpi-error-pages
    method: GET
    data_selector: application
    params: {}
- name: nvidia-query
  endpoint:
    path: /nvidia-query
    method: POST
    data_selector: results
    params: {}
- name: pvc
  endpoint:
    path: /pvc.yaml
    method: POST
    data_selector: status
    params: {}
- name: deployment
  endpoint:
    path: /deployment.yaml
    method: POST
    data_selector: status
    params: {}
- name: service
  endpoint:
    path: /service.yaml
    method: POST
    data_selector: status
    params: {}
- name: nvidia-query
  endpoint:
    path: /v1/nvidia-query
    method: POST
    data_selector: status
    params: {}
- name: Docker Compose
  endpoint:
    path: /dietpi.txt
    method: POST
    data_selector: null
    params:
      AUTO_SETUP_INSTALL_SOFTWARE_ID: 134
- name: Docker
  endpoint:
    path: /dietpi.txt
    method: POST
    data_selector: null
    params:
      AUTO_SETUP_INSTALL_SOFTWARE_ID: 162
- name: Git
  endpoint:
    path: /dietpi.txt
    method: POST
    data_selector: null
    params:
      AUTO_SETUP_INSTALL_SOFTWARE_ID: 17
- name: Keepalived
  endpoint:
    path: /keepalived
    method: GET
    data_selector: records
- name: GlusterFS
  endpoint:
    path: /glusterfs
    method: GET
    data_selector: records
- name: software_installation
  endpoint:
    path: /dietpi.txt
    method: POST
    data_selector: AUTO_SETUP_INSTALL_SOFTWARE_ID
    params: {}
- name: keepalived_configuration
  endpoint:
    path: /etc/keepalived/keepalived.conf
    method: POST
    data_selector: configuration
    params: {}
- name: docker_swarm
  endpoint:
    path: /docker/swarm
    method: POST
    data_selector: swarm_info
- name: dockervol1
  endpoint:
    path: /data/glusterfs/myvol1/brick1
    method: CREATE
    data_selector: volume
    params: {}
- name: dockervol2
  endpoint:
    path: /data/glusterfs/myvol1/brick2
    method: CREATE
    data_selector: volume
    params:
      redundancy: 1
      disperse: true
- name: keepalived_configuration
  endpoint:
    path: /etc/keepalived/keepalived.conf
    method: GET
    data_selector: configuration
    params: {}
- name: power_all_nodes
  endpoint:
    path: /api/bmc
    method: POST
    data_selector: null
    params:
      opt: set
      type: power
      node1: '1'
- name: change_usb_mode
  endpoint:
    path: /api/bmc
    method: POST
    data_selector: null
    params:
      opt: set
      type: host
      node: '3'
- name: dockervol1
  endpoint:
    path: /data/glusterfs/myvol1/brick1
    method: CREATE
    data_selector: success
- name: dockervol2
  endpoint:
    path: /data/glusterfs/myvol1/brick2
    method: CREATE
    data_selector: success
- name: compute_modules
  endpoint:
    path: /docs/turing-pi1-compute-modules
    method: GET
    data_selector: modules
    params: {}
- name: power_management
  endpoint:
    path: /docs/turing-pi1-power-supply
    method: GET
    data_selector: power
    params: {}
- name: portainer_agent
  endpoint:
    path: /docker/service/ls
    method: GET
    data_selector: services
    params: {}
- name: portainer_portainer
  endpoint:
    path: /docker/service/ls
    method: GET
    data_selector: services
    params: {}
- name: power_adaptor
  endpoint:
    path: /docs/turing-pi1-power-supply
    method: GET
    data_selector: power_adaptor_details
- name: atx_power_supply
  endpoint:
    path: /docs/turing-pi1-power-supply
    method: GET
    data_selector: atx_power_supply_details
- name: compute_modules
  endpoint:
    path: /docs/turing-pi1-compute-modules
    method: GET
    data_selector: records
- name: cluster_management_bus
  endpoint:
    path: /api/v1/cluster_management_bus
    method: GET
    data_selector: data
    params: {}
- name: power_adaptor
  endpoint:
    path: /power/adaptor
    method: GET
    data_selector: power_info
    params: {}
- name: atx_power_supply
  endpoint:
    path: /atx/power/supply
    method: GET
    data_selector: power_info
    params: {}
- name: compute_modules
  endpoint:
    path: /compute/modules
    method: GET
    data_selector: modules
    params: {}
- name: I2C expander
  endpoint:
    path: /i2c/expander
    method: GET
    data_selector: registers
    params:
      address: '0x57'
- name: Ethernet Switch
  endpoint:
    path: /i2c/switch
    method: GET
    data_selector: registers
    params:
      address: '0x5C'
- name: I2C expander
  endpoint:
    path: /i2c/expander
    method: GET
    data_selector: devices
    params: {}
- name: Real-Time Clock/Calendar
  endpoint:
    path: /rtc
    method: GET
    data_selector: time_date
    params: {}
- name: Ethernet Switch
  endpoint:
    path: /ethernet/switch
    method: GET
    data_selector: switch_status
    params: {}
- name: I2C expander
  endpoint:
    path: /i2c/expander
    method: GET
    data_selector: registers
    params: {}
- name: Ethernet Switch
  endpoint:
    path: /i2c/switch
    method: GET
    data_selector: status
    params: {}
- name: I2C expander
  endpoint:
    path: /i2c/expander
    method: GET
    data_selector: registers
    params: {}
- name: Real-Time Clock/Calendar
  endpoint:
    path: /rtc
    method: GET
    data_selector: time_date
    params: {}
- name: Ethernet Switch
  endpoint:
    path: /ethernet/switch
    method: GET
    data_selector: status
    params: {}
- name: mini_itx_case
  endpoint:
    path: /docs/turing-pi1-mini-itx-case
    method: GET
    data_selector: content
    params: {}
- name: i2c_tools
  endpoint:
    path: /docs/turing-pi1-cluster-management-bus-i2c
    method: GET
    data_selector: commands
    params: {}
- name: I2C expander
  endpoint:
    path: /i2c/expander
    method: GET
    data_selector: data
    params: {}
- name: Ethernet Switch
  endpoint:
    path: /i2c/switch
    method: GET
    data_selector: data
    params: {}
- name: Real-Time Clock/Calendar
  endpoint:
    path: /i2c/rtc
    method: GET
    data_selector: data
    params: {}
- name: open-source case files
  endpoint:
    path: https://github.com/turing-machines/mini-itx-case
    method: GET
- name: 3D sources
  endpoint:
    path: https://www.thingiverse.com/thing:4858278
    method: GET
- name: firmware
  endpoint:
    path: /api/v1/firmware
    method: GET
    data_selector: records
- name: nodes
  endpoint:
    path: /api/nodes
    method: GET
    data_selector: data
    params: {}
- name: status
  endpoint:
    path: /api/status
    method: GET
    data_selector: status
    params: {}
notes:
- Turing Pi 2 board is designed for multi-node computing clusters and includes a built-in
  BMC for node management.
- This innovative board is designed to provide a powerful platform for building not
  only multi-node computing clusters, but also as an excellent tool for learning Kubernetes,
  automation, edge AI computing, home labs and many more.
- The Turing Pi 2 board offers an unprecedented level of flexibility and scalability.
- Integrated power management and networking.
- Built-in BMC (Baseboard Management Controller) for managing and automating nodes.
- Uses GPIO 40-pin for various connections
- BMC reset button available for hard reset
- Although it's possible to achieve fan-less operation, we highly recommend at least
  one FAN in your case.
- All supported compute modules will work without an attached heat sink, but this
  is not recommended, and you will most certainly hit thermal throttling and performance
  issues.
- If you are going to use a standard PC case or 3D printed case with fan over the
  compute modules, passive heat sinks should be enough.
- You can insert and remove (hot-swap) the modules without turning off (disconnecting
  power from) the whole Turing Pi2 board.
- Modules can be hot-swapped without powering off the whole board.
- Modules should be inserted with the node power off.
- Pico PSU 24-pin ATX adapter also requires 12V external power supply with a 2.5-5.5mm
  connector
- The first boot can take up to 2 minutes as SSH and TLS keys are being generated
- Power up the 24-Pin socket by connecting a power source or turning on the ATX PSU
  switch. The BMC will start independently, which usually takes 10 to 20 seconds.
- All software related to the Turing-Pi is open source.
- The BMC does not use a unique domain name for certificates; it uses a self-signed
  certificate.
- The default login is root with password turing.
- Only raw .img files can be written to nodes.
- Firmware in version 2.x overhauls the flashing method and how the images are built.
- It's strongly recommended not to return to the firmware v1.x from v2.x without a
  very good cause.
- You always find the newest firmware version on https://firmware.turingpi.com/turing-pi2/
- This process of upgrading from firmware v1 to v2 will remove any custom files and
  settings and perform a clean install
- This process is also applicable if the BMC chip does not boot anymore or there is
  a need to completely re-flash the firmware
- This page is specifically targeted for users that are running v2.0, made changed
  to the /etc/network/interfaces file and want to install firmware version 2.1.x.
- During the update to v2.1 an attempt is made to upgrade the interfaces file.
- The original interfaces file will be renamed to interfaces_bak and can be put back
  in the event of errors.
- During the update to v2.1 an attempt is made to upgrade the interfaces file. It
  will update definitions and aliases from eth0 to the appropriate new bridge interface.
- No official OTA support for this method of running the BMC firmware
- At any point, you can rename the file back and the firmware will flash onto the
  BMC with all the changes made to the SD card image
- Failsafe mode preserves user files and does not permanently change any files created
  by the user.
- In safe mode, the user partition is mounted to an arbitrary directory.
- You can rename the file back to flash the firmware onto the BMC
- The BMC UI uses self-signed certificates.
- Failsafe will never remove or permanently change any files that the user created.
- SSH is notorious because of the numerous attacks that are attempted on it. If your
  system is reachable outside your local network, we recommend you take extra measures
  to protect your BMC.
- Replacing the self-signed certificates with one trusted by a CA improves the system's
  security.
- Root login is enabled by default and exposed over the default SSH port.
- SSH access as root is not allowed in older versions of the BMC Firmware.
- The Turing Pi 2 board includes an SD card slot located on its back.
- This slot is directly linked to the Board Management Controller (BMC).
- 'When using an SD card, it''s important to know the compatible file systems: exFAT,
  NTFS, FAT32, EXT4.'
- Root login is enabled by default for SSH.
- Additional security measures are recommended if SSH port is reachable from outside
  the local network.
- Starting with version 2.0.0 of the firmware, only authenticated users can issue
  commands on the BMC.
- An authentication token is stored to a file so that you would not need to enter
  them again. This token is valid for a configurable amount of time, by default 3
  hours.
- The preferred file system for Windows is exFAT.
- NTFS requires safe ejection on Windows to prevent read-only mode on Linux systems.
- FAT32 has limitations and should be avoided.
- EXT4 is also compatible.
- UART is disabled by default in Raspberry Pi OS
- The non-interactive usage with the tpi command can be performed interactively with
  picocom which comes pre-installed on the BMC
- With tpi it's possible to access filesystems of nodes by booting them as a Mass
  Storage Device (MSD)
- Compatible with multiple operating systems
- Supports various video input and output formats
- The heatsink kit for the RK1 module consists of a heatsink and 2 thermal pads -
  one for the RK3588 (SoM) chip and one for the RK806 (power management) chip.
- Uses BMC for flashing firmware, but can also use USB cable
- Flashing through BMC takes about 8 minutes for each 1 GB of the image file
- Flashing the Server image will take approximately 60 minutes, and flashing of Desktop
  image approximately 90 minutes
- There is a known issue when the progress bar during flashing will reach 100% after
  approximately 2.5 minutes
- USB ports on Jetson Carrier boards are not supported in Ubuntu images yet - run
  `sudo apt update` followed by `sudo apt -y upgrade` and reboot to have USB working
- DSI connector is not supported in Ubuntu builds yet - will be added later
- EDID (monitor resolution detection) does not work on the Turing Pi 2 v2.4 board
  correctly offering 1080p by default for all monitors - we're investigating this
- If you received your RK1 module before the official announcement (from the pool
  of initial 100 modules), HDMI might not work with some monitors while using a Jetson
  carrier board (and other Jetson-compatible carrier boards), however, HDMI will work
  on Turing Pi 2 board (can be fixed by adding 2 solder bridges)
- Uses BMC for flashing which takes about 60 minutes for Server image and 90 minutes
  for Desktop image
- Known issues with USB ports on Jetson Carrier boards in Ubuntu images
- Flashing through the BMC takes about 8 minutes for each 1 GB of the image file,
  plus an additional minute at the end for verification. Currently, flashing the Server
  image will take approximately 60 minutes, and flashing of Desktop image approximately
  90 minutes.
- There is a known issue when the progress bar during flashing will reach 100% after
  approximately 2.5 minutes. This won't affect the flashing process, just the progress
  bar will not be updated correctly
- Flashing using USB on the Turing Pi 2 v2.4 board might not work in Node 1 on some
  of the boards. If you are experiencing this issue, move the module temporarily to
  another node, flash, and then move back.
- For the `Server` image version, the default login is `ubuntu` and the default password
  `ubuntu` (you'll be prompted to change password on first login). The `Desktop` version
  asks you to create the account during finishing setup.
- Double check if you are choosing the right disk
- If install bfloat16 failed, please install numpy manually first. 'pip install numpy==1.17.3'
- The system needs Ubuntu 18.04 (x64) or later.
- 'Python version: 3.6/3.8'
- To be able to flash the Orin modules, you need Ubuntu 20.04 LTS operating system.
- It is recommended to set the USB to connect to the virtual machine by default.
- The SDK Manager does not support flashing of the Orin modules in the third-party
  boards (like Turing Pi 2), and most likely will never do, so we have to flash them
  by hand.
- Turing Pi 2 (similar to some other custom carrier boards) does not have the onboard
  EEPROM that the module or the flasher can access.
- Jetson modules cannot put their USB controller into host mode, this function only
  works on the Raspberry Pi Compute Module 4s.
- Any controller based on Renesas D720201 or Renesas D720202 should work out of the
  box.
- Uses Nvidia JetPack for installation of software
- Installation of TensorFlow and PyTorch is required for machine learning
- Default fan profile is 'quiet', can be changed to 'cool'.
- The flashing method does not provide Jetpack.
- Make sure you use Ubuntu 18 or you will have compatibility issues and may not be
  able to flash your device.
- Raspberry Pi Compute Module 4 requires a CM4 Adapter board to fit into the 260-pin
  DDR4 slot.
- Ensure the modules are firmly secured to the adapter board in edge computing applications.
- Do not use either SD card and eMMC during installation, remove the SD card temporarily
  when installing to eMMC.
- Some users have reported issues with USB-A to USB-C connections.
- We have seen some reports from users where USB-A to USB-C was not working correctly.
  If you face issues, please use preferred method USB-A to USB-A.
- If the node does not boot, try to remedy this by setting the node back to USB host
  mode.
- In the case of a home network, your router's DHCP might show the IP for the host
  'raspberrypi'.
- With the node booted, you should be able to find its IP. In the case of a home network,
  your router's DHCP might show the IP for the host 'raspberrypi'.
- Ensure to adjust the network settings to match your network's configuration.
- Longhorn needs at least three nodes with hard drives to set up a storage pool.
- Using the Raspberry Pi's SD card isn't recommended (though possible).
- AUTO_SETUP_TIMEZONE should be set to your timezone.
- AUTO_SETUP_NET_STATIC_IP, AUTO_SETUP_NET_STATIC_MASK, and AUTO_SETUP_NET_STATIC_GATEWAY
  should reflect your network settings.
- AUTO_SETUP_NET_HOSTNAME should be a unique hostname for each node.
- AUTO_SETUP_GLOBAL_PASSWORD is your initial root password.
- K3s is a lightweight Kubernetes distribution that demands lesser resources.
- Labeling nodes is recommended to represent the 'worker' role.
- Execute the commands on your Master node only.
- Helm is a Kubernetes package manager that streamlines the management and distribution
  of applications.
- Arkade is a one-liner tool that simplifies the installation of Kubernetes applications
  on any cluster.
- MetalLB should be installed only on your main control node.
- For local testing, the /etc/hosts file can be modified to act as a faux DNS server.
- To utilize Traefik, a working DNS server external to the Kubernetes cluster is required.
- Do not hot-plug the disk.
- Requires setup of NFS server on Node3.
- Uses NFS as a storage option in Kubernetes
- Node3 must be shut down before connecting a disk to avoid hot-plugging issues.
- Make sure to format and mount the disk before exporting it.
- Ensure to not hot-plug the disk when setting up NFS.
- Longhorn provides high availability and easy data management.
- Uses Helm to install the nfs-subdir-external-provisioner.
- Ensure NFS server is configured properly before installation.
- Longhorn is probably the most lightweight option for distributed file system.
- Its setup is not difficult, but it does require more hardware than option 1.
- Create the folder /storage on all nodes, even when there is no disk mounted to it,
  to avoid issues during installation.
- ArgoCD does not require persistent storage and supports Arm64 architecture out of
  the box.
- Admin password is auto-generated and can be retrieved using kubectl command.
- NFS setup requires formatting and mounting disks before use.
- Longhorn installation can take up to 10 minutes.
- Longhorn provides several benefits in a Kubernetes environment
- Longhorn is designed to use the underlying operating system's file system, rather
  than RAW devices
- Uses MetalLB for LoadBalancer IP allocation
- Persistent storage defined using Longhorn storage class
- Uses Nvidia's JetPack OS for installation.
- Installing the full SDK and JetPack can consume a significant amount of storage
  space.
- Registered device plugin for 'nvidia.com/gpu' with Kubelet.
- Uses DietPi for ease of setup.
- SD cards are not suitable for heavy writing and reading environments.
- Uses Nvidia's JetPack OS for installation — cannot use DietPi.
- The process for setting up the operating system for Docker Swarm is similar to the
  process of setting up the operating system for a Kubernetes cluster.
- When configuring software to install in the dietpi.txt file, it is important to
  include the following line among the lines that begin with 'AUTO_SETUP_INSTALL_SOFTWARE_ID'.
- Uses DietPi for OS setup, providing ease of configuration.
- GlusterFS is recommended for persistent storage in Docker Swarm.
- During our testing, we had issue exporting ports. Seems like the overlay ingress
  network that is automatically created was in the same range as the nodes.
- Keepalived enables the use of a single, shared virtual IP to access services on
  Docker Swarm.
- By default, GlusterFS server allows mounting volume to everybody, limit it to specific
  IPs.
- Keepalived enables using a single shared virtual IP for Docker Swarm services.
- It is important to note that during the installation process, we encountered a failure
  due to the missing folder /var/lib/docker/volumes.
- To ensure that the data stored by Portainer remains persistent, we can leverage
  the GlusterFS that has been deployed and mounted on all of our nodes at the location
  /mnt/docker-storage.
- 'Order of Execution: Change USB settings before powering on nodes.'
- GlusterFS volumes can be created from multiple bricks across nodes.
- You can use either eMMC or SD card storage. You can't use both options.
- To power the Turing Pi V1 board you can use two options - power adaptor and ATX
  power supply.
- The USB lanes of the Mini PCI-Express for both NODE 1 and NODE 2 are multiplexed
  with the USB-OTG port. Therefore, when a USB setting is active for either NODE 1
  or NODE 2, any USB devices connected via the Mini PCI-Express will be hidden.
- On a cold boot of the Turing Pi 2, the default setting is HOST MODE for NODE 1,
  which will render any Mini PCI-Express modules connected to NODE 1 that use USB
  unavailable.
- 'Order of Execution: If you create a script that changes the USB-OTG settings and
  powers on one or more nodes, ensure that you alter the USB settings before powering
  on the affected nodes. This sequence of operations is crucial for the proper functioning
  of your nodes.'
- The onboard Ethernet switch might get too hot when you run the Turing Pi cluster.
  To avoid any issues we recommend cooling the switch chip using a heatsink.
- 'Power: 12V, 5A, 60W'
- 'Connector: 2.1-5.5mm (center positive)'
- If your computer doesn't see the compute module, or you getting errors when trying
  to write an OS on it, please try other USB cables. Some USB cables may not supply
  enough power to transfer data onto USB mass storage devices. Also, always plug a
  USB cable directly into your computer.
- We recommend using Hypriot OS and setup each node with SSH enabled Docker container,
  instead of connecting a keyboard and a mouse to USB ports.
- As a security precaution, system devices are not exposed by default inside Docker
  containers.
- If your computer doesn't see the compute module, or you getting errors when trying
  to write an OS on it, please try other USB cables.
- System devices are not exposed by default inside Docker containers.
- Ensure I2C interface is enabled in sudo raspi-config.
- Uses I2C for communication with devices
- System devices are not exposed by default inside Docker containers
- Requires setup of OAuth2 authentication.
- Requires API key management for access
errors:
- 'Invalid certificate: Proceed with self-signed certificate warning.'
- 'Invalid certificate: Proceed with self-signed certificate.'
- Network reset takes around 5 seconds.
- If the flashing fails for any reason, the LEDs will start blinking the 'SOS code'
- Interrupting the upgrade process (e.g. due to a power failure or error during flashing)
  is not 'dangerous' but will result in a non-bootable BMC until installation is reattempted
  and completes successfully
- 'SSH_CONNECTION_TIMEOUT: Check network settings.'
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- If you are using VMWare Player and if the VMWare Player has been installed earlier,
  it might remember some USB settings and not connect devices automatically.
- The same message can appear if you did not set the USB mode on the Turing Pi 2 to
  'device' for the given node mode.
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- The latest BMC release is not able to receive big files (>50mb), rendering this
  command rather unuseful.
- 'NFS_SERVER_NOT_RUNNING: Ensure the NFS server is enabled and started.'
- 'EXPORTS_NOT_FOUND: Check the /etc/exports file for correct export entries.'
- 'NFS_SERVER_NOT_FOUND: Ensure NFS server IP is correct.'
- 'LONGHORN_INSTALLATION_FAILED: Check Helm installation logs for details.'
- 'Failed to create Persistent Volume Claim: Check if the NFS server is reachable.'
- 'NFS server not responding: Ensure NFS server is running and configured correctly.'
- '401 Unauthorized: Recheck admin credentials or permissions'
- 'INSTALLATION_FAILED: Check disk availability and configurations.'
- 'PVC_CREATION_FAILED: Ensure proper access modes and storage class.'
- '401 Unauthorized: Check admin password'
- 'Not enough space: Consider using an M.2 SSD and mounting it to ''/containerd''.'
- 'Unable to negotiate virtual IP: Check keepalived configuration or network settings.'
- 'volume create: dockervol1: success: please start the volume to access data'
- 'volume start: dockervol1: success'
- 'To remove the Portainer stack, you can use command: docker stack rm portainer'
- 'Invalid device access: Ensure the device address is correct.'
- 'Permission denied: Check if the device is exposed to the container.'
- '401 Unauthorized: Check client credentials and token validity.'
- '403 Forbidden: Check API key permissions'
- '404 Not Found: Verify endpoint existence'
- '500 Internal Server Error: Retry request'
auth_info:
  mentioned_objects: []
client:
  base_url: https://turingpi.com
source_metadata: null
