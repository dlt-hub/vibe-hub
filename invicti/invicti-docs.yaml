resources:
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: scans
  endpoint:
    path: /scans/list
    method: GET
- name: account
  endpoint:
    path: /account/me
    method: GET
- name: api_security
  endpoint:
    path: /product/api-security
    method: GET
    data_selector: records
- name: API Security
  endpoint:
    path: /product/api-security
    method: GET
- name: DAST
  endpoint:
    path: /product/dast
    method: GET
- name: SAST
  endpoint:
    path: /product/sast
    method: GET
- name: SCA
  endpoint:
    path: /product/sca
    method: GET
- name: Container Security
  endpoint:
    path: /product/container-security
    method: GET
- name: ASPM
  endpoint:
    path: /product/application-security-posture-management-aspm
    method: GET
- name: ServiceNow Application Vulnerability Response
  endpoint:
    path: /support/api-overview/
    method: GET
- name: ServiceNow Vulnerability Response
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow-vulnerability-response/
    method: GET
- name: ServiceNow Application Vulnerability Response
  endpoint:
    path: /support/api-overview/
    method: GET
- name: ServiceNow Vulnerability Response
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow-vulnerability-response/
    method: GET
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_application_scanning
  endpoint:
    path: /services/data/vXX.X/sobjects/WebApplicationScan
    method: GET
    data_selector: records
    params: {}
- name: api_scanning
  endpoint:
    path: /services/data/vXX.X/sobjects/APIScan
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: contact_support
  endpoint:
    path: /contact/support
    method: GET
    data_selector: records
    params: {}
- name: sales_contact
  endpoint:
    path: /contact/sales
    method: GET
    data_selector: records
    params: {}
- name: vulnerabilities
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: records
- name: attacks
  endpoint:
    path: /api/v1/attacks
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: vulnerabilities
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: data
    params: {}
- name: targets
  endpoint:
    path: /api/v1/targets
    method: GET
    data_selector: data
    params: {}
- name: scan
  endpoint:
    path: /v1/scans
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: agents
  endpoint:
    path: /api/v1/agents
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: Single Sign-On
  endpoint:
    path: /sso
    method: POST
    data_selector: configuration
    params: {}
- name: Single Sign-On
  endpoint:
    path: /sso
    method: GET
    data_selector: records
- name: waf_rules
  endpoint:
    path: /api/v1/waf/rules
    method: GET
    data_selector: rules
- name: SecureSphere
  endpoint:
    path: /secureSphere
    method: POST
    data_selector: rules
    params:
      URL: Imperva SecureSphere instance URL
      Username: user name
      Password: user password or personal access token
      Site Name: site name
      Server Group Name: server group name
      Web Service Name: web service name
- name: SecureSphere WAF
  endpoint:
    path: /api/securesphere/waf
    method: POST
    data_selector: rules
    params:
      mandatory:
      - URL
      - Username
      - Password
      - Site Name
      - Server Group Name
      - Web Service Name
- name: API Security
  endpoint:
    path: /api/security
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: vulnerabilities
  endpoint:
    path: /api/vulnerabilities
    method: POST
    data_selector: data
- name: issues
  endpoint:
    path: /issues
    method: GET
    data_selector: issues
    params: {}
- name: technologies
  endpoint:
    path: /technologies
    method: GET
    data_selector: technologies
    params: {}
- name: vulnerabilities
  endpoint:
    path: /api/vulnerabilities
    method: POST
    data_selector: issues
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
- name: vulnerability_scan
  endpoint:
    path: /api/v1/vulnerability_scan
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_application_security
  endpoint:
    path: /api/v1/web_application_security
    method: GET
    data_selector: results
    params: {}
- name: vulnerabilities
  endpoint:
    path: /v1/vulnerabilities
    method: GET
    data_selector: data
    params: {}
- name: scans
  endpoint:
    path: /v1/scans
    method: GET
    data_selector: data
    params: {}
- name: vulnerabilities
  endpoint:
    path: /vulnerabilities
    method: GET
    data_selector: records
- name: vulnerabilities
  endpoint:
    path: /web-vulnerability-scanner/vulnerabilities
    method: GET
    data_selector: records
- name: vulnerabilities
  endpoint:
    path: /web-vulnerability-scanner/vulnerabilities
    method: GET
    data_selector: loc
    params: {}
- name: vulnerabilities
  endpoint:
    path: /web-vulnerability-scanner/vulnerabilities
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: urls
  endpoint:
    path: /api/urls
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
- name: Azure Active Directory
  endpoint:
    path: /support/sso-configuring-azureactivedirectory-single-sign-on-integration-with-saml/
    method: GET
- name: PingFederate
  endpoint:
    path: /support/sso-configuring-pingfederate-single-sign-on-integration-with-saml/
    method: GET
- name: Microsoft ADFS
  endpoint:
    path: /support/sso-configuring-microsoftactivedirectory-single-sign-on-integration-with-saml/
    method: GET
- name: SAML
  endpoint:
    path: /support/sso-configuring-saml-based-single-sign-on-integration/
    method: GET
- name: PingIdentity
  endpoint:
    path: /support/sso-configuring-pingidentity-single-sign-on-integration-with-saml/
    method: GET
- name: ModSecurity
  endpoint:
    path: /support/modsecurity-waf-rules/
    method: GET
- name: Okta
  endpoint:
    path: /support/configuring-okta-sso-integration-with-saml/
    method: GET
- name: Google
  endpoint:
    path: /support/sso-configuring-google-single-sign-on-integration-with-saml/
    method: GET
- name: Imperva SecureSphere
  endpoint:
    path: /support/imperva-securesphere-waf-rules/
    method: GET
- name: F5 BIG-IP
  endpoint:
    path: /support/f5-big-ip-asm-waf-rules/
    method: GET
- name: Microsoft Teams
  endpoint:
    path: /support/integrating-invicti-enterprise-microsoft-teams/
    method: GET
- name: Mattermost
  endpoint:
    path: /support/integrating-invicti-enterprise-mattermost/
    method: GET
- name: GitLab CI/CD
  endpoint:
    path: /support/integrating-invicti-enterprise-gitlab-ci-cd/
    method: GET
- name: UrbanCode
  endpoint:
    path: /support/integrating-invicti-enterprise-urbancode-deploy/
    method: GET
- name: Jenkins
  endpoint:
    path: /support/integrating-invicti-enterprise-scan-jenkins-plugin/
    method: GET
- name: Circle CI
  endpoint:
    path: /support/integrating-invicti-enterprise-circleci/
    method: GET
- name: Bamboo
  endpoint:
    path: /integrations/
    method: GET
- name: TFS
  endpoint:
    path: /support/integrating-invicti-enterprise-tfs/
    method: GET
- name: YouTrack
  endpoint:
    path: /support/integrating-invicti-enterprise-youtrack/
    method: GET
- name: Shortcut
  endpoint:
    path: /support/integrating-invicti-enterprise-shortcut/
    method: GET
- name: Splunk
  endpoint:
    path: /support/invicti-enterprise-addon-splunk/
    method: GET
- name: PagerDuty
  endpoint:
    path: /support/integrating-invicti-enterprise-pagerduty/
    method: GET
- name: Unfuddle
  endpoint:
    path: /support/integrating-netsparking-enterprise-unfuddle/
    method: GET
- name: Redmine
  endpoint:
    path: /support/integrating-invicti-enterprise-redmine/
    method: GET
- name: Pivotal Tracker
  endpoint:
    path: /support/integrating-invicti-enterprise-pivotal-tracker/
    method: GET
- name: ServiceNow Incident Management
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow/
    method: GET
- name: GitHub
  endpoint:
    path: /support/integrating-invicti-enterprise-github/
    method: GET
- name: Kenna
  endpoint:
    path: /support/integrating-invicti-enterprise-kenna/
    method: GET
- name: Kafka
  endpoint:
    path: /support/integrating-invicti-enterprise-kafka/
    method: GET
- name: JIRA
  endpoint:
    path: /support/integrating-invicti-enterprise-jira/
    method: GET
- name: Jazz Team Server
  endpoint:
    path: /support/integrating-invicti-enterprise-jazzteam/
    method: GET
- name: DefectDojo
  endpoint:
    path: /support/integrating-invicti-enterprise-defectdojo/
    method: GET
- name: GitLab
  endpoint:
    path: /support/integrating-invicti-enterprise-gitlab-issue-tracking/
    method: GET
- name: Freshservice
  endpoint:
    path: /support/integrating-invicti-enterprise-freshservice/
    method: GET
- name: Azure Boards
  endpoint:
    path: /support/integrating-invicti-enterprise-azure-boards/
    method: GET
- name: FogBugz
  endpoint:
    path: /support/integrating-invicti-enterprise-fogbugz/
    method: GET
- name: Bugzilla
  endpoint:
    path: /support/integrating-invicti-enterprise-bugzilla/
    method: GET
- name: Bitbucket
  endpoint:
    path: /support/integrating-invicti-enterprise-bitbucket/
    method: GET
- name: Azure API Management
  endpoint:
    path: /support/integrating-azure-api-management/
    method: GET
- name: Mend.io
  endpoint:
    path: /support/integrate-mend-sast/
    method: GET
- name: Amazon API Gateway
  endpoint:
    path: /support/integrating-amazon-api-gateway/
    method: GET
- name: Kubernetes
  endpoint:
    path: /support/installing-invicti-network-traffic-analyzer/
    method: GET
- name: Apigee API hub
  endpoint:
    path: /support/integrating-apigee-api-hub/
    method: GET
- name: MuleSoft Anypoint Exchange
  endpoint:
    path: /support/integrating-mulesoft-anypoint-exchange/
    method: GET
- name: Zapier
  endpoint:
    path: /support/integrating-invicti-enterprise-zapier/
    method: GET
- name: FortiWeb
  endpoint:
    path: /support/fortiweb-waf-rules/
    method: GET
- name: Cloudflare
  endpoint:
    path: /support/cloudflare-waf-rules/
    method: GET
- name: Slack
  endpoint:
    path: /support/integrating-invicti-enterprise-slack/
    method: GET
- name: AWS
  endpoint:
    path: /support/amazon-web-services-waf-rules/
    method: GET
- name: GitHub Actions
  endpoint:
    path: /support/integrating-invicti-enterprise-github-actions/
    method: GET
- name: Asana
  endpoint:
    path: /support/integrating-invicti-enterprise-asana/
    method: GET
- name: Travis CI
  endpoint:
    path: /support/integrating-invicti-enterprise-travis-ci/
    method: GET
- name: Azure Pipelines
  endpoint:
    path: /support/integrating-invicti-enterprise-azure-pipelines/
    method: GET
- name: Trello
  endpoint:
    path: /support/integrating-invicti-enterprise-trello/
    method: GET
- name: Application Security Posture Management
  endpoint:
    path: /api/v1/appsec
    method: GET
    data_selector: results
- name: Azure Active Directory
  endpoint:
    path: /support/sso-configuring-azureactivedirectory-single-sign-on-integration-with-saml/
    method: GET
- name: PingFederate
  endpoint:
    path: /support/sso-configuring-pingfederate-single-sign-on-integration-with-saml/
    method: GET
- name: Microsoft ADFS
  endpoint:
    path: /support/sso-configuring-microsoftactivedirectory-single-sign-on-integration-with-saml/
    method: GET
- name: SAML
  endpoint:
    path: /support/sso-configuring-saml-based-single-sign-on-integration/
    method: GET
- name: PingIdentity
  endpoint:
    path: /support/sso-configuring-pingidentity-single-sign-on-integration-with-saml/
    method: GET
- name: ModSecurity
  endpoint:
    path: /support/modsecurity-waf-rules/
    method: GET
- name: Okta
  endpoint:
    path: /support/configuring-okta-sso-integration-with-saml/
    method: GET
- name: Google
  endpoint:
    path: /support/sso-configuring-google-single-sign-on-integration-with-saml/
    method: GET
- name: Imperva SecureSphere
  endpoint:
    path: /support/imperva-securesphere-waf-rules/
    method: GET
- name: F5 BIG-IP
  endpoint:
    path: /support/f5-big-ip-asm-waf-rules/
    method: GET
- name: Microsoft Teams
  endpoint:
    path: /support/integrating-invicti-enterprise-microsoft-teams/
    method: GET
- name: Mattermost
  endpoint:
    path: /support/integrating-invicti-enterprise-mattermost/
    method: GET
- name: GitLab CI/CD
  endpoint:
    path: /support/integrating-invicti-enterprise-gitlab-ci-cd/
    method: GET
- name: UrbanCode
  endpoint:
    path: /support/integrating-invicti-enterprise-urbancode-deploy/
    method: GET
- name: Jenkins
  endpoint:
    path: /support/integrating-invicti-enterprise-scan-jenkins-plugin/
    method: GET
- name: Circle CI
  endpoint:
    path: /support/integrating-invicti-enterprise-circleci/
    method: GET
- name: Bamboo
  endpoint:
    path: /integrations/
    method: GET
- name: TFS
  endpoint:
    path: /support/integrating-invicti-enterprise-tfs/
    method: GET
- name: YouTrack
  endpoint:
    path: /support/integrating-invicti-enterprise-youtrack/
    method: GET
- name: Shortcut
  endpoint:
    path: /support/integrating-invicti-enterprise-shortcut/
    method: GET
- name: Splunk
  endpoint:
    path: /support/invicti-enterprise-addon-splunk/
    method: GET
- name: PagerDuty
  endpoint:
    path: /support/integrating-invicti-enterprise-pagerduty/
    method: GET
- name: Unfuddle
  endpoint:
    path: /support/integrating-netsparking-enterprise-unfuddle/
    method: GET
- name: Redmine
  endpoint:
    path: /support/integrating-invicti-enterprise-redmine/
    method: GET
- name: Pivotal Tracker
  endpoint:
    path: /support/integrating-invicti-enterprise-pivotal-tracker/
    method: GET
- name: ServiceNow Incident Management
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow/
    method: GET
- name: GitHub
  endpoint:
    path: /support/integrating-invicti-enterprise-github/
    method: GET
- name: Kenna
  endpoint:
    path: /support/integrating-invicti-enterprise-kenna/
    method: GET
- name: Kafka
  endpoint:
    path: /support/integrating-invicti-enterprise-kafka/
    method: GET
- name: JIRA
  endpoint:
    path: /support/integrating-invicti-enterprise-jira/
    method: GET
- name: Jazz Team Server
  endpoint:
    path: /support/integrating-invicti-enterprise-jazzteam/
    method: GET
- name: DefectDojo
  endpoint:
    path: /support/integrating-invicti-enterprise-defectdojo/
    method: GET
- name: GitLab
  endpoint:
    path: /support/integrating-invicti-enterprise-gitlab-issue-tracking/
    method: GET
- name: Freshservice
  endpoint:
    path: /support/integrating-invicti-enterprise-freshservice/
    method: GET
- name: Azure Boards
  endpoint:
    path: /support/integrating-invicti-enterprise-azure-boards/
    method: GET
- name: FogBugz
  endpoint:
    path: /support/integrating-invicti-enterprise-fogbugz/
    method: GET
- name: Bugzilla
  endpoint:
    path: /support/integrating-invicti-enterprise-bugzilla/
    method: GET
- name: Bitbucket
  endpoint:
    path: /support/integrating-invicti-enterprise-bitbucket/
    method: GET
- name: Azure API Management
  endpoint:
    path: /support/integrating-azure-api-management/
    method: GET
- name: Mend.io
  endpoint:
    path: /support/integrate-mend-sast/
    method: GET
- name: Amazon API Gateway
  endpoint:
    path: /support/integrating-amazon-api-gateway/
    method: GET
- name: Kubernetes
  endpoint:
    path: /support/installing-invicti-network-traffic-analyzer/
    method: GET
- name: Apigee API hub
  endpoint:
    path: /support/integrating-apigee-api-hub/
    method: GET
- name: MuleSoft Anypoint Exchange
  endpoint:
    path: /support/integrating-mulesoft-anypoint-exchange/
    method: GET
- name: Zapier
  endpoint:
    path: /support/integrating-invicti-enterprise-zapier/
    method: GET
- name: FortiWeb
  endpoint:
    path: /support/fortiweb-waf-rules/
    method: GET
- name: Cloudflare
  endpoint:
    path: /support/cloudflare-waf-rules/
    method: GET
- name: Slack
  endpoint:
    path: /support/integrating-invicti-enterprise-slack/
    method: GET
- name: AWS
  endpoint:
    path: /support/amazon-web-services-waf-rules/
    method: GET
- name: GitHub Actions
  endpoint:
    path: /support/integrating-invicti-enterprise-github-actions/
    method: GET
- name: Asana
  endpoint:
    path: /support/integrating-invicti-enterprise-asana/
    method: GET
- name: Travis CI
  endpoint:
    path: /support/integrating-invicti-enterprise-travis-ci/
    method: GET
- name: Azure Pipelines
  endpoint:
    path: /support/integrating-invicti-enterprise-azure-pipelines/
    method: GET
- name: Trello
  endpoint:
    path: /support/integrating-invicti-enterprise-trello/
    method: GET
- name: ServiceNow Application Vulnerability Response
  endpoint:
    path: /support/api-overview/
    method: GET
- name: ServiceNow Vulnerability Response
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow-vulnerability-response/
    method: GET
- name: Zapier
  endpoint:
    path: /support/integrating-invicti-enterprise-zapier/
    method: GET
- name: ServiceNow Application Vulnerability Response
  endpoint:
    path: /bundle/washingtondc-security-management/page/product/secops-integration-vr/invicti/concept/invicti-vuln-integration.html
    method: GET
    data_selector: vulnerabilities
    params: {}
- name: ServiceNow Vulnerability Response
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow-vulnerability-response/
    method: GET
    data_selector: responses
    params: {}
- name: ServiceNow Application Vulnerability Response
  endpoint:
    path: /bundle/washingtondc-security-management/page/product/secops-integration-vr/invicti/concept/invicti-vuln-integration.html
    method: GET
- name: ServiceNow Vulnerability Response
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow-vulnerability-response/
    method: GET
- name: HashiCorp Vault
  endpoint:
    path: /support/integrating-invicti-enterprise-hashicorp-vault/
    method: GET
- name: CyberArk Vault
  endpoint:
    path: /support/integrating-invicti-enterprise-cyberark-vault/
    method: GET
- name: Okta
  endpoint:
    path: /support/configuring-okta-sso-integration-with-saml/
    method: GET
- name: scan_results
  endpoint:
    path: /api/v1/scan/results
    method: GET
    data_selector: results
- name: vulnerability_reports
  endpoint:
    path: /api/v1/vulnerabilities/reports
    method: GET
    data_selector: reports
- name: vulnerability_scan
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: records
- name: api_security_tests
  endpoint:
    path: /api/v1/security-tests
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_asset_inventory
  endpoint:
    path: /features/continuous-web-asset-discovery-engine
    method: GET
    data_selector: results
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: api_security_testing
  endpoint:
    path: /api/security/testing
    method: GET
- name: scan_result
  endpoint:
    path: /api/v1/scan/result
    method: GET
    data_selector: results
    params:
      incremental: last_scanned
- name: vulnerability
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: vulnerabilities
    params: {}
- name: detailed_scan_results
  endpoint:
    path: /features/detailed-scan-results
    method: GET
    data_selector: vulnerabilities
    params: {}
- name: vulnerability_trend_matrix
  endpoint:
    path: /features/vulnerability-trend-matrix
    method: GET
- name: compliance_scans
  endpoint:
    path: /features/simplify-compliance
    method: GET
- name: vulnerability_scan_results
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: results
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_vulnerability_scanner
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: results
- name: scan
  endpoint:
    path: /api/v1/scans
    method: GET
    data_selector: scans
    params: {}
- name: vulnerability
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: vulnerabilities
    params: {}
- name: vulnerability_scan_results
  endpoint:
    path: /api/v1/vulnerability_scan_results
    method: GET
    data_selector: results
- name: vulnerabilities
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: records
    params: {}
- name: security_reports
  endpoint:
    path: /api/v1/security_reports
    method: GET
    data_selector: reports
    params: {}
- name: vulnerabilities
  endpoint:
    path: /api/v1/vulnerabilities
    method: GET
    data_selector: data
- name: security_reports
  endpoint:
    path: /api/v1/reports
    method: GET
    data_selector: reports
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
- name: vulnerability_scan
  endpoint:
    path: /api/vulnerability_scan
    method: GET
    data_selector: scans
- name: application_security
  endpoint:
    path: /api/application_security
    method: GET
    data_selector: applications
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_application_security
  endpoint:
    path: /api/web_application_security
    method: GET
    data_selector: records
- name: api_security
  endpoint:
    path: /api/api_security
    method: GET
    data_selector: records
- name: web_application_security
  endpoint:
    path: /api/v1/security
    method: GET
    data_selector: results
- name: asset_management
  endpoint:
    path: /services/data/vXX.X/sobjects/AssetManagement
    method: GET
    data_selector: records
    params: {}
- name: vulnerability_tracking
  endpoint:
    path: /services/data/vXX.X/sobjects/VulnerabilityTracking
    method: GET
    data_selector: records
    params: {}
- name: web_security_scanner
  endpoint:
    path: /api/v1/websecurityscanner
    method: GET
    data_selector: results
    params: {}
- name: vulnerability_scan
  endpoint:
    path: /api/v1/scans
    method: POST
    data_selector: scans
    params: {}
- name: web_application_security_scanner
  endpoint:
    path: /web-vulnerability-scanner/
    method: GET
- name: vulnerability_scan
  endpoint:
    path: /api/v1/scans
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_application_security_scans
  endpoint:
    path: /api/scans
    method: GET
    data_selector: scans
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: job_openings
  endpoint:
    path: /api/v1/job-openings
    method: GET
    data_selector: jobs
    params: {}
- name: vulnerability_scan
  endpoint:
    path: /services/data/vXX.X/sobjects/VulnerabilityScan
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: vulnerability_scan
  endpoint:
    path: /api/v1/vulnerability-scan
    method: GET
    data_selector: records
- name: dast_scan
  endpoint:
    path: /api/v1/scans
    method: POST
    data_selector: scans
    params: {}
- name: api_security
  endpoint:
    path: /api/v1/security
    method: GET
    data_selector: security
    params: {}
- name: customer_success_manager
  endpoint:
    path: /api/v1/customersuccessmanager
    method: GET
    data_selector: records
    params: {}
- name: senior_ux_designer
  endpoint:
    path: /api/v1/senioruxdesigner
    method: GET
    data_selector: records
    params: {}
- name: application_security
  endpoint:
    path: /api/v1/application_security
    method: GET
    data_selector: records
- name: security_scan
  endpoint:
    path: /api/security_scan
    method: POST
    data_selector: results
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: web_application_security
  endpoint:
    path: /api/v1/web_application_security
    method: GET
    data_selector: data
    params: {}
- name: api_security
  endpoint:
    path: /api/v1/api_security
    method: GET
    data_selector: data
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: dast_scan
  endpoint:
    path: /services/data/vXX.X/sobjects/DastScan
    method: GET
    data_selector: records
    params: {}
- name: web_application_security
  endpoint:
    path: /product/api-security
    method: GET
    data_selector: data
    params: {}
- name: security_scanning
  endpoint:
    path: /scanning
    method: POST
    data_selector: results
    params: {}
- name: application_security
  endpoint:
    path: /appsec
    method: GET
    data_selector: reports
    params: {}
- name: blind_sql_injection
  endpoint:
    path: /learn/blind-sql-injection
    method: GET
    data_selector: content
- name: vulnerabilities
  endpoint:
    path: /learn/vulnerabilities
    method: GET
    data_selector: records
    params: {}
- name: attacks
  endpoint:
    path: /learn/attacks
    method: GET
    data_selector: records
    params: {}
- name: HOIC
  endpoint:
    path: /learn/high-orbit-ion-cannon-hoic
    method: GET
    data_selector: records
- name: slowloris_attack
  endpoint:
    path: /learn/slowloris-attack
    method: GET
    data_selector: content
    params: {}
- name: session_fixation
  endpoint:
    path: /learn/session-fixation
    method: GET
    data_selector: content
    params: {}
- name: reverse_shell_examples
  endpoint:
    path: /learn/reverse-shell/examples
    method: GET
    data_selector: examples
- name: session_prediction
  endpoint:
    path: /learn/session-prediction
    method: GET
    data_selector: records
- name: vulnerabilities
  endpoint:
    path: /learn/vulnerabilities
    method: GET
    data_selector: vulnerabilities
    params: {}
- name: attacks
  endpoint:
    path: /learn/attacks
    method: GET
    data_selector: attacks
    params: {}
- name: tools
  endpoint:
    path: /learn/tools
    method: GET
    data_selector: tools
    params: {}
- name: vulnerability_management
  endpoint:
    path: /learn/vulnerability-management
    method: GET
    data_selector: records
    params: {}
- name: dynamic_application_security_testing
  endpoint:
    path: /learn/dynamic-application-security-testing-dast
    method: GET
    data_selector: records
    params: {}
- name: static_application_security_testing
  endpoint:
    path: /learn/static-application-security-testing-sast
    method: GET
    data_selector: records
    params: {}
- name: vulnerability_assessment
  endpoint:
    path: /learn/vulnerability-assessment
    method: GET
    data_selector: records
    params: {}
- name: vulnerability_assessment
  endpoint:
    path: /learn/vulnerability-assessment
    method: GET
    data_selector: content
    params: {}
- name: vulnerability
  endpoint:
    path: /learn/vulnerability
    method: GET
    data_selector: records
- name: components
  endpoint:
    path: /learn/software-composition-analysis-sca
    method: GET
    data_selector: components
    params: {}
- name: iRule
  endpoint:
    path: /integrate/f5/big-ip/irule
    method: POST
    data_selector: data
    params: {}
- name: log_pool
  endpoint:
    path: /local_traffic/pools
    method: POST
    data_selector: log_pool
    params:
      name: log_pool
      node_name: NTA_node_name
      address: NTA_IP_address
      port: 15400
- name: iRule
  endpoint:
    path: /local_traffic/iRules
    method: POST
    data_selector: iRule
    params:
      name: iRule_name
      definition: when CLIENT_ACCEPTED { ... } when HTTP_REQUEST { ... }
- name: NTA in Docker with NGINX in Docker
  endpoint:
    path: /integrate-nta-docker-nginx-docker/
    method: GET
- name: log_pool
  endpoint:
    path: /Local traffic/Pools
    method: POST
    data_selector: log_pool
    params:
      name: log_pool
      node_name: NTA installation node name
      address: IP address of NTA machine
      port: 15400
- name: iRule
  endpoint:
    path: /Local traffic/iRules
    method: POST
    data_selector: iRule
    params:
      name: iRule name
      definition: iRule script
- name: Virtual Server
  endpoint:
    path: /Local traffic/Virtual Servers
    method: PUT
    data_selector: Virtual Server
    params:
      iRule: iRule name
- name: reconstructor
  endpoint:
    path: /api-discovery/reconstructor:latest
    method: GET
- name: traffic-signal-aggregator
  endpoint:
    path: /api-discovery/tsa:latest
    method: GET
- name: scan_result
  endpoint:
    path: /api/scans/results
    method: GET
    data_selector: results
    params:
      incremental: updated_at
- name: reconstructor
  endpoint:
    path: /api-discovery/reconstructor:latest
    method: GET
    data_selector: records
    params: {}
- name: traffic-signal-aggregator
  endpoint:
    path: /api-discovery/tsa:latest
    method: GET
    data_selector: records
    params: {}
- name: slowest_pages_report
  endpoint:
    path: /scans/recent/scans/report
    method: GET
    data_selector: slowestPages
- name: exclude_urls
  endpoint:
    path: /scans/new_scan
    method: POST
    data_selector: excludeUrls
- name: signature_page_limits
  endpoint:
    path: /scans/recent/scans/report
    method: GET
    data_selector: signaturePageLimits
- name: crawling_limits
  endpoint:
    path: /policies/new_scan_policy/crawling
    method: PUT
    data_selector: crawlingLimits
- name: security_checks
  endpoint:
    path: /policies/new_scan_policy/security_checks
    method: PUT
    data_selector: securityChecks
- name: request_settings
  endpoint:
    path: /policies/new_scan_policy/request
    method: PUT
    data_selector: requestSettings
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: scan
  endpoint:
    path: /scans
    method: GET
    data_selector: data
    params:
      incremental: updated_at
- name: target
  endpoint:
    path: /targets
    method: GET
    data_selector: data
    params: {}
- name: scan_scope
  endpoint:
    path: /api/scans
    method: GET
    data_selector: records
- name: issues
  endpoint:
    path: /issues
    method: GET
    data_selector: data
    params: {}
- name: technologies
  endpoint:
    path: /technologies
    method: GET
    data_selector: data
    params: {}
- name: scan_scope
  endpoint:
    path: /scan/scope
    method: GET
    data_selector: scopes
    params: {}
- name: scan_scope
  endpoint:
    path: /scans/new
    method: POST
    data_selector: scan_settings
    params:
      scope: Entered Path and Below
      target_url: http://example.com/
- name: scan_scope
  endpoint:
    path: /scans/scope
    method: GET
    data_selector: scopes
    params: {}
- name: scan_result
  endpoint:
    path: /api/v1/scan/result
    method: GET
    data_selector: results
    params: {}
- name: Scan Scope
  endpoint:
    path: /scan/scope
    method: GET
    data_selector: scope
    params: {}
- name: scan_scope
  endpoint:
    path: /scans/new
    method: POST
    data_selector: scan_configuration
    params:
      scope: Entered Path and Below
      target_url: http://example.com/
      exclude_regex: /admin
- name: issues
  endpoint:
    path: /issues
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: scan_policy
  endpoint:
    path: /policies
    method: POST
    data_selector: scan_policy
    params: {}
- name: scan
  endpoint:
    path: /scans
    method: POST
    data_selector: scan_result
    params: {}
- name: issues
  endpoint:
    path: /issues
    method: GET
    data_selector: data
    params: {}
- name: vulnerabilities
  endpoint:
    path: /vulnerabilities
    method: GET
    data_selector: data
    params: {}
- name: form_validation_errors
  endpoint:
    path: /api/form-validation-errors
    method: GET
    data_selector: errors
    params: {}
- name: scan_policy
  endpoint:
    path: /Policies/New
    method: POST
    data_selector: scanPolicy
    params: {}
- name: scan_application
  endpoint:
    path: /Scans/New
    method: POST
    data_selector: scanResult
    params: {}
- name: group_scan
  endpoint:
    path: /Scans/NewGroupScan
    method: POST
    data_selector: groupScanResult
    params: {}
- name: scan_report
  endpoint:
    path: /Scans/RecentScans
    method: GET
    data_selector: scanReports
    params: {}
- name: form_validation_errors
  endpoint:
    path: /api/v1/form-validation-errors
    method: GET
    data_selector: errors
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
- name: issues
  endpoint:
    path: /issues
    method: GET
    data_selector: data
    params: {}
- name: technologies
  endpoint:
    path: /technologies
    method: GET
    data_selector: data
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: jira_integration
  endpoint:
    path: /api/jira/integration
    method: POST
    data_selector: issue
    params: {}
- name: jira_integration
  endpoint:
    path: /api/jira/integration
    method: POST
    data_selector: issue
    params: {}
- name: scan_agent
  endpoint:
    path: /services/data/vXX.X/sobjects/ScanAgent
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: scan_agent
  endpoint:
    path: /support/installing-scan-agent-linux-redhat/
    method: GET
    data_selector: content
    params: {}
- name: scan_agent
  endpoint:
    path: /support/installing-scan-agent-linux-redhat/
    method: GET
    data_selector: instructions
    params: {}
- name: authentication_verifier_agent
  endpoint:
    path: /support/authentication-verifier-agent/#linux
    method: GET
    data_selector: instructions
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: login
  endpoint:
    path: /login
    method: POST
    data_selector: credentials
    params: {}
- name: secret_management_service
  endpoint:
    path: /v1/secret/data
    method: POST
    data_selector: data
    params:
      kv_version: V2
      secret_engine: eng-secrets
      secret: passcodes
      username_key: Username
      password_key: Password
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: Cloud Integration
  endpoint:
    path: /cloud-integration
    method: POST
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: cloud_integration_settings
  endpoint:
    path: /cloud-provider-settings
    method: GET
- name: Issue note
  endpoint:
    path: /services/data/vXX.X/sobjects/IssueNote
    method: GET
    data_selector: records
- name: Scan profile
  endpoint:
    path: /services/data/vXX.X/sobjects/ScanProfile
    method: GET
    data_selector: records
- name: User
  endpoint:
    path: /services/data/vXX.X/sobjects/User
    method: GET
    data_selector: records
- name: Target URI
  endpoint:
    path: /services/data/vXX.X/sobjects/TargetURI
    method: GET
    data_selector: records
- name: Scan data
  endpoint:
    path: /services/data/vXX.X/sobjects/ScanData
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: agents_listverifiers
  endpoint:
    path: /agents/listverifiers
    method: GET
    data_selector: records
    params: {}
- name: agents
  endpoint:
    path: /agents/listverifiers
    method: GET
    data_selector: records
- name: campaign_member
  endpoint:
    path: /services/data/vXX.X/sobjects/CampaignMember
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: contact
  endpoint:
    path: /services/data/vXX.X/sobjects/Contact
    method: GET
    data_selector: records
    params: {}
- name: automated_penetration_testing
  endpoint:
    path: /services/data/vXX.X/sobjects/AutomatedPenetrationTesting
    method: GET
    data_selector: records
    params:
      incremental: updated_at
- name: ServiceNow Application Vulnerability Response
  endpoint:
    path: /bundle/washingtondc-security-management/page/product/secops-integration-vr/invicti/concept/invicti-vuln-integration.html
    method: GET
- name: ServiceNow Vulnerability Response
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow-vulnerability-response/
    method: GET
- name: ServiceNow Incident Management
  endpoint:
    path: /support/integrating-invicti-enterprise-servicenow/
    method: GET
notes:
- Uses OAuth2 with refresh token — requires setup of connected app in api
- Some objects like Contact may return nulls in deeply nested fields
- Some objects may return nulls in deeply nested fields
- Invicti Enterprise does not support partial API calls.
- Invicti scans REST, SOAP, and GraphQL APIs with the same depth and accuracy as web
  apps.
- No agent or sensors to deploy. Automatically discover and extract downstream API
  specs during web app scans.
- Crawl target domains for Swagger/OpenAPI specs.
- Uses OAuth2 with refresh token — requires setup of connected app in Invicti
- Prove your compliance with built-in reporting for HIPAA and more
- Integrating Invicti into Your Vulnerability Management System
- Managing team members in Invicti Enterprise
- Ensure correct OAuth scopes are set up in the Invicti application.
- Requires setup of connected app in api
- Ensure you create a .github/workflows directory.
- Committing the workflow file in your repository triggers the event and runs your
  workflow.
- Configuring Azure Active Directory Integration with SAML
- Uses Security Assertion Markup Language (SAML) for SSO access.
- IdP-initiated SSO is required for Auto Provisioning.
- Invicti Enterprise supports the SAML methods, both IdP-initiated and SP-initiated.
- 'Enable Auto Provisioning: If enabled, an account will be automatically created
  for IdP-registered users when they first access Invicti Enterprise.'
- 'Require SAML assertions to be encrypted: If enabled, it prevents third parties
  from reading private data in transit from assertions.'
- Select this option to enable the single sign-on feature.
- Enable this option so only administrator users can authenticate without single sign-on.
  Users can only sign in to Invicti Enterprise by using the email address that belongs
  to their employer.
- Ensure that API keys are kept secure and not exposed in client-side code.
- ServiceNow Application Vulnerability Response helps you with tracking, prioritizing,
  and resolving vulnerabilities.
- Requires verification of SSL certificate for the GitHub server URL.
- Ensure proper API access permissions are configured.
- The SSL certificate of the URL must be verified.
- Requests with empty or default values are not sent to DeepInfo
- Updated remediation details for outdated AngularJS versions
- Enhanced the 'Configure New Agent' page to include additional details for auth verifier
  agents
- Fixed an issue with retrieving OAuth2 token data from JSON responses
- Automated pentesting should be a continuous process.
- DAST tools can identify common security weaknesses.
- Automated pentesting is best performed as part of an automated continuous process.
- DAST tools can automatically probe for common security weaknesses.
- Invicti can scan any type of web application, regardless of the technology it was
  built with.
- Netsparker is now Invicti. While the results of the benchmark test remain valid,
  this post may not reflect the latest product names and features.
- Uses OAuth2 for authentication
- Periodic web vulnerability scanning is vital for ensuring cybersecurity
- Invicti allows unlimited concurrent scanning.
- Invicti (formerly Netsparker) is built on a market-leading dynamic application security
  testing (DAST) solution.
- Automated authentication is a must for scanning enterprise environments that overwhelmingly
  require authentication and authorization to access most or all web assets, both
  web apps and APIs.
- Requires setup of API client in Invicti dashboard.
- Some endpoints may have rate limits.
- The Sites are not directed to children under the age of 18.
- We cannot guarantee or warrant the security of any information transmitted to or
  from the Sites or services.
- Invicti Team and Enterprise has a full-featured REST API which allows for easy integration.
- We do not sell personal information as defined under applicable law.
- We do not offer financial incentives and price or service differences.
- Easily find vulnerabilities in authentication-protected areas
- The policy applies to personal information collected when visiting the Sites or
  communicating with the company.
- Requires setup of connected app in Invicti
- Some data may return nulls in deeply nested fields
- Requires setup of connected app in invicti
- No authentication required for access.
- 'Scan with proof: Validate exploitable issues with 99.98% accuracy.'
- 'Consolidate alerts: Instantly fetch findings from all your security tools.'
- 'Correlate across scanners: Correlate issues across tools into a single, prioritized
  risk view.'
- Invicti fits directly into your CI/CD pipeline with native integrations for tools
  like Jenkins, GitHub, and Azure to deliver clean, actionable results right inside
  developer workflows.
- Some objects may return nulls in deeply nested fields.
- Invicti is authentication-aware and designed to scan authenticated flows.
- Invicti provides multi-level API discovery spanning zero-config specification file
  detection, API management platform integration, and network traffic analysis in
  container environments.
- Invicti provides mature support for popular API authentication methods, including
  basic HTTP authentication, JSON Web Tokens (JWTs), and OAuth2.
- Automated authentication is a practical prerequisite for API vulnerability scanning.
- API security needs to be a routine yet unobtrusive part of your overall web application
  security program
- API discovery should be a routine part of your broader application security process
- Integrates with CI/CD tools for automated security testing
- Supports stateful API scanning for complex workflows
- Integrates with tools developers use
- Scan for vulnerabilities from the early stages of development
- Some endpoints may return nulls in deeply nested fields
- Integrates with 110+ tools, including CI/CD, issue tracker, collaboration tools,
  and other software
- Run tests in multiple environments at the same time.
- Get results for multiple environments in one place.
- Choose the best deployment model for each environment.
- Easily crawl assets that require authentication
- Run authenticated scans on production-ready applications
- Advanced manual scanning tools are available for manual vulnerability testing.
- Uses Proof-Based Scanning to reduce false positives.
- IAST sensor enhances visibility into backend of web applications.
- Requires setup of OAuth application in Invicti
- Rate limits apply to API calls
- 'Supported authentication methods include: Automated login form submission, OAuth2,
  NTLM/Kerberos, Basic HTTP Authentication'
- Gives developers all the information they need to resolve each issue on their own
- Automatically scans for unknown assets.
- Works in the background, scanning for vulnerabilities everywhere.
- Invicti detects common API access control flaws like broken object level authorization
  (BOLA), the API-specific form of Insecure direct object reference (IDOR), as well
  as broken function level authorization (BFLA).
- Supports stateful API scanning, which means it tracks and tests multi-step workflows
  across chained API calls.
- Use predefined compliance scans and reports to simplify the process.
- Some scan results may include false positives
- Uses OAuth2 with refresh token.
- Cross-site scripting is a common web application vulnerability.
- Validation and sanitization of user input can help prevent XSS attacks.
- Give direct or API-based access to everyone who needs it
- Customize user roles and privileges
- Filters often remove legitimate content because it matches forbidden keywords. Filtering
  is recommended only if the content is very simple.
- Writing escaping routines by yourself is extremely time-consuming and makes the
  code difficult to maintain.
- All-in-one platform for SAST, DAST, IAST, and SCA
- API Discovery ensures no vulnerability is overlooked
- Cross-site scripting (XSS) is a web vulnerability that lets a malicious hacker introduce
  undesired commands into legitimate client-side code.
- Filtering may have side effects.
- Most developers prefer to use community-maintained libraries for XSS prevention.
- Eliminate manual work with auto-verification and 50+ integrations
- SQL injection is one of the most dangerous vulnerabilities.
- Using prepared statements is the only fully effective way to prevent SQLi vulnerabilities.
- Requires setup of OAuth2 integration in Invicti
- Server-side request forgery (SSRF) is a vulnerability that lets a malicious hacker
  send a request from the back end of the software to another server or to a local
  service.
- For these reasons, SSRF exploits are usually a preliminary attack step before exploiting
  another vulnerability.
- SQL injection is one of the highest severity vulnerabilities.
- It is even possible to obtain operating system access through an SQL injection.
- SSRF vulnerabilities may appear in any type of computer software, in almost every
  programming language, and on any platform.
- The only way to guarantee that your code will not have an SSRF vulnerability is
  not to use any data originating from user input when you access other servers.
- Asset management is a really big priority for Zen Internet, but it should also be
  a big priority for everybody.
- DAST is an important piece of your overall application security strategy.
- DAST tools either offer extra functionality or come bundled with accompanying software.
- Automated pentesting is best performed as part of a continuous process.
- Web applications and APIs are in the first line of fire for cyberattacks.
- Invicti allows for the integration of vulnerability scan results into a global cybersecurity
  KPI dashboard.
- DAST has proven to be a critical component of our company's security success.
- Invicti offers customizable scan settings for detailed analysis.
- Asset management issues are a risk to any organization and should be a top priority
- Dynamic application security testing is not limited to any specific types of applications
  or tools.
- DAST solutions are designed to work as part of AppSec automation processes.
- Automated penetration testing software integrates with development, operations,
  and security workflows.
- Focus on web application and API attack surface for automated pentesting.
- Invicti is easy to use and automates much of the pre-scan and post-scan process.
- Invicti is an integral part of ISACA's development life cycle and has been used
  to scan website changes and new web applications.
- Some API calls may have rate limits
- Uses support for two-factor authentication and security audit logs.
- Invicti consistently finds and validates SQL injection vulnerabilities faster than
  any scanner we have ever used.
- Invicti offers a strong combination of vital features, notably out-of-the-box integration
  with tools already used in the software development pipeline.
- Need some help with support questions or technical issues? We’re here to help you
  troubleshoot.
- Uses OAuth2 with refresh token — requires setup of connected app in Invicti.
- DAST scanning is part of compliance frameworks like PCI and SOC 2.
- Thorough interview process with recruitment team and hiring managers
- Job offers are not communicated solely via email
- Some features may be in beta and subject to change.
- Invicti’s dynamic and interactive application security products help organizations
  in every industry scale their overall security operations.
- Focus on integrating security into CI/CD pipeline
- TrolleySpill was used in hundreds of thousands of sites.
- The maintainer sold the source control account and domain.
- Some endpoints may have rate limits
- WAFs should not be relied upon as the only means of keeping web applications secure.
- WAFs can mitigate zero-day vulnerabilities until a patch is available.
- DOM-based XSS is purely a client-side vulnerability.
- The payload never reaches the server.
- Reflected cross-site scripting is regarded as less dangerous than stored/persistent
  XSS, but the consequences can also be dire.
- A reflected XSS attack is more difficult to perform because it needs more than just
  creating and delivering a single payload.
- DAST scanning is part of most compliance frameworks like PCI and SOC 2.
- Speed and accuracy are critical for DAST performance.
- Stored cross-site scripting is the most dangerous of all XSS types simply because
  it reaches the largest number of users.
- Invicti Learn is your one-stop-shop for all information on web application security.
- Integration with CI/CD pipeline is essential for vulnerability management.
- DAST should be prioritized for initial security scanning.
- Integer overflow is a software weakness that causes a program to behave unexpectedly
  when it exceeds the maximum supported integer value.
- Never trust the content of the Host header or any other request headers that could
  be manipulated.
- TrolleySpill was created as a free tool to make web developers’ lives easier.
- The maintainer got burned out and sold the source control account and the domain
  that hosted the code to a sketchy company.
- Automation helps in combating vulnerabilities
- Increased scrutiny around software supply chain due to incidents like SolarWinds
- Buffer overflow is a vulnerability that lets a malicious hacker inject data into
  program memory and execute it by giving more data in user input than the program
  is designed to handle.
- Publicly exposed endpoints may lack authentication and authorization.
- Insecure direct object references (IDOR) are vulnerabilities that occur when a web
  application developer uses only identifiers to directly point to page elements that
  should be subject to access control or require authorization.
- Implement strict access control checks for all sensitive objects.
- JSON injection is a vulnerability that lets a malicious hacker inject malicious
  data into JSON streams or use malicious JSON streams to modify application behavior.
- Server-side JSON injection happens when data from an untrusted source is not sanitized
  by the server and is written directly to a JSON stream.
- Client-side JSON injection happens when data from an untrusted JSON source is not
  sanitized and is parsed directly using the JavaScript eval function.
- 'WAFs should be an integral part of a web application security program because they
  are the only tool able to immediately address two types of situations: Zero-day
  response and Temporary mitigation.'
- Email injection is a severe vulnerability that can abuse email-related functionality.
- NoSQL injection is a vulnerability that lets a malicious hacker introduce undesired
  code into database queries executed by NoSQL databases.
- NoSQL injections may allow the attacker to bypass authentication, extract data,
  modify data, or even gain complete control over the web application.
- Reflected cross-site scripting is a type of cross-site scripting (XSS) where the
  attacker does not send the payload to the web application; instead, they send it
  to the victim in the form of a URL that includes the payload.
- HTML injections are less dangerous than XSS but may still be used for malicious
  purposes.
- Preventing HTML injections requires input validation.
- Stored cross-site scripting can reach a large number of users and has significant
  consequences.
- Validation and sanitization of user input are crucial to prevent XSS vulnerabilities.
- CRLF injection is a vulnerability that lets a malicious hacker inject carriage return
  (CR) and linefeed (LF) characters to change the way a web application works.
- Potential escalation to cross-site scripting.
- Remote file inclusion vulnerabilities may lead to remote code execution.
- The ability to include remote files has been deprecated since PHP 7.4.0.
- Exploiting SQL injections in combination with other common vulnerabilities can have
  dramatic consequences.
- The only way to protect against IDORs is to implement strict access control checks
  for all sensitive objects.
- Directory listing should always be turned off to avoid information disclosure.
- Relying purely on other prevention methods, such as whitelists, blacklists, or input
  filtering/escaping, is not recommended.
- The only fully effective way to prevent all types of SQLi vulnerabilities in web
  applications, including blind SQLi, is to use parameterized queries (also known
  as prepared statements) to access SQL databases.
- JSON injection is a vulnerability that lets a malicious hacker inject malicious
  data into JSON streams.
- Server-side JSON injection happens when data from an untrusted source is not sanitized
  by the server.
- Email injection is considered a severe cybersecurity issue.
- Vulnerabilities can allow attackers to send emails with arbitrary content.
- The only fully effective way to prevent all types of SQLi vulnerabilities in web
  applications, including out-of-band SQLi, is to use parameterized queries (also
  known as prepared statements) to access SQL databases.
- OS command injection is a vulnerability that lets a malicious hacker trick an application
  into executing operating system commands.
- Command injection vulnerabilities are an appsec problem that may appear in any type
  of computer software, in almost every programming language, and on any platform.
- HTML injection vulnerabilities are usually underestimated.
- 'Severity: severe in rare circumstances'
- 'Prevalence: discovered rarely'
- 'Scope: web applications'
- 'Technical impact: potential escalation to cross-site scripting'
- 'Worst-case consequences: full system compromise'
- 'Quick fix: use user input filtering and output encoding'
- Directory traversal is a web vulnerability that lets a malicious hacker access and
  view files located in the web server file system but outside of the web application’s
  document root folder.
- Avoid passing any filenames in user input.
- Remote file inclusion vulnerabilities may lead to remote code execution
- Cross-site scripting (XSS) is a web vulnerability that lets a malicious hacker introduce
  (inject) undesired commands into legitimate client-side code.
- The attacker may be able to trick a legitimate user into providing their login credentials.
- SQL injection is considered one of the highest severity vulnerabilities.
- The only fully effective way to prevent SQLi vulnerabilities in web applications
  is to use parameterized queries.
- Filtering is recommended only if the content is very simple.
- In-band SQL injection is a type of SQL injection where the attacker receives the
  result as a direct response using the same communication channel.
- Stored cross-site scripting is a type of cross-site scripting where the attacker
  first sends the payload to the web application, then the application saves the payload,
  and finally, the application unintentionally executes the payload for every victim
  visiting its web pages.
- Performing an attack using blind SQL injections takes much longer than in the case
  of in-band SQL injections but can yield the same results.
- Reflected cross-site scripting is regarded as less dangerous than stored/persistent
  XSS.
- DOM-based XSS is a client-side vulnerability.
- Web application firewalls cannot protect against DOM-based XSS.
- OS command injection is a vulnerability that lets a malicious hacker trick an application
  into executing operating system (OS) commands.
- Blind cross-site scripting is a sub-type of stored/persistent cross-site scripting
  where the web application stores the payload sent by an attacker and only executes
  it later.
- To prevent blind cross-site scripting, follow overall guidelines for preventing
  cross-site scripting.
- Unvalidated redirects and forwards can lead to security vulnerabilities like phishing
  and malware.
- Open redirects are often used in phishing attempts and other social engineering
  attacks.
- Dynamic redirects are considered unsafe if the destination URL can be manipulated
  by the client.
- Local file inclusion vulnerabilities may have a variety of consequences, depending
  on the functionality of the vulnerable application.
- LFI vulnerabilities are often confused with directory traversal vulnerabilities.
- Writing escaping routines by yourself is extremely time-consuming.
- Remote code execution is a vulnerability that lets a malicious hacker execute arbitrary
  code in the programming language in which the developer wrote that application.
- Every common programming language used in web development has functions for evaluating
  (executing) code in that language at runtime.
- Stored cross-site scripting is a type of cross-site scripting (XSS) where the attacker
  first sends the payload to the web application, then the application saves the payload,
  and finally, the application unintentionally executes the payload for every victim
  visiting its web pages.
- Uses blackhat SEO techniques which can have ethical implications.
- Reflected cross-site scripting is regarded as less dangerous than stored/persistent
  XSS but can still have dire consequences.
- Expired domains can lead to impersonation and phishing attacks.
- Regular manual penetration testing is recommended to detect broken links.
- Payload never reaches the server.
- HOIC is an application-layer attack tool designed to work using only HTTP floods.
- It can attack up to 256 domains or IP addresses simultaneously.
- DDoS protection offered by cloud providers is most effective against packet flood
  attacks.
- Slow HTTP DoS attacks such as R.U.D.Y. are not commonly detected by intrusion detection
  systems.
- The Slowloris attack is an application-layer rather than network-layer type of DDoS
  attack.
- DDoS protection methods implemented at the network level to protect against such
  threats are ineffective against slow HTTP DoS attacks.
- Unvalidated redirects and forwards allow malicious hackers to exploit other attack
  vectors.
- Slowloris is an application-layer denial-of-service (DoS) cyberattack.
- Dynamic redirects can be unsafe if the destination URL can be manipulated by the
  client.
- XSS filter evasion is a collective cybersecurity term for methods that hackers use
  to bypass XSS filters in web applications.
- Do not rely on blacklisting, encoding, or methods of input validation/sanitization
  such as filtering to prevent local file inclusion.
- Never trust any input that can be manipulated by the user.
- Use a whitelist of allowed host names if the Host header must be used.
- RCE vulnerabilities may appear in any type of computer software, in almost every
  programming language, and on any platform.
- Web cache poisoning can lead to delivery of malicious payloads to users.
- Prevention includes sanitizing user inputs and configuring web caches properly.
- Source code disclosure can be caused by many different vulnerabilities and misconfigurations.
- Cookie poisoning attacks are often confused with cookie hijacking.
- Vulnerabilities from cookie poisoning cannot be detected automatically.
- Forced browsing may seem similar to directory traversal or local file inclusion
  because, in all these cases, a successful attacker can read the content of files
  on the web server.
- HOIC is a denial-of-service attack application designed by the hacktivist group
  Anonymous.
- It can attack up to 256 domains or IP addresses simultaneously using a large number
  of threads.
- As an attack tool, HOIC is much more powerful than LOIC, but it lacks certain features
  of its predecessor.
- Cookie hijacking attacks can be detected by monitoring user computers and connections.
- Prevent cookie hijacking by enforcing SSL/TLS for all pages and setting security
  flags for cookies.
- R.U.D.Y. attacks are denial-of-service attacks performed against web servers by
  sending data very slowly to generate lots of open connections and exhaust server
  resources.
- R.U.D.Y. is most effective against thread-based servers like Apache and Microsoft
  IIS, and has a much smaller impact on event-based servers like Nginx.
- Session identifiers may be vulnerable to prediction attacks if not generated securely.
- Session hijacking attacks can be detected by monitoring user computers and connections.
- Prevent session hijacking by enforcing SSL/TLS and changing session IDs after login.
- Uses application-layer DoS attack techniques against thread-based web servers.
- Attacks can leave servers unresponsive, impacting business and reputation.
- A successful session fixation attack can give an attacker access to the user’s account
  in the targeted web application.
- Web shells are not malicious scripts by their nature.
- They only become malicious if they are uploaded by an attacker.
- Source code disclosure can be caused by different types of web and network vulnerabilities.
- Ensure that directory listing functionality is turned off.
- Privilege escalation is a crucial concept in cybersecurity.
- Malicious hackers often exploit web vulnerabilities to gain access and escalate
  privileges.
- Cookie poisoning is a web application security term used to describe an attack where
  an attacker modifies the content of HTTP cookies before they are delivered from
  the user’s browser to a web application.
- The risks associated with a successful cookie poisoning attack depend on the cookie
  content and the functionality of a specific web application.
- Reverse shells can be used for legitimate purposes, such as remote server administration.
- Preventing reverse shell use is challenging; focus on securing against initial attacks.
- Never assume that a publicly accessible URL is impossible to find because it’s not
  linked or indexed. If it exists, it can be found, so authentication is always a
  must.
- Never assume that once the user is authenticated, they are a valid user and don’t
  need any other access control. For every web page and API endpoint that is accessed,
  developers must ensure that authenticated users also require authorization to access
  data or resources.
- XFS is perceived as a minor cybersecurity threat.
- Cookie hijacking occurs when an attacker gains access to the content of cookies
  by eavesdropping on user communication.
- To help prevent cookie hijacking attacks, enforce SSL/TLS for all pages and set
  security flags for cookies.
- LOIC does not rely on exploiting vulnerabilities, so web vulnerability scanners
  and network scanners are not effective at mitigating the risk of such DDoS attacks.
- Attackers may abuse clickjacking vulnerabilities to achieve many different goals.
- The only way to detect if one of your pages is being used as a tool page for a clickjacking
  attack is to analyze the server-side logs for suspicious patterns.
- Man-in-the-middle attacks are not specific to web application security and are considered
  to be a network security issue.
- Most MITM attacks are successful because the victim is not aware that such an attack
  is possible.
- Cross-site scripting vulnerabilities can make session hijacking possible.
- ARP spoofing/poisoning is an issue related to network security, not web application
  security, but it can have a major impact on the security of web servers and web
  applications.
- Session fixation attacks can allow an attacker to gain access to user accounts.
- IP spoofing is a network security problem, not a web application security issue,
  but it can have a major impact on the security of web servers and web applications.
- Safeguarding your local network from external attempts at IP address spoofing won’t
  prevent other types of attacks such as ARP spoofing, DNS spoofing, or local IP address
  spoofing.
- DNS cache poisoning is considered a type of man-in-the-middle attack (MITM)
- The only complete solution would be to globally replace DNS with DNSSEC (Domain
  Name System Security Extensions)
- Regularly check your systems for web application vulnerabilities.
- HTTP spoofing is also called HTTPS spoofing or IDN homograph attacks.
- Detecting HTTP spoofing at the endpoint is very easy if you use a modern web browser.
- Reverse shells are often used by attackers because they are not stopped by the most
  common firewall configurations.
- Cross-frame scripting is considered a very minor issue simply because it requires
  the victim to use an old, vulnerable browser version, such as Internet Explorer
  6 on Windows XP.
- While man-in-the-middle attacks are usually considered to be a network security
  issue, SSL hijacking most often affects websites and web applications (because they
  use the HTTPS protocol), so it could be considered a web application security issue.
- The targeted site has no way of preventing SSL hijacking attacks. For a web server,
  it’s not possible to distinguish between a connection coming from a real user and
  one from an attacker’s proxy.
- While man-in-the-middle attacks are usually considered to be a network security
  issue, SSL stripping typically applies to websites and web applications.
- The only way to prevent SSL stripping on the server side is to use HTTP Strict Transport
  Security (HSTS).
- Web application security is not only about eliminating vulnerabilities in the code
  and guarding against attacks.
- The way an application is deployed and configured is also critical for security.
- HSTS is considered a vital component of web security and a mandatory part of any
  security policy.
- IP spoofing attacks are not caused by any misconfigurations or vulnerabilities.
  The vulnerability is the TCP/IP protocol itself, which was designed in the early
  days of networking, before cybersecurity became a major consideration.
- SOP is a web security mechanism built into web browsers that influences how websites
  can access one another.
- SOP does not need to be turned on – it is automatically enabled in every browser
  that supports it.
- The Secure flag specifies that a cookie may only be transmitted using HTTPS connections
  (SSL/TLS encryption) and never sent in clear text.
- The SameSite flag instructs web browsers to send cookies differently depending on
  the attribute value and how a visitor interacts with the site that set the cookie.
- SSL hijacking is considered a man-in-the-middle attack technique.
- Basic cybersecurity hygiene is necessary to prevent SSL hijacking.
- SSL stripping is a type of attack where the attacker tricks the victim’s browser
  to stop it from changing its insecure HTTP connection with the target site to a
  secure HTTPS connection.
- The only way to prevent SSL stripping on the server side is to use HTTP Strict Transport
  Security (HSTS) to guarantee that insecure connections to your website or web application
  cannot be made.
- Web asset discovery identifies web assets based on a seed keyword provided by the
  user.
- WAFs function as a reverse proxy and sanitize web requests and responses.
- WAFs can mitigate OWASP Top 10 application vulnerabilities.
- HSTS is a mechanism for ensuring that your website or web application is only accessible
  using secure HTTPS (SSL/TLS) connections.
- SCA should be part of a complete security solution ecosystem.
- The Secure flag specifies that a cookie may only be transmitted using HTTPS connections.
- The SameSite flag instructs web browsers to send cookies differently depending on
  the attribute value.
- The HttpOnly flag was introduced for XSS attack mitigation.
- DAST tools can be used in CI/CD pipelines.
- SAST tools are limited to specific programming languages.
- Static application security testing is extremely prone to false positives.
- IAST may be implemented as part of automation workflows (CI/CD pipelines)
- IAST has several advantages over other testing methodologies
- WAFs should be an integral part of a web application security program.
- You should never rely on WAFs as the only means of keeping your web applications
  secure.
- Vulnerability assessment is essential for improving security posture because most
  organizations find more cybersecurity vulnerabilities than they can resolve immediately.
- SCA tools help build your software bill of materials (SBOM).
- SCA cannot be considered your primary application security tool due to its limitations.
- DAST tools can be integrated into CI/CD pipelines.
- Static application security testing tools work by running checks on the application
  code.
- SAST should be a part of a complete security testing program that includes other
  web application security testing methods.
- The F5 BIG-IP system must be able to reach UDP port 15400 on the server where NTA
  is installed.
- Ensure there are no conflicting HTTP::respond commands in other iRules assigned
  to the same Virtual Server.
- NGINX must be able to reach the TSA over UDP port 15400.
- Reconstructor must be accessible via the internal Docker network (or hostname).
- TSA must be started before NGINX starts logging to it.
- Uses OAuth2 with refresh token — requires setup of connected app in invicti
- Some API responses may include rate limits
- Ensure each Invicti Enterprise On-Premises agent has at least 4GB of dedicated RAM
  for optimal scan performance.
- Slow page load times can reveal insights into application performance during scans.
- Optimizing scan times involves a continuous process of refinement.
- Defines the maximum number of scans that can be failed at one time per account.
  The default is 100, but it can be set between 10 and 200.
- Determines the number of days before scans are automatically marked as failed. The
  default value is 14 days, but it can be adjusted within a range of 14 to 90 days.
- API requires authentication setup
- Some API calls may return nulls in deeply nested fields
- 'Maximum number of scans to be failed per batch: 100 (can be set between 10 and
  200)'
- 'Queued scan failure threshold: 14 days (can be adjusted within a range of 14 to
  90 days)'
- By default, Invicti scanners do not follow and scan data from external sources.
- Do not differentiate HTTP and HTTPS protocols if required.
- Exclude Authentication Pages if required.
- Ensure to have a valid client ID and secret for authentication.
- Some API responses may include null values
- Uses Invicti Shark (IAST) to analyze software composition
- Requires configuration of scan policies for SCA
- API requires OAuth2 authentication.
- Ensure to handle rate limits as per documentation.
- Some responses may include nested errors
- Ensure proper API key is used for authentication
- Invicti forms Knowledge Base nodes on its findings.
- Invicti products, including Invicti, do not utilize Log4j or ship Log4j.
- The best way to ensure your environment is not vulnerable is to verify that any
  presence of Log4j is a version that is not affected.
- Invicti products do not utilize Log4j
- Invicti's Java IAST component may log through host application’s logging library
- Requires configuration of API token from Atlassian.
- Ensure that you have first configured Jira integration.
- Body templates are stored in %userprofile%\Documents\Invicti\Resources\Send To Templates.
- RHEL 9 has removed support for NTLM authentication and no longer includes the gssntlmssp
  package.
- The AgentName specified in the appsettings.json file must match the unit file name
  of the agent.
- Disable SELinux before starting the installation.
- RHEL 9 has removed support for NTLM authentication.
- 'TIP: Refer to official HashiCorp documentation for more information about configuring
  Vault.'
- 'IMPORTANT: It is highly recommended that the secrets and encryption management
  service, the scan agent, and the authentication verifier agent have network connectivity
  among themselves.'
- ClamAV is optional. If you want a Invicti Enterprise scan agent to identify malware,
  you need to use it.
- The Authentication Verifier Agent is optional. Install it if you need to scan websites
  using Form, Basic, or OAuth2 authentication.
- If NTLM is used as the authentication method, Ubuntu version 24.04 or its equivalent
  must be used at a minimum.
- API Settings Overview
- Access keys and Secret keys are special tokens that allow our services to communicate
  with your AWS account through AWS API.
- If you enable Cloud integration, then your targets need to have the Agent Mode set
  to Cloud.
- Updated the Docker agent's compression method and file extension; ensure any automation
  or scripts referencing the old format are updated accordingly.
- Introduced a new setting under the Account General settings, within the Data Privacy
  and Security section, to modify the X-AMZ-Expires parameter while downloading the
  scan data
- Access keys and Secret keys are special tokens that allow services to communicate
  with your AWS account through AWS API.
- 'When using an Auth Verifier Agent, configure it as ''AgentType'': ''Cloud'' in
  the appsetting.json file.'
- The Agent type (Arm or Intel) information is now displayed on the Scan Summary page
- Fixed the HTTP 401 forbidden response form authentication error
- Fixed a scan authentication issue and a crawling issue with Cloud Agents
- Redirected support email addresses to the http://support.invicti.com/ link
- A new API Token encryption method for Agents/Verifier Agents
- CVSS 4.0 scores are now available via API
- The hash value for the '25.1.0.zip' file is provided below.
- You can verify the integrity of the file by checking its hash value.
- Enhanced DAST scanner with improved performance and vulnerability detection capabilities
- Fully redesigned user interface and experience
- 'Introduced Global Client Certificates: Admins can now add client certificates to
  the Global Certificate section and apply them directly to Scan Profiles'
- Addressed SSL errors in certificate-based environments by adding support for the
  IgnoreSslCertificateErrors parameter
- Starting September 1, 2025, HTTP Request/Response data for vulnerabilities older
  than 180 days will be removed (except for the most recent occurrence).
- Minor security patch for Authentication Verifier Service
- Uses OAuth2 with implicit flow — requires setup of connected app in Invicti
- Added new REST API endpoint (agents/listverifiers) to retrieve AV agents data
- Implemented an enhancement to capture the token information present in the response
  during the OAuth2 Implicit Flow
- Uses DAST for automated pentesting.
- Web application security scanners can only identify technical vulnerabilities.
- Use security tools
- Always install security patches
- Switch off unnecessary functionality
- Limit and secure remote access
- Use accounts with limited privileges
- Permissions and privileges
- Segregate development, testing, and live environments
- Segregate data
- Monitor and audit the servers and logs
- Stay informed
- Local file inclusion vulnerabilities can lead to access to sensitive information
  and remote code execution.
- Avoid passing filenames from user input to prevent LFI.
- OS command injection may appear in all computer software.
- Command injection vulnerabilities are a result of using operating system call functions
  with insufficient input validation.
errors:
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'QUERY_TIMEOUT: Break down filters or add selectivity'
- '401 Unauthorized: Recheck OAuth scopes or token expiration'
- '400: BadRequest'
- '401: Unauthorized'
- '403: Forbidden'
- '404: NotFound'
- '429: Too Many Requests'
- '500: Internal Server Error'
- 'INVALID_TOKEN: Check if the token is valid or expired.'
- 'FORBIDDEN: Ensure proper permissions for the requested resource.'
- '400 Bad Request: Check request parameters'
- '401 Unauthorized: Verify credentials and scopes'
- '403 Forbidden: Check your API key and permissions.'
- '404 Not Found: Verify the endpoint URL.'
- '500 Internal Server Error: Try again later.'
- '401 Unauthorized: Recheck API key or access token.'
- '403 Forbidden: Check API permissions or access rights.'
- '401 Unauthorized: Check access token and permissions.'
- 'Invalid Target URI: Ensure the Target URI does not end with multiple slashes (///)
  on the new scan page'
- 'Invalid Target URI: Recheck the Target URI format'
- 'REQUEST_LIMIT_EXCEEDED: Throttle API calls or reduce frequency.'
- 'QUERY_TIMEOUT: Break down filters or add selectivity.'
- '401 Unauthorized: Check your API key and permissions.'
- '404 Not Found: Verify the endpoint path.'
- '429 Too Many Requests: Reduce the frequency of requests.'
- If you believe we have not processed your personal information in accordance with
  applicable law, you may lodge a complaint.
- 'Excessive Requests: If requests from a consumer are manifestly unfounded or excessive,
  we may either charge a reasonable fee, or refuse to act on the request.'
- 'AUTHENTICATION_FAILED: Check client credentials or token expiration'
- False positives lead to wasted developer time.
- Misconfigured local configuration files can lead to vulnerabilities.
- '401 Unauthorized: Verify OAuth token'
- '403 Forbidden: Check access rights'
- '401 Unauthorized: Check OAuth credentials.'
- '403 Forbidden: Ensure permission scopes are granted.'
- ineffective and easy for attackers to circumvent
- create a false sense of security and discourage developers
- SQL injection can lead to full system compromise.
- Access to sensitive data stored in the database.
- 'Access to privileged resources: Malicious hackers usually use SSRF attacks to target
  internal resources with private IP addresses or located behind firewalls.'
- 'Hiding the real source of the connection: This way, access attempts appear to originate
  from the back-end of the local application that is vulnerable to SSRF.'
- Access to sensitive data stored in the database, such as passwords and/or credit
  card numbers.
- Access to information about the database and operating system to aid further attacks.
- 'CWE-918: Server-side request forgery'
- '401 Unauthorized: Recheck OAuth scopes or token expiration.'
- '403 Forbidden: Check API key and permissions.'
- '404 Not Found: Verify endpoint and resource availability.'
- 'RATE_LIMIT_EXCEEDED: Throttle API calls or reduce frequency'
- 'RATE_LIMIT_EXCEEDED: Reduce frequency of API calls'
- 'INVALID_CREDENTIALS: Check your client_id and client_secret'
- No way to mitigate zero-day DOM-based XSS attacks.
- Potential attack if the application generates password reset links in an unsafe
  way.
- '404 Not Found: Check the endpoint URL'
- '403 Forbidden: Access denied to the requested resource'
- Server-side JSON injection may lead to privilege escalation and full system compromise.
- Client-side JSON injection may lead to cross-site scripting attacks.
- Reflected XSS attacks can lead to credential theft and damage to the application's
  reputation.
- 'Severity: severe in rare circumstances'
- 'Prevalence: discovered rarely'
- 'XSS vulnerability: Ensure proper input validation and sanitization.'
- Attackers can use CRLF injections to escalate to other types of vulnerabilities,
  primarily cross-site scripting (XSS).
- SQL injections can lead to full system compromise.
- 'Unauthorized access: Ensure proper access control checks to avoid IDOR vulnerabilities.'
- Directory listing may lead to the exposure of sensitive information.
- You have an error in your SQL syntax; check the manual that corresponds to your
  MySQL server version for the right syntax to use near ' ...
- 'Warning: mysql_fetch_array() expects parameter 1 to be resource, boolean given
  in /hj/var/www/query.php on line 37'
- JSON injection attacks happen when unsanitized JSON data containing a malicious
  payload is accepted and parsed by a web application or browser.
- NoSQL injection may allow an attacker to gain full control over the application.
- CRLF injection can lead to log poisoning and HTTP response splitting
- SQL injection vulnerabilities allow malicious hackers to introduce unexpected SQL
  code into SQL queries executed by an application.
- You have an error in your SQL syntax; check the manual that corresponds to your
  MySQL server version for the right syntax to use near '' at line 1
- Stored cross-site scripting is the most dangerous of all XSS types simply because
  it reaches the largest number of users.
- No specific error codes mentioned.
- Access to privileged resources may lead to full system compromise.
- 'Phishing: Redirecting users to malicious sites.'
- 'Malware: Leading users to download harmful software.'
- 'XSS: Exploiting redirects to perform cross-site scripting attacks.'
- 'SSRF: Using unvalidated redirects to bypass security filters.'
- 'CWE 601: Open Redirect'
- 'WASC 38: Unvalidated Redirects and Forwards'
- 'CWE: 23'
- 'CWE-98: Improper control of filename for include/require statement in PHP program'
- No specific error codes or messages provided.
- Potential web vulnerabilities could lead to exploitation in SEO poisoning.
- Application-layer attacks cannot be detected or prevented using typical DDoS protection
  mechanisms.
- '408 REQUEST TIMEOUT: The server replies with a 408 error if a client fails to send
  header or body data within the configured time.'
- 'Phishing: The most straightforward use for an unvalidated redirect or forward is
  to take the victim away from the original webpage.'
- 'Malware: An attacker may lead a user to a malicious URL.'
- 'Cross-site scripting (XSS): Attackers could conduct an XSS attack.'
- '408 REQUEST TIMEOUT: Client failed to send header or body data within the configured
  time.'
- Potential for phishing attacks using open redirects.
- May allow exploitation of other vulnerabilities such as XSS, SSRF, or CRLF injection.
- '400 Bad Request: Check the request format.'
- '500 Internal Server Error: Server error, try again later.'
- Vulnerabilities can lead to XSS attacks.
- DoS attacks can occur if the cache is not configured to handle ports properly.
- Forced browsing attacks may allow an attacker to access crucial information by using
  predictable resource locations in the form of common directory names.
- 'SESSION_EXPIRED: Re-authenticate the user to establish a new session.'
- 'COOKIE_NOT_FOUND: Ensure cookies are being set and sent correctly.'
- 'SESSION_ID_TOO_SHORT: Increase the length of session IDs to enhance security.'
- 'PREDICTABLE_SESSION_ID: Ensure session IDs are generated using secure algorithms.'
- Unauthorized access can lead to identity theft and exposure of sensitive information.
- '408 REQUEST TIMEOUT: Client failed to send header or body data in time.'
- 'Unauthorized: Recheck security configurations or access permissions.'
- 'CWE-540: Inclusion of Sensitive Information in Source Code'
- Unauthorized access may indicate an attempt to establish a reverse shell.
- No way to detect that you are a victim of HTTP spoofing from the point of view of
  the domain owner.
- The browser warns you that the certificate is not valid and often there is no way
  to manually override the warning.
- No known error codes provided.
- HSTS will make your domain inaccessible to browsers if the pages are not accessible
  via HTTPS.
- False positives can be a problem in automated security testing.
- 'QUERY_TIMEOUT: Break down filters or increase selectivity'
- '401 Unauthorized: Check credentials'
- '404 Not Found: Verify endpoint path'
- '500 Internal Server Error: Retry after some time'
- '401 Unauthorized: Check your credentials.'
- '401 Unauthorized: Check OAuth scopes or token expiration'
- '429 Too Many Requests: Throttle API calls'
- 'Unauthorized: Check user permissions'
- 'Not Found: Verify the endpoint and resource ID'
- '401 Unauthorized: Check your token and permissions.'
- '429 Too Many Requests: Implement exponential backoff.'
- '400 Bad Request: Check input validation errors'
- '401 Unauthorized: Verify API key or token'
- '500 Internal Server Error: Contact support'
- 'INVALID_REQUEST: Check the request structure and parameters'
- 'FORBIDDEN: Verify API permissions and access rights'
- Log4j 2.17.1 addresses a malicious configuration change that can conditionally lead
  to remote code exploitation.
- '401 Unauthorized: Check API token and user credentials.'
- '400 Bad Request: Ensure all mandatory fields are filled.'
- RHEL 9 will not be capable of handling NTLM authentication.
- 'Invalid Target URI: Ensure the Target URI does not end with multiple slashes (///)'
- 'Invalid Target URI: Check the format of the Target URI'
- 'Internal Server Error: encountered on the Invicti scans/report API endpoint after
  enabling the Prevent any sensitive information showing within the product setting'
- 'Invalid Target URI: Check the Target URI for multiple slashes'
- Fixed an issue with retrieving OAuth2 token data from JSON responses
- 'HTTP 401 forbidden: Recheck OAuth scopes or token expiration'
- 'HTTP 413: Request entity too large'
- 'HTTP 504: Gateway timeout'
- 'Internal Server Error: encountered on the Invicti scans/report API endpoint after
  enabling the ''Prevent any sensitive information showing within the product'' setting'
- '429 Too Many Requests: Throttle API calls or reduce frequency'
- 'HTTP 401 forbidden: Recheck authentication settings'
- 'HTTP 401 forbidden: Check authentication settings'
- '413 Payload Too Large: Reduce request size'
- '504 Gateway Timeout: Check server response time'
- HTTP 401 forbidden response form authentication error
- 'Invalid Target URI: occurred when editing the Target URI to end with multiple slashes
  (///) on the new scan page'
- 'Unauthorized access: Ensure proper input validation to avoid LFI.'
- Very severe vulnerability.
- Discovered regularly.
auth_info:
  mentioned_objects:
  - OauthToken
  - AuthProvider
  - NamedCredential
client:
  base_url: https://www.invicti.com
  auth:
    type: oauth2
    flow: refresh_token
    token_url: https://login.invicti.com/oauth/token
    client_id: '{{ dlt.secrets[''invicti_client_id''] }}'
    client_secret: '{{ dlt.secrets[''invicti_client_secret''] }}'
    refresh_token: '{{ dlt.secrets[''invicti_refresh_token''] }}'
    location: header
    header_name: Authorization
  headers:
    Accept: application/json
source_metadata: null
